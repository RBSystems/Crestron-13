/*******************************************************************************************
  SIMPL+ Module Information
  (Fill in comments below)
*******************************************************************************************/
/*
Dealer Name:
System Name:
System Number:
Programmer:
Comments:
*/

/*******************************************************************************************
  Compiler Directives
  (Uncomment and declare compiler directives as needed)
*******************************************************************************************/
//#SYMBOL_NAME ""
// #HINT ""
#DEFINE_CONSTANT TRUE   1
#DEFINE_CONSTANT FALSE  0

#DEFINE_CONSTANT SCHED_RESPONSE_BUF		65534
#DEFINE_CONSTANT CREATE_RESPONSE_BUF	1000
#DEFINE_CONSTANT ACTION_RESPONSE_BUF	1000

#DEFINE_CONSTANT MAX_STORED_EVENTS 			48
#DEFINE_CONSTANT MAX_TIME_BLOCKS 				48
#DEFINE_CONSTANT MAX_NAME_LEN 					100
#DEFINE_CONSTANT MAX_WELCOME_MSG_LEN 		150
#DEFINE_CONSTANT MAX_SUBJECT_LEN 				255
#DEFINE_CONSTANT MAX_ORGANIZER_LEN			100
#DEFINE_CONSTANT MAX_TEMP_SUBJECT_LEN 	1500
#DEFINE_CONSTANT MAX_ATTENDEES 					10
#DEFINE_CONSTANT MAX_MEETING_ID_LEN			125
#DEFINE_CONSTANT MAX_INSTANCE_ID_LEN		170
#DEFINE_CONSTANT MAX_RV_MEETING_ID_LEN 	50
#DEFINE_CONSTANT MAX_RV_DATE_FORMAT_LEN 19
#DEFINE_CONSTANT MAX_ROOM_NAME_LEN			100

#DEFINE_CONSTANT MAX_PRESET_NAME_LEN				50
#DEFINE_CONSTANT MAX_PRESET_FIELD_DATA_LEN	150

#DEFINE_CONSTANT REQUEST_MODE_IDLE				0
#DEFINE_CONSTANT REQUEST_MODE_BUSY				1
#DEFINE_CONSTANT REQUEST_MODE_PROCESSING	2
#DEFINE_CONSTANT REQUEST_MODE_SUCCESS			3
#DEFINE_CONSTANT REQUEST_MODE_FAILURE			4



#DEFINE_CONSTANT NONE            0
#DEFINE_CONSTANT INROOMDISC      1
#DEFINE_CONSTANT ACONF           2
#DEFINE_CONSTANT INROOMPRES      3
#DEFINE_CONSTANT VCONF           4
#DEFINE_CONSTANT MULTIPOINT      5 

#DEFINE_CONSTANT LINE_MODE_INACTIVE 0
#DEFINE_CONSTANT LINE_MODE_ACTIVE   1
#DEFINE_CONSTANT LINE_MODE_BLANK    2

#DEFINE_CONSTANT RESPONSE  	1
#DEFINE_CONSTANT REQUEST  	2

#DEFINE_CONSTANT SCHED_NODE_ROOT         			1
#DEFINE_CONSTANT SCHED_NODE_MEETING         	2
#DEFINE_CONSTANT SCHED_NODE_LIVE_MEETING     	3
#DEFINE_CONSTANT SCHED_NODE_MEETING_SUBJECT 	4
#DEFINE_CONSTANT SCHED_NODE_WELCOME_MSG      	5
#DEFINE_CONSTANT SCHED_NODE_RESOURCES			   	6
#DEFINE_CONSTANT SCHED_NODE_ATTENDEES			  	7

#DEFINE_CONSTANT ACTION_NODE_ROOT							0
#DEFINE_CONSTANT ACTION_NODE_MEETING_ID				1
#DEFINE_CONSTANT ACTION_NODE_PUSH_REGISTER		2
#DEFINE_CONSTANT ACTION_NODE_MEETING_CHANGE		3
#DEFINE_CONSTANT ACTION_NODE_SUBSCRIPTION			4
#DEFINE_CONSTANT ACTION_NODE_BACKLOG					5	

#DEFINE_CONSTANT REQUEST_TODAY					1
#DEFINE_CONSTANT REQUEST_PUSH						2
#DEFINE_CONSTANT REQUEST_NEXT_RESERV		3
#DEFINE_CONSTANT REQUEST_FIRST_APPT			4	
#DEFINE_CONSTANT REQUEST_AUTO_UPDATE		5
#DEFINE_CONSTANT REQUEST_MEETING_INFO		6
#DEFINE_CONSTANT REQUEST_IS_PRIVATE			7

#DEFINE_CONSTANT ROOM_PUBLIC								0
#DEFINE_CONSTANT ROOM_SEMI_PRIVATE					1
#DEFINE_CONSTANT ROOM_PRIVATE								2
#DEFINE_CONSTANT ROOM_SEMI_PRIVATE_NO_RNOW	3
#DEFINE_CONSTANT ROOM_PRIVATE_NO_RNOW				4

#DEFINE_CONSTANT TYPE_WORKDAY			0
#DEFINE_CONSTANT TYPE_AUTO_UPDATE	1

#DEFINE_CONSTANT CREATE_TYPE_RESERVE_NOW	0
#DEFINE_CONSTANT CREATE_TYPE_USER					1

#DEFINE_CONSTANT LIST_TYPE_INFO_MOD	1
#DEFINE_CONSTANT LIST_TYPE_UI_MOD		2

#DEFINE_CONSTANT TYPE_MEETING_ID	1
#DEFINE_CONSTANT TYPE_INSTANCE_ID	2	

#DEFINE_CONSTANT TIME_FORMAT_DD_HH_MM			1
#DEFINE_CONSTANT TIME_FORMAT_HH_MM				2

#DEFINE_CONSTANT REM_SYS_DATA_WORKDAY								1
#DEFINE_CONSTANT REM_SYS_DATA_CURR_MEETING					2
#DEFINE_CONSTANT REM_SYS_DATA_NEXT_RESERV						3
#DEFINE_CONSTANT REM_SYS_DATA_END_MEETING_WARN			4
#DEFINE_CONSTANT REM_SYS_DATA_DATE_TIME							5

#DEFINE_CONSTANT MEETING_INFO_CURRENT								1
#DEFINE_CONSTANT MEETING_INFO_NEXT									2

#DEFINE_CONSTANT MEETING_INFO_REQUEST_ATTENDEES			1
#DEFINE_CONSTANT MEETING_INFO_REQUEST_PRESET_DATA		2

#DEFINE_CONSTANT TIME_FORMAT_HHMM  1
#DEFINE_CONSTANT TIME_FORMAT_MINS  2


// #CATEGORY "" 
#DEFAULT_VOLATILE
//#DEFAULT_NONVOLATILE
//#PRINT_TO_TRACE
#ENABLE_STACK_CHECKING
#ENABLE_TRACE
/*
#HELP_BEGIN
   (add additional lines of help lines)
#HELP_END
*/

/*******************************************************************************************
  Include Libraries
  (Uncomment and include additional librarys as needed)
*******************************************************************************************/
// #CRESTRON_LIBRARY ""
// #USER_LIBRARY ""

/*******************************************************************************************
  DIGITAL, ANALOG and SERIAL INPUTS and OUTPUTS
  (Uncomment and declare inputs and outputs as needed)
*******************************************************************************************/
DIGITAL_INPUT Debug_Logic,
              Debug_Print_Work_Events,
              Debug_Print_AutoUpdate_Events,
              Debug_Force_Reserve_Now,
			  Debug_Preset_Data, 
              Initialize_Module,
              Config_En_Decline_For_NoShow,
							Config_Decline_For_NoShow_En_CheckAtExactMin,
              Config_En_Reserve_Now,
              Config_En_StartMeeting,
              Config_En_FreeUpRoom,
              Time_Format,
              En_FreeBusy_AttributeData,
              RoomView_Online_FB,
              Room_Occupied_FB,
              Check_Room_Status,
              Get_Schedule,
              Schedule_Request_Timeout,
              Reserve_Now,
							Reserve_Now_Even_End_Time,
							Reserve_Now_Time_Select,
              Reserve_Now_Select_30,
              Reserve_Now_Select_60,
              Reserve_Now_Select_90,
              Reserve_Now_Yes,
              Reserve_Now_Timeout,
              End_Meeting_Btn,
              End_Meeting_Confirm_YES,
              End_Meeting_Confirm_NO,
              End_Meeting_Timeout,
              Start_Meeting_Btn,
              Start_meeting_Confirm_YES,
              Start_Meeting_Confirm_NO,
              Register_Push,
              Unregister_Push,
              Register_Push_Timeout,
              Auto_Update_Push_Start,
              Auto_Update_Get_Schedule,
              Auto_Update_Request_Timeout,
              Get_Current_Meeting_Info,
              Get_Current_Meeting_Info_Timeout,
              Get_Current_Meeting_Preset_Data_Timeout,
              Get_Next_Meeting_Info,
              Get_Next_Meeting_Info_Timeout;
 
ANALOG_INPUT Privacy_Level,
						 Column_Width,
						 Field_Qty,
             Date_Format,
						 Current_Page,
             Meeting_Active_Window_Value,
             End_Next_Meeting_Warn_Time,
             Reserve_Now_Duration,
             Decline_Applies_Duration,
             Decline_Meeting_Min,
             Decline_Meeting_Percent,
             Serial_Pacing_Time,
             Meeting_Preset_Start_Time;
              
STRING_INPUT Default_Subject$[MAX_SUBJECT_LEN],
             Default_Organizer$[MAX_NAME_LEN],
             Reserve_Now_Subject$[MAX_SUBJECT_LEN],
             Reserve_Now_Organizer$[MAX_NAME_LEN],
             Room_Name$[MAX_ROOM_NAME_LEN],
             From_MeetingPreset_Mod_DataOut$[255],
             From_Remote_Sys_Mod_DataOut$[255];
  
BUFFER_INPUT From_RV_ScheduleResponse$[SCHED_RESPONSE_BUF],
             From_RV_CreateResponse$[CREATE_RESPONSE_BUF],
             From_RV_ActionResponse$[ACTION_RESPONSE_BUF]; 

DIGITAL_OUTPUT Initialize_Module_Busy_FB,
               Push_Triggered_Check_Room_Status,
               Have_Valid_Workday_Sched,
               Schedule_Updated,
               Meeting_Started,
               Meeting_Active,
               Current_Meeting_Private,
               Have_Next_Reservation,
               Next_Reservation_Private,
               End_Meeting_Warn_FB,
               Enable_Reserve_Now,
               Set_Reserve_Now_Confirm,
               Set_Reserve_Now_Select,
               End_Meeting_Btn_Sub,
               End_Meeting_Btn_FB,
               End_Meeting_Confirm_Sub,
               Start_Meeting_Btn_Sub,
               Start_Meeting_Btn_FB,
               Start_Meeting_Confirm_Sub,
               Auto_Update_Need_Sched,
               Auto_Update_Process_Active,
               EWS_Subscription_Offline_FB,
               RoomService_Backlog_Active_FB;
                
ANALOG_OUTPUT Workday_Sched_Request_Mode,
							Next_Reserv_Request_Mode,
							First_Appt_Request_Mode,
						  Reserve_Now_Request_Mode,
              Reserve_Now_Select_30_Mode,
              Reserve_Now_Select_60_Mode,
              Reserve_Now_Select_90_Mode,
              End_Meeting_Request_Mode,
						  Register_Push_Request_Mode,
						  Current_Meeting_Info_Request_Mode,
						  Current_Meeting_Preset_Data_Request_Mode,
						  Next_Meeting_Info_Request_Mode,
						  Auto_Update_Request_Mode,
							Current_Time_Bargraph_Value,
							End_Meeting_Warn_Countdown_Seed,
							Processed_Push_Responses,
						  Processed_RV_Forced_Refresh,
							Current_Time_Hour,
              Current_Time_Minute,
              Current_Meeting_Duration_Min,
              Current_Meeting_Elapsed_Time,
              Current_Meeting_Elapsed_Percent;
               
STRING_OUTPUT To_RV_ScheduleQuery$,
              To_RV_CreateMeeting$,
              To_RV_ActionQuery$,
              To_RV_FreeBusy_AttributeData$,
              To_NoShow_Mod_DataIn$,
              To_MeetingPreset_Mod_DataIn$,
              To_UI_Mod_DataIn$,
              To_Avail_Rooms_Mod_DataIn$,
              To_Remote_Sys_Mod_DataIn$,
              Current_Time$,
              Current_Date$,
              Last_Received_Schedule_Time_Date$,
              Schedule_Label$,
              CurrentTime_Meeting_ID$,
              CurrentTime_RVMeeting_ID$,
              Current_Meeting_Meeting_ID$,
              Current_Meeting_RVMeeting_ID$,
              Current_Meeting_Organizer$,
              Current_Meeting_Subject$,
              Current_Meeting_Start_Date$,
              Current_Meeting_Start_Time$,
              Current_Meeting_End_Date$,
              Current_Meeting_End_Time$,
              Current_Meeting_Required_Attendees$,
              Current_Meeting_Optional_Attendees$,
              Current_Meeting_StartEnd$,
              Current_Meeting_Welcome_Msg$,
              Next_Reservation_In$,
              Next_Reservation_Organizer$,
              Next_Reservation_Subject$,
              Next_Reservation_Start_Date$,
              Next_Reservation_Start_Time$,
              Next_Reservation_End_Date$,
              Next_Reservation_End_Time$,
              Next_Reservation_Required_Attendees$,
              Next_Reservation_Optional_Attendees$,              
              Next_Reservation_HrMin$,
              Next_Reservation_Date$,
              Next_Reservation_DateTime$,
              Time_Remaining_HrMin$,
              Reserve_Now_Select_30$,
              Reserve_Now_Select_60$,
              Reserve_Now_Select_90$,
              Reserve_Now_Start_Time$,
              Reserve_Now_End_Time$,
              Last_Processed_Push_Response_DateTime$,
              Reserve_Now_Message$,
              EWS_Subscription_Offline_Msg$,
              RoomService_Backlog_Active_Msg$;


// *** Array Defs ***
ANALOG_OUTPUT Time_Block_Mode[MAX_TIME_BLOCKS];
STRING_OUTPUT Time_Block_Text$[MAX_TIME_BLOCKS];

/*******************************************************************************************
  Structure Definitions
  (Uncomment and define structure definitions as needed)
  Note:  Be sure to initialize all declared STRING variables as needed
         For example, in Function Main: struct.myString = "";
*******************************************************************************************/
STRUCTURE EventData
{
  string MeetingID[MAX_MEETING_ID_LEN];
  string RVMeetingID[MAX_RV_MEETING_ID_LEN];
  string InstanceID[MAX_INSTANCE_ID_LEN];
  
  integer StartBlock;
  integer EndBlock;
  
  string StartDate[10];
  string EndDate[10];
  string StartTime[8];
  string EndTime[8];
  
  string Subject[MAX_SUBJECT_LEN];
  
  integer IsPrivate;
  integer IsExchangePrivate;
  
  string Organizer[MAX_ORGANIZER_LEN];
  
  integer Recurring;
};

EventData MeetingEvent[MAX_STORED_EVENTS];
EventData AutoUpdateMeetingEvent[MAX_STORED_EVENTS];
EventData TempMoveEvent;

STRUCTURE NextData
{
	string MeetingID[MAX_MEETING_ID_LEN];
	string InstanceID[MAX_INSTANCE_ID_LEN];
	
	string StartDate[10];
  string StartTime[10];
  
	string EndDate[10];
  string EndTime[10];
  
  string Subject[MAX_SUBJECT_LEN];
  
  integer IsPrivate;
  integer IsExchangePrivate;
  
  string Organizer[MAX_ORGANIZER_LEN];  
};

NextData NextEvent;

STRUCTURE ReserveNowData
{
  integer iStartYear,
          iStartMonth,
          iStartDay,
          iStartHour,
          iStartMin,
          iStartSec;
          
  integer iEndYear,
          iEndMonth,
          iEndDay,
          iEndHour,
          iEndMin,
          iEndSec;
};

ReserveNowData ConfirmEvent,
               Select30Min,
               Select60Min,
               Select90Min;

/*******************************************************************************************
  Global Variables
  (Uncomment and declare global variables as needed)
  Note:  Be sure to initialize all declared STRING variables as needed
         For example, in Function Main: myString = "";
*******************************************************************************************/
INTEGER g_bRXOK1,
        g_bRXOK2,
        g_bRXOK3,
        g_bHaveAutoUpdateSchedule,
        g_bEndedWhileActive,
        g_bPushEnabled,
        g_bNeedFirstApptRequest,
        g_bWaitingToSendInfoEventList,
        g_bWaitingToSendUIEventList,
        g_bNeedAnotherWorkdayRequest,
        g_bWaitingToSendRVData,
        g_bHaveMeetingPresetModule,
        g_bHaveRemoteSysModule;


STRING g_sRXData1[SCHED_RESPONSE_BUF],
       g_sRXData2[CREATE_RESPONSE_BUF],
       g_sRXData3[ACTION_RESPONSE_BUF];

STRING g_sMonth[12][10],
       g_sDateToday[10],
       g_sAutoUpdateDate[10],
       g_sCurrentTime[8];

INTEGER g_iBlockEventIndex[MAX_TIME_BLOCKS];
        
// *** Request Data ***

STRING g_sReqStartTime[8],
       g_sReqHourSpan[2];

       
INTEGER g_iStoredEventCount,
				g_iAutoUpdateStoredEventCount,
				g_iCurrentEventNum,
        g_iStartedEventNum,
        g_iStartedEventTime; 

STRING g_sStartedEventID[MAX_MEETING_ID_LEN];

INTEGER g_iCurrentHour,
        g_iCurrentMinute,
        g_iCurrentTime,
        g_iCurrentTimeMin,
        g_iCurrentTimeBlock;

STRING g_sScheduleRequestID[45],
			 g_sPushRequestID[45],
       g_sReserveNowRequestID[45],
       g_sEndMeetingRequestID[45],
       g_sActionRVIDRequestID[45],
       g_sActionPushRequestID[45],
       g_sNextReservRequestID[45],
       g_sFirstApptRequestID[45],
       g_sIsPrivateRequestID[45],
       g_sAutoUpdateRequestID[45],
       g_sCurrentMeetingInfoRequestID[45],
       g_sCurrentMeetingPresetDataRequestID[45],
       g_sNextMeetingInfoRequestID[45],
       g_sNextMeetingPresetDataRequestID[45];

INTEGER g_bReserveNowSuccessNeedSched;

STRING g_sReserveNowStartTime[10],
			 g_sReserveNowEndTime[10],
			 g_sReserveNowMeetingID[MAX_MEETING_ID_LEN];

String g_sEndMeetingReqMeetingID[MAX_MEETING_ID_LEN],
       g_sCurrentMeetingID[MAX_MEETING_ID_LEN];
       
Integer g_bStartMeetingConfirmed;

INTEGER g_iEffStartTime, g_iEffDeltaTime;

//INTEGER g_iExtendedEventNum; Not suporting meeting extensions anymore

STRING g_sLastSentNoShowID[MAX_MEETING_ID_LEN],
			 g_sLastSentNoShowDate[10],
			 g_sLastSentGetMeetingID[MAX_MEETING_ID_LEN],
			 g_sLastSentGetPresetDataID[MAX_MEETING_ID_LEN];

STRING g_sNextReservRequestDate[10],
			 g_sAutoUpdateRequestDate[10];

STRING g_sFirstApptStartDate[10];

STRING g_sXML[1000];

STRING g_sReserveNowDTStart[20],
			 g_sReserveNowDTEnd[20];

STRING g_sCurrentMeetingWelcomeMsgID[MAX_MEETING_ID_LEN],
			 g_sCurrentWelcomeMsg[MAX_WELCOME_MSG_LEN];

INTEGER g_iLastSentGetPresetDataIndex;

/*******************************************************************************************
  Functions
  (Add any additional functions here)
  Note:  Functions must be physically placed before the location in
         the code that calls them.
*******************************************************************************************/

Function PrintEvents(integer iType)
{
  integer i;
  
  if (iType = TYPE_WORKDAY)
  {
  	trace ("\n** Work Events Stored:%u **\n", g_iStoredEventCount);
  	
  	for (i = 1 to g_iStoredEventCount)
  	{
    	trace("    Event %u:\n", i);
    	trace("     MeetingID:%s\n", MeetingEvent[i].MeetingID); 
    	trace("     StartBlock:%u\n", MeetingEvent[i].StartBlock);
    	trace("     EndBlock:%u\n", MeetingEvent[i].EndBlock);
    	trace("     StartDate:%s\n", MeetingEvent[i].StartDate);
    	trace("     StartTime:%s\n", MeetingEvent[i].StartTime);
    	trace("     EndDate:%s\n", MeetingEvent[i].EndDate);
    	trace("     EndTime:%s\n", MeetingEvent[i].EndTime);
    	trace("     Subject:%s\n", MeetingEvent[i].Subject);
    	trace("     Organizer:%s\n", MeetingEvent[i].Organizer );
    	trace("     Recurring:%u\n", MeetingEvent[i].Recurring );
  	}
  	
  }
  else if (iType = TYPE_AUTO_UPDATE)
  {
  	trace ("\n** Auto Update Events Stored:%u **\n", g_iAutoUpdateStoredEventCount);
  	
  	for (i = 1 to g_iAutoUpdateStoredEventCount)
  	{
    	trace("    Event %u:\n", i);
    	trace("     MeetingID:%s\n", AutoUpdateMeetingEvent[i].MeetingID);
    	trace("     StartBlock:%u\n", AutoUpdateMeetingEvent[i].StartBlock);
    	trace("     EndBlock:%u\n", AutoUpdateMeetingEvent[i].EndBlock);
    	trace("     StartDate:%s\n", AutoUpdateMeetingEvent[i].StartDate);
    	trace("     StartTime:%s\n", AutoUpdateMeetingEvent[i].StartTime);
    	trace("     EndDate:%s\n", AutoUpdateMeetingEvent[i].EndDate);
    	trace("     EndTime:%s\n", AutoUpdateMeetingEvent[i].EndTime);
    	trace("     Subject:%s\n", AutoUpdateMeetingEvent[i].Subject);
    	trace("     Organizer:%s\n", AutoUpdateMeetingEvent[i].Organizer );
    	trace("     Recurring:%u\n", AutoUpdateMeetingEvent[i].Recurring );
  	} 	
  }
}

/////////////////////////////////////////////////////////////////////
//
// Function: ClearCalendar()
//
// Parameters: StartBlock, EndBlock
//
// Return Value: <none>
//
// Description: Clears the calendar UI from StartBlock to EndBlock.
//
//
/////////////////////////////////////////////////////////////////////

Function ClearCalendar(integer iStartBlock, integer iEndBlock)
{
	integer i;
	
	if (Debug_Logic)
	{
		trace ("\n** ClearCalendar **\n");
		trace ("  StartBlock:%u\n", iStartBlock);
		trace ("  EndBlock:%u\n", iEndBlock);
	}
	
	for (i = iStartBlock to iEndBlock)
	{
		g_iBlockEventIndex[i] = 0;
		
		Time_Block_Mode[i] = 0;
		Time_Block_Text$[i] = "";
	}
}


/////////////////////////////////////////////////////////////////////
//
// Function: DaysInMonth()
//
// Parameters: Month, Year
//
// Return Value: Days in Month
//
// Description: Returns the days for a given month.
//
//
/////////////////////////////////////////////////////////////////////

Integer_Function DaysInMonth(integer iMonth, integer iYear)
{
  integer iDays;
  
  iDays = 0;
  
  if (Debug_Logic)
  {
  	trace ("\n** DaysInMonth **\n");
  	trace ("  Month:%u\n", iMonth);
  	trace ("  Year:%u\n", iYear);
  }
  
  cswitch (iMonth)
  {
    case(1): //january
    {
      iDays = 31;
      break;
    }
    case(2): //february
    {
      if (iYear mod 4 = 0)
      {
        iDays = 29;
        break;
      }
      else
      {
        iDays = 28;
        break;      
      }
    }
    case(3): //march
    {
      iDays = 31;
      break;
    }
    case(4): //april
    {
      iDays = 30;
      break;
    }
    case(5): //may
    {
      iDays = 31;
      break;
    }
    case(6): //june
    {
      iDays = 30;
      break;
    }
    case(7): //july
    {
      iDays = 31;
      break;
    }
    case(8): //august
    {
      iDays = 31;
      break;
    }
    case(9): //september
    {
      iDays = 30;
      break;
    }
    case(10): //october
    {
      iDays = 31;
      break;
    }
    case(11): //november
    {
      iDays = 30;
      break;
    }
    case(12): //december
    {
      iDays = 31;
      break;
    }
  }
  
  if (Debug_Logic)
  {
  	trace ("  Days:%u\n", iDays);
  }
  
  return (iDays);  
}

/////////////////////////////////////////////////////////////////////
//
// Function: FormatDate()
//
// Parameters: Data, Format
//
// Return Value: Formatted date
//
// Description: Returns formatted date from UTC Date.
//
//
/////////////////////////////////////////////////////////////////////

String_Function FormatDate(string sData, integer iFormat)
{
  string sLocalCopy[10], sDate[10];
  integer iMonth;
  string  sYear[4], sMonth[2], sMonthName[9], sDay[2];
  
  iMonth = atoi(mid(sData, 6, 2)); 
  
  sYear = left(sData, 4);
  sMonth = mid(sData, 6, 2);
  sMonthName = g_sMonth[iMonth];
  sDay = right(sData, 2);
  
  iFormat = iFormat + 2*(Date_Format);
  
  if (Debug_Logic)
  {
  	print ("\n** FormatDate **\n");
  	print ("  Data:%s\n", sData);
  	print ("  Format:%u\n", iFormat);
  }

  
  if (iFormat = 1) //format = "FullMonth DD, YYYY"
  {
    sDate = sMonthName + " " + sDay + ", " + sYear;
  }
  else if (iFormat = 2) //format = "MM/DD/YYYY"
  {
    sDate = sMonth + "/" + sDay + "/" + sYear;
  }
  
  else if (iFormat = 3) //format = "DD Full Month YYYY"
  {
    sDate = sDay + " " + sMonthName + " " + sYear;
  }
  else if (iFormat = 4) //format = "DD/MM/YYYY"
  {
    sDate = sDay + "/" + sMonth + "/" + sYear;
  }
  
  else if (iFormat = 5) //format = "YYYY, Full Month DD"
  {
    sDate = sYear + ", " + sMonthName + " " + sDay;
  }
  else if (iFormat = 6) //format = "YYYY/MM/DD"
  {
    sDate = sYear + "/" + sMonth + "/" + sDay;
  }
  
  if (Debug_Logic)
  {
  	print ("  Formatted Date:%s\n", sDate);
  }
  
  return (sDate);
}
 
/*
String_Function DayofWeek(string sDate)
{
  Integer TotalDays;
}
*/

/////////////////////////////////////////////////////////////////////
//
// Function: IToLA()
//
// Parameters: Number as Integer (2 digit only)
//
// Return Value: Number as String
//
// Description: Converts a 2-digit integer to string with leading zeros
//
//
/////////////////////////////////////////////////////////////////////
String_Function IToLA(integer iNumber)
{
	string sNumber[2];
	
	if (iNumber < 10)
	{
		sNumber = "0" + itoa(iNumber);
	}
	else
	{
		sNumber = itoa(iNumber);
	}
	
	return (sNumber);
}

/////////////////////////////////////////////////////////////////////
//
// Function: FormatTime()
//
// Parameters: Data
//
// Return Value: Time
//
// Description: Returns formatted time based on type specified.
//
//
/////////////////////////////////////////////////////////////////////

String_Function FormatTime(string sData)
{
  integer iHour, iMinute;
  string sHour[2], sMinute[2], sAMPM[2];
  string sTime[8];
  
  iHour = atoi(left(sData, 2));
  iMinute = atoi(right(sData, 2));
	
  //Regular or Army?
  if (Time_Format)
  { //Army
   sHour = ItoLA(iHour);
   sAMPM = "";
  }
  else
  { //Regular
    //Set Hour
    sHour = ItoA(iHour mod 12);
    if (iHour = 0 || iHour = 12)
      sHour = "12";
      
    // Set AM/PM
	  if (iHour < 12)
    {
      sAMPM = "AM";
     }
    else
    {
      sAMPM = "PM";
    }	
  }
  
  //Set Minute
  sMinute = ItoLA(iMinute); 
  	      
	sTime = sHour + ":" + sMinute + " " + sAMPM;
    
  return (sTime);
}

/////////////////////////////////////////////////////////////////////
//
// Function: LocalTime()
//
// Parameters: <none>
//
// Return Value: Formatted local time
//
// Description: Returns the local time in "HH:MM AM/PM".
//
//
/////////////////////////////////////////////////////////////////////

String_Function LocalTime()
{
  integer iHour, iMinute;
  string sHour[2], sMinute[2], sTime[8];
  
  //get the time
  sHour = ItoA(gethournum());
  sMinute = ItoA(getminutesnum());
  sTime = sHour + ":" + sMinute;
  sTime = FormatTime(sTime);
     
  return (sTime);
}

String_Function Time24ToTime12(string sData)
{
	integer iPos,
					iLen,
					iHour,
					iMinute;
					
	string sTime[8],
				 sAMPM[2];
	
	if (Debug_Logic)
	{
		trace ("\n** Time24ToTime12 **\n");
		trace ("  Data:%s\n", sData);
	}
	
	iLen = len(sData);
	iPos = find(":", sData);
	
	iHour = atoi(left(sData, iPos - 1));
	iMinute = atoi(mid(sData, iPos + 1, 2));
  
	if (iHour = 0)
	{
		sTime = "12";
		sAMPM = "AM";
	}
	else if (iHour < 10)
	{
		sTime = "0" + itoa(iHour);
		sAMPM = "AM";
	}
	else if (iHour >= 10 && iHour < 12)
	{
		sTime = itoa(iHour);
		sAMPM = "AM";
	}
	else if (iHour = 12)
	{
		sTime = itoa(iHour);
		sAMPM = "PM";
	}
	else
	{
		iHour = iHour - 12;
		
		if (iHour < 10)
		{
			sTime = "0" + itoa(iHour);
		}
		else
		{
			sTime = itoa(iHour);
		}
			
		sTime = itoa(iHour);
		sAMPM = "PM";
	}
		
  sTime = sTime + ":" + itola(iMinute) + " " + sAMPM;
  
	if (Debug_Logic)
	{
		trace ("  Time:%s\n", sTime);
	}
	
	return (sTime);		
}

/////////////////////////////////////////////////////////////////////
//
// Function: DateToInteger()
//
// Parameters: Date
//
// Return Value: Integer
//
// Description: Converts date from string to a integer.
//
//
/////////////////////////////////////////////////////////////////////

Integer_Function DateToInteger(string sData)
{
	integer iValue,
					iYear,
					iMonth,
					iDay;
	
	if (Debug_Logic)
	{
		trace ("\n** DateToInteger **\n");
		trace ("    sData:%s\n", sData);
	}
	
	iValue = 0;
	
	iYear = atoi(left(sData, 4));
	iMonth = atoi(mid(sData, 6, 2)) * 100;
	iDay = atoi(right(sData, 2));
	
	iValue = iYear + iMonth + iDay;
	
	return (iValue);
}

/////////////////////////////////////////////////////////////////////
//
// Function: TimeToInteger()
//
// Parameters: Time, Format
//
// Return Value: Integer Time based on Format
//
// Description: Converts time from string to integer.
//
//
/////////////////////////////////////////////////////////////////////

Integer_Function TimeToInteger(string sData, integer iFormat)
{
	integer iTimeValue,
    			iTimeH,
    			iTimeM;
    
	// Format 1 = Time as Hours & Minutes (18:00 = 1800)
  // Format 2 = Time as Minutes (18:00 = 1080)

	if (Debug_Logic)
	{
		trace ("\n** TimeToInteger **\n");
		trace ("    sData:%s\n", sData);
		trace ("    iFormat:%u\n", iFormat);
	}
    
  iTimeValue = 0;
    
  if (iFormat = 1)
  {
  	iTimeH = atoi(left(sData, 2)) * 100;
  	iTimeM = atoi(mid(sData, 4, 2));
    iTimeValue = iTimeH + iTimeM;
  }
  else if (iFormat = 2)
  {
    iTimeH = atoi(left(sData, 2)) * 60;
    iTimeM = atoi(mid(sData, 4, 2));
    iTimeValue = iTimeH + iTimeM;    	
  }

	if (Debug_Logic)
	{
		trace ("    sData After:%s\n", sData);
		trace ("    iTimeValue:%u\n", iTimeValue);
	}
    
  return (iTimeValue);
}

String_Function ReserveNowToIntDateFormat(ReserveNowData oData, String StartEnd)
{
  string result[19];
  if (StartEnd = "Start")
  {
    result = itoa(oData.iStartYear) + "-" + IToLA(oData.iStartMonth) + "-" + IToLA(oData.iStartDay) +
		         "T" + ItoLA(oData.iStartHour) + ":" + IToLA(oData.iStartMin) + ":" + IToLA(oData.iStartSec);
  }
  else if (StartEnd = "End")
  {
    result = itoa(oData.iEndYear) + "-" + IToLA(oData.iEndMonth) + "-" + IToLA(oData.iEndDay) +
		         "T" + ItoLA(oData.iEndHour) + ":" + IToLA(oData.iEndMin) + ":" + IToLA(oData.iEndSec);
  }
  return (result);
}

/////////////////////////////////////////////////////////////////////
//
// Function: TimeDiff()
//
// Parameters: StartDate(UTC), StartTime, EndDate(UTC), EndTime
//
// Return Value: Time Difference
//
// Description: Returns the time difference (HH:MM) between two dates/times.
//
//
/////////////////////////////////////////////////////////////////////

String_Function TimeDiff(integer iFormat, string sStartDate, string sStartTime, string sEndDate, string sEndTime)
{
  integer i;
  integer iTotalMinutesUntil, iTotalMinutesFrom, iTotalDiffMinutes;
  integer iDiffDays, iDaysUntil, iDaysFrom;
  integer iStartMonth, iEndMonth;
  integer iStartDay, iEndDay;
  integer iStartYear, iEndYear;
  integer iStartHour, iEndHour;
  integer iStartTime, iEndTime;
  integer iStartMin, iEndMin;
  integer iStartTimeMin, iEndTimeMin;
  integer iDiffHours, iDiffMins;
  integer iDiffTotalMin;
  string sTimeDiff[5];
  
  if (Debug_Logic)
  {
    trace ("\n** TimeDiff **\n");
    trace ("    Format:%u\n", iFormat);
    trace ("    StartDate:%s\n", sStartDate);
    trace ("    StartTime:%s\n", sStartTime);
    trace ("    EndDate:%s\n", sEndDate);
    trace ("    EndTime:%s\n", sEndTime);
  }
  
  //reset vars
  sTimeDiff = "";
  
  iStartTime = TimeToInteger(sStartTime, TIME_FORMAT_HHMM);
  iStartHour = iStartTime / 100;
  iStartMin = iStartTime MOD 100;
  iStartTimeMin = (iStartHour * 60) + iStartMin;
  	
  iEndTime = TimeToInteger(sEndTime, TIME_FORMAT_HHMM);
  iEndHour = iEndTime / 100;
  iEndMin = iEndTime MOD 100;
  iEndTimeMin = (iEndHour * 60) + iEndMin;
  	   	
  //dates equal?
  if (sStartDate = sEndDate)
  {
  	//start date = end date, so just calc hours between time
  	
  	if (Debug_Logic)
  	 trace ("    Start Date = End Date\n");
  	
  	iDiffTotalMin = iEndTimeMin - iStartTimeMin;
  	iDiffHours = iDiffTotalMin / 60;
  	iDiffMins = iDiffTotalMin MOD 60;  	
  }
  else
  {
  	//start date <> end date, so get hours between dates
  	
  	iStartMonth = atoi(mid(sStartDate, 6, 2));
  	iStartDay = atoi(right(sStartDate, 2));
  	iStartYear = atoi(left(sStartDate, 4));
  	
  	iEndMonth = atoi(mid(sEndDate, 6, 2));
  	iEndDay = atoi(right(sEndDate, 2));
  	iEndYear = atoi(left(sEndDate, 4));
  	
  	if (Debug_Logic)
  	{
    	trace ("    iStartMonth:%u\n", iStartMonth);
    	trace ("    iStartDay:%u\n", iStartDay);
    	trace ("    iStartYear:%u\n", iStartYear);    
    	
    	trace ("    iEndMonth:%u\n", iEndMonth);
    	trace ("    iEndDay:%u\n", iEndDay);
    	trace ("    iEndYear:%u\n", iEndYear);
  	}

  	if (iStartYear <> iEndYear)
  	{
    	if (Debug_Logic)
     	 trace ("    Years Not Equal\n");
    
    	//days until end of the year
    
    	// get days until end of month
    	iDaysUntil = DaysInMonth(iStartMonth, iStartYear) - iStartDay;
    
    	if (Debug_Logic)
     	 trace ("    Days Until End of Current Month:%u\n", iDaysUntil);
    
    	// if month <> 12, then get the rest of the days based on the months
    	if (iStartMonth <> 12)
    	{
      	if (Debug_Logic)
       	 trace ("    Current Month <> 12. Add up all days based on month.\n");
      
      	for (i = iStartMonth + 1 to 12)
      	{
        	iDaysUntil = iDaysUntil + DaysInMonth(i, iStartYear);
      	} 
    	}    
      
    	if (Debug_Logic)
     	 trace ("    Total Days to the End of the Year:%u\n", iDaysUntil);
           
    	//months from beginning of year
    
    	// get the days from the beginning of the month
    	iDaysFrom = DaysInMonth(iEndMonth, iEndYear);
    
    	//if month <> 1, then get the rest of the days based on the months
    	if (iEndMonth <> 1)
    	{
      	if (Debug_Logic)
       	 trace ("    End Month <> 1\n");
      
      	for (i = 1 to iEndMonth - 1)
      	{
        	iDaysFrom = iDaysFrom + DaysInMonth(i, iEndYear);
      	}
    	}
    
    	if (Debug_Logic)
     	 trace ("    Total Days from the Beginning of the Year:%u\n", iDaysFrom);
    
    	iDiffDays = iDaysUntil + iDaysFrom;
  	}
  	else if (iStartMonth <> iEndMonth)
  	{
    	if (Debug_Logic)
     	 trace ("    Months Not Equal\n");

    	//get days until end of month
    	iDiffDays = DaysInMonth(iStartMonth, iStartYear) - iStartDay;    
    
    	//get the days from the beginning of the month
    	iDiffDays = iDiffDays + DaysInMonth(iEndMonth, iEndYear);
    
    	//if months apart > 1, get the rest of the days based on the months
    	if (iEndMonth - iStartMonth > 1)
    	{
      	if (Debug_Logic)
       	 trace ("    Month Difference > 1\n");
      
      	for (i = iStartMonth + 1 to iEndMonth - 1)
      	{
        	iDiffDays = iDiffDays + DaysInMonth(i, iEndYear);
      	}
    	}    
  	}
  	else if (iStartDay <> iEndDay)
  	{
    	if (Debug_Logic)
     	 trace ("    Days Not Equal\n");
    
    	iDiffDays = iEndDay - iStartDay;
  	}
  
  	if (Debug_Logic)
   	 trace ("    Total Day Diff:%u\n", iDiffDays);
       
  	// *** calculate hours ***
    
    // minutes until next day
    iTotalMinutesUntil = 1440 - ((iStartHour * 60) + iStartMin);

  	if (Debug_Logic)
   	 trace ("    Total Minutes Until Midnight:%u\n", iTotalMinutesUntil);
   	
   	// minutes from next day
   	iTotalMinutesFrom = (iEndHour * 60) + iEndMin;

  	if (debug_Logic)
   	 trace ("    Total Minutes From Midnight:%u\n", iTotalMinutesFrom);
   	 
   	
   	iTotalDiffMinutes = iTotalMinutesUntil + iTotalMinutesFrom;

  	if (debug_Logic)
   	 trace ("    Total Diff Minutes:%u\n", iTotalDiffMinutes);
   	    	
    iDiffDays = iDiffDays - 1;
    
    iDiffHours = (iTotalDiffMinutes / 60) + (iDiffDays * 24);
    
    iDiffMins = iTotalDiffMinutes mod 60;
    
  	if (debug_Logic)
  	{
   		trace ("    Diff Hours:%u\n", iDiffHours);
   		trace ("    Diff Minutes:%u\n", iDiffMins);    
    }
  }  
  
  // ** build output string **
  
  // Which format?
  
  if (iFormat = TIME_FORMAT_DD_HH_MM)
  {
  	// Hours > 23?
  	if (iDiffHours > 23)
  	{
  		// Yes, hours > 23.
  		
  		iDiffDays = iDiffHours / 24;
  		
  		iDiffHours = iDiffHours - (iDiffDays * 24);  		
  	}
  	else
  	{
  		iDiffDays = 0;
  	}

  	// Need to pad the hours?
  	if (iDiffDays < 10)
  	{
  		sTimeDiff = "0" + itoa(iDiffDays);
  	}
  	else
  	{
  		sTimeDiff = itoa(iDiffDays);
  	} 


  	// Need to pad the hours?
  	if (iDiffHours < 10)
  	{
  		sTimeDiff = sTimeDiff + ":0" + itoa(iDiffHours);
  	}
  	else
  	{
  		sTimeDiff = sTimeDiff + ":" + itoa(iDiffHours);
  	}  
  }
  else if (iFormat = TIME_FORMAT_HH_MM)
  {
  	// Need to pad the hours?
  	if (iDiffHours < 10)
  	{
  		sTimeDiff = "0" + itoa(iDiffHours);
  	}
  	else
  	{
  		sTimeDiff = itoa(iDiffHours);
  	}  	
  }
   	
  //need to pad the minutes?
  if (iDiffMins < 10)
  {
  	sTimeDiff = sTimeDiff + ":0" + itoa(iDiffMins);
  }
  else
  {
  	sTimeDiff = sTimeDiff + ":" + itoa(iDiffMins);
  }

  if (Debug_Logic)
   trace ("    TimeDiff:%s\n", sTimeDiff);
  
  
  return (sTimeDiff);  
}

String_Function FormatTimeDiff(string sData)
{
	string sFormattedData[25];
	
	integer i,
					iDataLen,
					iColonCount;
					
	integer iDay,
					iHour,
					iMin;
	
	if (Debug_Logic)
	{
		trace ("\n** FormatTimeDiff **\n");
	  trace ("  Data:%s\n", sData);
	}
	
	sFormattedData = "";
	
	// Determine the data format
	iDataLen = len(sData);
	iColonCount = 0;
	
	for (i = 1 to iDataLen)
	{
		if (mid(sData, i, 1) = ":")
		{
			iColonCount = iColonCount + 1;
		}
	}
	
	if (iColonCount = 1)
	{
		// Format is HH:MM
		
		iHour = atoi(left(sData, 2));
		iMin = atoi(right(sData, 2));
		
		if (iHour > 0)
		{
			sFormattedData = itoa(iHour) + " Hr " + itoa(iMin) + " Min";
		}
		else
		{
			sFormattedData = itoa(iMin) + " Min";		
		}
	}
	else if (iColonCount = 2)
	{
		// Format is DD:HH:MM
		
		iDay = atoi(left(sData, 2));
		iHour = atoi(mid(sData, 4, 2));
		iMin = atoi(right(sData, 2));		
		
		if (iDay > 0)
		{
			sFormattedData = itoa(iDay) + " Day " + itoa(iHour) + " Hr " + itoa(iMin) + " Min";
		}
		else
		{
			if (iHour > 0)
			{
				sFormattedData = itoa(iHour) + " Hr " + itoa(iMin) + " Min";
			}
			else
			{
				sFormattedData = itoa(iMin) + " Min";
			}		
		}
	}
	
	if (Debug_Logic)
	{
		trace ("  FormattedData:%s\n", sFormattedData);
	}
	
	return (sFormattedData);
}

/////////////////////////////////////////////////////////////////////
//
// Function: TimeRemaining()
//
// Parameters: EventNum
//
// Return Value: Time Remaining
//
// Description: Returns the time remaining for a given Event Number.
//
//
/////////////////////////////////////////////////////////////////////

String_Function TimeRemaining(integer iType)
{
  integer i, iEventIndex;
  integer iCurrentHour, iCurrentMin;
  integer iEndHour, iEndMin;
  integer iHoursRemaining, iMinutesRemaining;
  string sTimeRemaining[5];
  
  if (Debug_Logic)
   trace ("\n** TimeRemaining **\n");
  
  //reset vars
  sTimeRemaining = "";
  
  // If iType = 1, use current meeting.
  // If iType = 2, use started meeting.
  
  //set the event index
  if (iType = 1)
   iEventIndex = g_iCurrentEventNum;
  else if (iType = 2)
   iEventIndex = g_iStartedEventNum;
    
  //get the current hour and minute
  iCurrentHour = g_iCurrentTime / 100;
  iCurrentMin = g_iCurrentTime MOD 100;
    
  //check end date
  if (g_sDateToday = MeetingEvent[iEventIndex].EndDate)
  {
    //event ends today
    
    if (Debug_Logic)
     trace ("    Event Ends Today\n");
    
    //calculate the end hour/min
    iEndHour = TimeToInteger(MeetingEvent[iEventIndex].EndTime, TIME_FORMAT_HHMM) / 100;
    iEndMin = TimeToInteger(MeetingEvent[iEventIndex].EndTime, TIME_FORMAT_HHMM) MOD 100;
    
    //calculate the hours remaining
    iHoursRemaining = iEndHour - iCurrentHour;
    
  	//calculate minutes remaining  
  	if (iCurrentMin < iEndMin)
   	 iMinutesRemaining = iEndMin - iCurrentMin;
  	else
  	{
    	if (iHoursRemaining > 0)
     	 iHoursRemaining = iHoursRemaining - 1;
      
    	iMinutesRemaining = (60 - iCurrentMin) + iEndMin;
    	
		}
		
		//format the data string
		if (iHoursRemaining > 0 || iMinutesRemaining > 0)
		{	  
			if (Debug_Logic)
			 trace ("    There is Time Remaining\n");
	  
	  	if (iHoursRemaining < 10)
	   	 sTimeRemaining = "0" + itoa(iHoursRemaining);
	  	else
	   	 sTimeRemaining = itoa(iHoursRemaining);
	    
	  	if (iMinutesRemaining < 10)
	   	 sTimeRemaining = sTimeRemaining + ":0" + itoa(iMinutesRemaining);
	  	else
	   	 sTimeRemaining = sTimeRemaining + ":" + itoa(iMinutesRemaining);
		}
		else
		{
			if (Debug_Logic)
		 	 trace ("    No Time Remaining\n");
		
			sTimeRemaining = "";
		}
  }
  else
  {
    //event does not end today
    
    if (Debug_Logic)
     trace ("    Event Does Not End Today\n");
    
    // Use TimeDiff function
    sTimeRemaining = TimeDiff(TIME_FORMAT_HH_MM, g_sDateToday, g_sCurrentTime,
     MeetingEvent[iEventIndex].EndDate, MeetingEvent[iEventIndex].EndTime);
  }
  
  if (Debug_Logic)
   trace ("    TimeRemaining:%s\n", sTimeRemaining);
  
	return (sTimeRemaining);
}

/////////////////////////////////////////////////////////////////////
//
// Function: ElapsedTimeMin()
//
// Parameters: <none>
//
// Return Value: Elapsed Time in Minutes
//
// Description: Returns the total elapsed minutes of the active meeting.
//
//
/////////////////////////////////////////////////////////////////////

Integer_Function ElapsedTimeMin()
{
	integer iEventIndex, iStartTime;
	string sElapsedTime[5], sTimeDiff[5];
	integer iCurrentHour, iCurrentMin, iCurrentTimeMin;
	integer iStartHour, iStartMin;
	integer iElapsedHours, iElapsedMinutes, iElapsedTimeMin;
	
	if (Debug_Logic)
	{
		trace ("\n** ElapsedTime **\n");
	}
	
	//reset vars
	iElapsedTimeMin = 0;
	
	//set the event index
	iEventIndex = g_iCurrentEventNum;
	
	//Did event start prior to actual start time?
	if (g_iStartedEventTime > 0)
	{
		//Yes, meeting started prior.
		
		if (Debug_Logic)
		 trace ("    Meeting Started Prior to Actual Start Time\n");
		
		iStartTime = g_iStartedEventTime;		
	}
	else
	{
		//No, meeting did not start prior.
		
		if (Debug_Logic)
		 trace ("    Meeting did not start prior to Start Time\n");
		
		iStartTime = TimeToInteger(MeetingEvent[iEventIndex].StartTime, TIME_FORMAT_HHMM);	
	}
	
  //get the current hour and minute
  iCurrentHour = g_iCurrentTime / 100;
  iCurrentMin = g_iCurrentTime MOD 100;
  iCurrentTimeMin = (iCurrentHour * 60) + iCurrentMin;
  
  //event starts today
  if (g_sDateToday = MeetingEvent[iEventIndex].StartDate)
  {
    if (Debug_Logic)
     trace ("    Event Starts Today\n");
    	 
    iStartHour = iStartTime / 100;
    iStartMin = iStartTime MOD 100;
    
    //make sure current hour >= start hour
    if (iCurrentHour < iStartHour)
    {
    	//something wrong
    	
    	if (Debug_Logic)
    	 trace ("    Current Hour < Start Hour. Error!\n");
    	
    	iElapsedTimeMin = 0;
    }
    else
    {
    	iElapsedTimeMin = iCurrentTimeMin - ((iStartHour * 60) + iStartMin);    	    	
    }
    
  }
  //event started prior to today
  else if (DateToInteger(g_sDateToday) > DateToInteger(MeetingEvent[iEventIndex].StartDate))
  {
    if (Debug_Logic)
     trace ("    Event Started Prior to Today\n");
    
    
    //use TimeDiff function
    sTimeDiff = TimeDiff(TIME_FORMAT_HH_MM, MeetingEvent[iEventIndex].StartDate, MeetingEvent[iEventIndex].StartTime,
     g_sDateToday, g_sCurrentTime);
     
    //calculate the elapsed hours
    iElapsedHours = atoi(left(sTimeDiff, 2));
    
  	//calculate the elapsed minutes
   	iElapsedMinutes = atoi(right(sTimeDiff, 2));
  	
  	//calculate total elapsed minutes
  	iElapsedTimeMin = (iElapsedHours * 60) + iElapsedMinutes;    
    
  }
  
  if (Debug_Logic)
   trace ("    ElapsedTimeMin:%u\n", iElapsedTimeMin);
  
  return (iElapsedTimeMin);	
}

/////////////////////////////////////////////////////////////////////
//
// Function: DurationMin()
//
// Parameters: <none>
//
// Return Value: Duration in Minutes
//
// Description: Returns the total meeting duration (minutes)
//              of the active meeting.
//
/////////////////////////////////////////////////////////////////////

Integer_Function DurationMin()
{
	integer iEventIndex, iStartTime, iEndTime;
	integer iEventDurationMin, iHourMin, iStartTimeMin, iEndTimeMin;
	integer iDurationHours, iDurationMinutes;
	string sStartTime[5], sEndTime[5];
	integer iHour, iMin;
	string sTimeDiff[5];
	
	if (Debug_Logic)
	{
		trace ("\n** DurationMin **\n");
	}
	
	//Reset VARS
	sTimeDiff = "";
	
	//Set the event index
	iEventIndex = g_iCurrentEventNum;
	
	//Did event start prior to actual start time?
	if (g_iStartedEventTime > 0)
	{
		//Yes, meeting started prior.
		
		if (Debug_Logic)
		 trace ("    Meeting Started Prior to Actual Start Time\n");
		
		iStartTime = g_iStartedEventTime;
		
		iHour = iStartTime / 100;
		
		if (iHour < 10)
		{
			sStartTime = "0" + itoa(iHour);
		}
		else
		{
			sStartTime = itoa(iHour);
		}
		
		iMin = iStartTime MOD 100;
		
		if (iMin < 10)
		{
			sStartTime = sStartTime + ":0" + itoa(iMin);
		}
		else
		{
			sStartTime = sStartTime + itoa(iMin);
		}		
	}
	else
	{
		//No, meeting did not start prior.
		
		if (Debug_Logic)
		 trace ("    Meeting did not start prior to Start Time\n");
		
		sStartTime = MeetingEvent[iEventIndex].StartTime;
		iStartTime = TimeToInteger(sStartTime, TIME_FORMAT_HHMM);	
	}
	
	//Set the end time
	sEndTime = MeetingEvent[iEventIndex].EndTime;
	iEndTime = TimeToInteger(sEndTime, TIME_FORMAT_HHMM);
	
  //Does the event start & end today?
  if (g_sDateToday = MeetingEvent[iEventIndex].StartDate &&
   g_sDateToday = MeetingEvent[iEventIndex].EndDate)
  {
    //Yes, event starts & ends today.
    
    if (Debug_Logic)
     trace ("    Event Starts & Ends Today\n");
    
    //Calculate the start time minutes.
    iHourMin = (iStartTime / 100) * 60;
    iStartTimeMin = iHourMin + (iStartTime MOD 100);
    
    //Calculate the end time minutes.
    iHourMin = (iEndTime / 100) * 60;
    iEndTimeMin = iHourMin + (iEndTime MOD 100);
    
    //Calculate the minute diff.
    iEventDurationMin = iEndTimeMin - iStartTimeMin;
  }
  else
  {
  	//Event does not start or end today.
  	
  	if (Debug_Logic)
  	 trace ("    Event did not Start or End Today\n");
  	
    //use TimeDiff function
    sTimeDiff = TimeDiff(TIME_FORMAT_HH_MM, MeetingEvent[iEventIndex].StartDate, sStartTime,
     MeetingEvent[iEventIndex].EndDate, sEndTime);
     
    //calculate the duration hours
    iDurationHours = atoi(left(sTimeDiff, 2));
    
  	//calculate the elapsed minutes
   	iDurationMinutes = atoi(right(sTimeDiff, 2));
  	
  	//calculate total elapsed minutes
  	iEventDurationMin = (iDurationHours * 60) + iDurationMinutes;
  	
  }
  
  if (Debug_Logic)
   trace ("    EventDurationMin:%u\n", iEventDurationMin);
  
  return (iEventDurationMin);	
}


Function SendFreeBusyAttributeData(string sDate, string sTime)
{
	string sOccupied[1],
				 sEnReserveNow[1],
				 sPrivacyLevel[1],
				 sMeetingActive[1];
	
	string sNewTime[8];
	
	// Old Data format is "<Occupied Status>||<En Reserve Now>||<Privacy Level>||<Next Reservation Date/Time in UTC>"
	// New Data format is <Free Until Date/Time in UTC>
	
	if (Debug_Logic)
	{
		trace ("\n** SendFreeBusyAttributeData **\n");
		trace ("  Date:%s\n", sDate);
		trace ("  Time:%s\n", sTime);
	}
  
  if (len(sTime) < 8)
  {
  	// Need seconds tagged to end.
  	sNewTime = sTime + ":00";
  }
  else
  {
  	// Should never get here ...
  	sNewTime = sTime;
  }
  
  if (!EWS_Subscription_Offline_FB)
  {
  	if (En_FreeBusy_AttributeData)
	 	 To_RV_FreeBusy_AttributeData$ = sDate + "T" + sNewTime;
		else
	 	 To_RV_FreeBusy_AttributeData$ = "-";		
	}
}

Function SetCurrentTimeBargraphValue()
{
	integer iStartBlock,
					iEndBlock,
					iMinutesPerPage,
					iOffsetMinutes;
	
	string sTime[8];
	
	if (Debug_Logic)
	{
		trace ("\n** SetCurrentTimeBargraphValue **\n");
	}
	
	iMinutesPerPage = Field_Qty * 30;
	iOffsetMinutes = (Current_Page * iMinutesPerPage) - iMinutesPerPage;
			
	// Calculate value.
	Current_Time_Bargraph_Value = 65535 - ((65535 / iMinutesPerPage) * (g_iCurrentTimeMin - iOffsetMinutes));
}

Function SendRemoteSystemData(integer iType, string sData)
{
	integer i,
					iEventNum;
	
	if (Debug_Logic)
  {
  	trace ("\n** SendRemoteSystemData **\n");
  	trace ("    iType:%u\n", iType);
  	trace ("    sData:%s\n", sData);
  }
  
  iEventNum = 0;
  
	To_Remote_Sys_Mod_DataIn$ = 
		"<RemoteSystemData>";
				  
  cswitch (iType)
  {
  	case (REM_SYS_DATA_WORKDAY):
  	{
			To_Remote_Sys_Mod_DataIn$ = 
				"<WorkdaySchedule>";
			
			if (g_iStoredEventCount > 0)
			{
				
				for (i = 1 to g_iStoredEventCount)
				{
					To_Remote_Sys_Mod_DataIn$ =
						"<Event>" +
							"<MeetingID>" + MeetingEvent[i].MeetingID + "</MeetingID>";
					
					To_Remote_Sys_Mod_DataIn$ =
							"<RVMeetingID>" + MeetingEvent[i].RVMeetingID + "</RVMeetingID>";
							
					To_Remote_Sys_Mod_DataIn$ =		
							"<StartDate>" + MeetingEvent[i].StartDate + "</StartDate>" +
							"<StartTime>" + MeetingEvent[i].StartTime + "</StartTime>" +
							"<StartBlock>" + itoa(MeetingEvent[i].StartBlock) + "</StartBlock>";
					
					To_Remote_Sys_Mod_DataIn$ =
							"<EndDate>" + MeetingEvent[i].EndDate + "</EndDate>" +
							"<EndTime>" + MeetingEvent[i].EndTime + "</EndTime>" +
							"<EndBlock>" + itoa(MeetingEvent[i].EndBlock) + "</EndBlock>";
					
					To_Remote_Sys_Mod_DataIn$ =
							"<Organizer>" + MeetingEvent[i].Organizer + "</Organizer>";
					
					To_Remote_Sys_Mod_DataIn$ =
							"<Subject>" + MeetingEvent[i].Subject + "</Subject>" +
							"<IsPrivate>" + itoa(MeetingEvent[i].IsPrivate) + "</IsPrivate>" +
							"<IsExchangePrivate>" + itoa(MeetingEvent[i].IsExchangePrivate) + "</IsExchangePrivate>" +
						"</Event>";			
				}
			}

			To_Remote_Sys_Mod_DataIn$ =
				"</WorkdaySchedule>";
				  		
  		break;
  	}
  	
  	case (REM_SYS_DATA_CURR_MEETING):
  	{
			To_Remote_Sys_Mod_DataIn$ =
				"<CurrentMeetingInfo>";
		  
		  // What to send?
		  
		  if (g_iStartedEventNum > 0)
		   iEventNum = g_iStartedEventNum;
		  else if (g_iCurrentEventNum > 0)
		   iEventNum = g_iCurrentEventNum;
		  
		  if (iEventNum > 0)
		  {
		  	
        To_Remote_Sys_Mod_DataIn$ =
        	"<StartDate>" + MeetingEvent[iEventNum].StartDate + "</StartDate>" +
        	"<StartTime>" + MeetingEvent[iEventNum].StartTime + "</StartTime>" +
        	"<EndDate>" + MeetingEvent[iEventNum].EndDate + "</EndDate>" +
        	"<EndTime>" + MeetingEvent[iEventNum].EndTime + "</EndTime>";
        
		  	To_Remote_Sys_Mod_DataIn$ =
		  		"<Organizer>" + MeetingEvent[iEventNum].Organizer + "</Organizer>";
		  		
		  	To_Remote_Sys_Mod_DataIn$ =
		  		"<Subject>" + MeetingEvent[iEventNum].Subject + "</Subject>";
		  	    
		  	To_Remote_Sys_Mod_DataIn$ =
		  		"<WelcomeMsg>" + g_sCurrentWelcomeMsg + "</WelcomeMsg>";
		  }
		  
		  To_Remote_Sys_Mod_DataIn$ =
		  	"</CurrentMeetingInfo>";
				  		
  		break;
  	}
  	
  	case (REM_SYS_DATA_NEXT_RESERV):
  	{
			To_Remote_Sys_Mod_DataIn$ =
				"<NextReservation>";

  		// Have event?
  		if (len(NextEvent.MeetingID) > 0)
  		{
  			// Yes, have next event.
			
				To_Remote_Sys_Mod_DataIn$ =
					"<StartDate>" + NextEvent.StartDate + "</StartDate>" +
					"<StartTime>" + NextEvent.StartTime + "</StartTime>" +
					"<EndDate>" + NextEvent.EndDate + "</EndDate>" +
					"<EndTime>" + NextEvent.EndTime + "</EndTime>";

				To_Remote_Sys_Mod_DataIn$ =
					"<Organizer>" + NextEvent.Organizer + "</Organizer>";
					
				To_Remote_Sys_Mod_DataIn$ =
					"<Subject>" + NextEvent.Subject + "</Subject>";					
			
			}
			
			To_Remote_Sys_Mod_DataIn$ =
				"</NextReservation>";
  		
  		break;
  	}
  	
  	case (REM_SYS_DATA_END_MEETING_WARN):
  	{
			To_Remote_Sys_Mod_DataIn$ = "<Set ID=\x22EndMeetingWarn\x22 Value=\x22" + sData + "\x22 />";  		
  		
			break; 		
  	}
  	
  	case (REM_SYS_DATA_DATE_TIME):
  	{
			To_Remote_Sys_Mod_DataIn$ =
				"<DateTime>";
			
			To_Remote_Sys_Mod_DataIn$ =
				"<Set ID=\x22DateTime\x22 Value=\x22" + g_sDateToday + "T" + g_sCurrentTime + ":00" + "\x22 />";
				  		
			To_Remote_Sys_Mod_DataIn$ =
				"</DateTime>";  		
			break; 		
  	}
  }
  
  To_Remote_Sys_Mod_DataIn$ = 
		"</RemoteSystemData>";
}

Function SetReserveNow()
{
  integer i,
  				iEventStartBlock,
  				iEventEndBlock,
  				bCurrentTimeBlockActive;
  
  if (Debug_Logic)
  {
  	trace ("\n** SetReserveNow **\n");
  }
  
  iEventStartBlock = 0;
  iEventEndBlock = 0;
  bCurrentTimeBlockActive = FALSE;
  
  if (Reserve_Now_Request_Mode != REQUEST_MODE_IDLE ||
  	Workday_Sched_Request_Mode = REQUEST_MODE_PROCESSING ||
  	g_bReserveNowSuccessNeedSched ||
  	EWS_Subscription_Offline_FB ||
  	RoomService_Backlog_Active_FB)
  {
    if (Debug_Logic)
    {
    	trace ("    Disable Book Now\n");
    	trace ("     Reasons:\n");
    	trace ("      ReserveNowRequestMode:%u\n", Reserve_Now_Request_Mode);
    	trace ("      WorkdaySchedRequestMode:%u\n", Workday_Sched_Request_Mode);
    	trace ("      ReserveNowSuccessNeedSched:%u\n", g_bReserveNowSuccessNeedSched);
    	trace ("      EWSSubscriptionOffline:%u\n", EWS_Subscription_Offline_FB);
    	trace ("      BacklogActive:%u\n", RoomService_Backlog_Active_FB);
    }
    
    Enable_Reserve_Now = FALSE;
  }
  else
  {
  	// No current event?
    if (g_iCurrentEventNum = 0)
    {
      // No current event. Enable Reserve Now.
      
      if (Debug_Logic)
       trace ("  No current event. Enable reserve now.\n");
      
      Enable_Reserve_Now = TRUE;
    }
    else
    {
      // Have a current event. Disable Reserve Now.
      
      if (Debug_Logic)
       trace ("  Have current event. Disable reserve now.\n");
      
      Enable_Reserve_Now = FALSE;
    } 
  }
}

/////////////////////////////////////////////////////////////////////
//
// Function: SetStartMeetingBtn()
//
// Parameters: <none>
//
// Return Value: <none>
//
// Description: xxxx.
//
//
/////////////////////////////////////////////////////////////////////

Function SetStartMeetingBtn()
{
 if (Debug_Logic)
 {
   trace("\r** Start Meeting Btn**\r");
   trace("Config_En_Decline_For_NoShow: %d\r", Config_En_Decline_For_NoShow);
   trace("Config_En_StartMeeting: %d\r", Config_En_StartMeeting);
   trace("Meeting_Active: %d\r", Meeting_Active);
   trace("End_Meeting_Btn_Sub: %d\r", End_Meeting_Btn_Sub);
   trace("Current_Meeting_Elapsed_Time < Decline_Meeting_Min: %d < %d ?\r", Current_Meeting_Elapsed_Time, Decline_Meeting_Min);
 }

  if (Config_En_Decline_For_NoShow)
  {
    if (Config_En_StartMeeting)
    {
      if (Meeting_Active)
      {
	      if (End_Meeting_Btn_Sub = FALSE)
	      {
	        if (Current_Meeting_Elapsed_Time < Decline_Meeting_Min)
	        {
            if (!g_bStartMeetingConfirmed)
            {
	            Start_Meeting_Btn_SUB = TRUE;
	            return;
            }
	        }
	      }
      }
    }
  }  
  //Otherwise
  Start_Meeting_Btn_SUB = FALSE;
  Start_Meeting_Btn_FB = FALSE;
  Start_Meeting_Confirm_Sub = FALSE;
}

/////////////////////////////////////////////////////////////////////
//
// Function: SetEndMeetingBtn()
//
// Parameters: <none>
//
// Return Value: <none>
//
// Description: xxxx.
//
//
/////////////////////////////////////////////////////////////////////

Function SetEndMeetingBtn()
{
  if (Config_En_FreeUpRoom)
  {
    if (Meeting_Active)
    {
      if (Current_Meeting_Elapsed_Time >= Decline_Meeting_Min)
      {
         End_Meeting_Btn_SUB = TRUE;
         return;
      }
    }
  }
  
  //else
  End_Meeting_Btn_SUB = FALSE;
  End_Meeting_Confirm_Sub = FALSE;
}

/////////////////////////////////////////////////////////////////////
//
// Function: SetEndNextMeetingWarn()
//
// Parameters: <none>
//
// Return Value: <none>
//
// Description: xxxx.
//
//
/////////////////////////////////////////////////////////////////////

Function SetEndNextMeetingWarn()
{
  integer i;
  integer bNextEvent;
  integer iCurrentEvent,
  				iNextEvent,
  				iEventEndTime,
  				iEventEndTimeMin; 
  
  bNextEvent = FALSE;
  iNextEvent = 0;
  
  if (Debug_Logic)
  {
    trace ("\n** SetEndNextMeetingWarn **\n");
  }
  
  iNextEvent = 0;
    
  // Current event, warning based on N minutes left in meeting
  if (g_iCurrentEventNum > 0)
  {     
    if (debug_Logic)
     trace ("    Current Event\n");
      
    iCurrentEvent = g_iCurrentEventNum;
    
    //if event ends today, see if we are N min until it ends
    if (MeetingEvent[iCurrentEvent].EndDate = g_sDateToday)
    {
      if (Debug_Logic)
       trace ("    Meeting Ends Today. Check Time Remaining\n");
      
      iEventEndTime = TimeToInteger(MeetingEvent[iCurrentEvent].EndTime, TIME_FORMAT_HHMM);
      
      iEventEndTimeMin = (iEventEndTime / 100) * 60 +
       iEventEndTime MOD 100;
       
      if (iEventEndTimeMin - g_iCurrentTimeMin <= End_Next_Meeting_Warn_Time)
      {
        if (Debug_Logic)
         trace ("    Time Remaining = Warn Value of :%u\n", End_Next_Meeting_Warn_Time);
        
        // If time = End_Meeting_Warn_Time, set seed.
        if (iEventEndTimeMin - g_iCurrentTimeMin = End_Next_Meeting_Warn_Time)
         End_Meeting_Warn_Countdown_Seed = End_Next_Meeting_Warn_Time * 60;
        else
        {
        	// Check the value of End_Meeting_Warn_Countdown_Seed.
        	// If it has not been set, either meeting came down
        	// just before it was scheduled to end OR the program
        	// has reset.
        	
        	if (End_Meeting_Warn_Countdown_Seed = 0)
        	{
        		End_Meeting_Warn_Countdown_Seed = (iEventEndTimeMin - g_iCurrentTimeMin) * 60;
        	}
        }
        
       	End_Meeting_Warn_FB = TRUE;
       	  
        if (g_bHaveMeetingPresetModule)
        {
        	To_MeetingPreset_Mod_DataIn$ =
         	 	"<ScheduleInterfaceData>" +
         			"<EndMeetingWarn>" + itoa(iCurrentEvent) + "</EndMeetingWarn>" +	
         		"</ScheduleInterfaceData>";
        }
        
        if (g_bHaveRemoteSysModule)
         call SendRemoteSystemData(REM_SYS_DATA_END_MEETING_WARN, "1");
      }
      else
      {
        if (Debug_Logic)
         trace ("    Time Remaining > Warn Value\n");
         
        End_Meeting_Warn_FB = FALSE;

        if (g_bHaveMeetingPresetModule)
        {          
        	To_MeetingPreset_Mod_DataIn$ =
         		"<ScheduleInterfaceData>" +
         			"<EndMeetingWarn>0</EndMeetingWarn>" +	
         		"</ScheduleInterfaceData>";
      	}
      	
      	if (g_bHaveRemoteSysModule)
         call SendRemoteSystemData(REM_SYS_DATA_END_MEETING_WARN, "0");
      }   
    }
    else
    {
      if (Debug_Logic)
       trace ("    Meeting Does Not End Today\n");
      
      End_Meeting_Warn_FB = FALSE;
      
      if (g_bHaveMeetingPresetModule)
      {          
      	To_MeetingPreset_Mod_DataIn$ =
        	"<ScheduleInterfaceData>" +
         		"<EndMeetingWarn>0</EndMeetingWarn>" +	
         	"</ScheduleInterfaceData>";
      }
      
      if (g_bHaveRemoteSysModule)
       call SendRemoteSystemData(REM_SYS_DATA_END_MEETING_WARN, "0");
    }
  }
  //no active event, so see if we are 2 min within the start of a meeting
  else
  {
  	End_Meeting_Warn_FB = FALSE;
  } 
}

/////////////////////////////////////////////////////////////////////
//
// Function: NextTimeMin()
//
// Parameters: <none>
//
// Return Value: <none>
//
// Description: xxxx.
//
//
/////////////////////////////////////////////////////////////////////
String_Function NextTimeMin(string sStartTime)
{
	integer iStartHour,
					iStartMin;
					
	integer iNextHour,
					iNextMin;
	
	integer bNeedNextDay;
	
	string sNextTimeMin[8];
	
	if (Debug_Logic)
	{
		trace ("\n** NextTimeMin **\n");
		trace ("  StartTime:%s\n", sStartTime);
	}
	
	bNeedNextDay = FALSE;
	
	// Convert starting time items to integers.
	iStartHour = atoi(left(sStartTime, 2));
	iStartMin = atoi(mid(sStartTime, 4, 2));
	
	// Goto next minute.
	
	// Minutes left in hour?
	if (iStartMin < 59)
	{
		// Yes, minutes left. Goto next minute.
		
		iNextHour = iStartHour;
		iNextMin = iStartMin + 1;	
	}
	else
	{
		// No minutes left. Goto next hour.
		
		// Hours left?
		if (iStartHour < 23)
		{
			// Yes, hours left. Goto next hour.
			
			iNextHour = iStartHour + 1;
			iNextMin = 0;
		}
		else
		{
			// No hours left. Need to goto next day.
			bNeedNextDay = TRUE;
		}		
	}
	
	// Need next day?
	if (bNeedNextDay)
	{
		// Need next day. Return special text.
		
		sNextTimeMin = "NextDay";		
	}
	else
	{
		// Do not need next day. Return next minute.
		
		// Leading zero for hour?
		if (iNextHour < 10)
		{
			sNextTimeMin = "0" + itoa(iNextHour);
		}
		else
		{
			sNextTimeMin = itoa(iNextHour);
		}
		
		// Leading zero for min?
		if (iNextMin < 10)
		{
			sNextTimeMin = sNextTimeMin + ":" + "0" + itoa(iNextMin);
		}
		else
		{
			sNextTimeMin = sNextTimeMin + ":" + itoa(iNextMin);
		}
		
		// Add seconds
		sNextTimeMin = sNextTimeMin + ":00";
	}
	
	if (Debug_Logic)
	{
		trace ("  NextTimeMin:%s\n", sNextTimeMin);
	}
	
	return (sNextTimeMin);
}

/////////////////////////////////////////////////////////////////////
//
// Function: NextDayDate()
//
// Parameters: <none>
//
// Return Value: <none>
//
// Description: xxxx.
//
//
/////////////////////////////////////////////////////////////////////
String_Function NextDayDate(string sStartDate, string sDays)
{
	integer iStartMonth,
					iStartDay,
					iStartYear;
					
	integer iNextMonth,
					iNextDay,
					iNextYear;
	
	integer iDaysInMonth,
					iDays;
	
	string sNextDayDate[10];
	
	if (Debug_Logic)
	{
		trace ("\n** NextDayDate **\n");
		trace ("  StartDate:%s\n", sStartDate);
		trace ("  Days:%s\n", sDays);
	}
	
	// Convert starting date items to integers.
	iStartMonth = atoi(mid(sStartDate, 6, 2));
	iStartDay = atoi(right(sStartDate, 2));
	iStartYear = atoi(left(sStartDate, 4));
	iDaysInMonth = DaysInMonth(iStartMonth, iStartYear);
	
	iDays = atoi(sDays);
	
	if (Debug_Logic)
	{
		trace ("  StartMonth:%u\n", iStartMonth);
		trace ("  StartDay:%u\n", iStartDay);
		trace ("  StartYear:%u\n", iStartYear);
		trace ("  DaysInMonth:%u\n", iDaysInMonth);
		trace ("  Days:%u\n", iDays);
	}
	
	
	// Goto next day.
	
	// Days left in month?
	if (iStartDay + iDays <= iDaysInMonth)
	{
		// Yes, days left. Goto next day.
		
		if (Debug_Logic)
		{
			trace ("  Days left in month.\n");
		}
		
		iNextMonth = iStartMonth;
		iNextDay = iStartDay + iDays;
		iNextYear = iStartYear;
	}
	else
	{
		// No days left in month.
		
		if (Debug_Logic)
		{
			trace ("  No days left in month.\n");
		}
		
		// Last month of year?
		if (iStartMonth = 12)
		{
			// Yes, last month of year. Goto next year.
			iNextMonth = 1;
			iNextDay = (iStartDay + iDays) - iDaysInMonth;
			iNextYear = iStartYear + 1;
		}
		else
		{
			// Not the last month of the year. Goto next month.
			iNextMonth = iStartMonth + 1;
			iNextDay = (iStartDay + iDays) - iDaysInMonth;
			iNextYear = iStartYear;
		}
	}
	
	// Build return string.
	sNextDayDate = itoa(iNextYear);
	
	if (iNextMonth < 10)
	{
		sNextDayDate = sNextDayDate + "-" + "0" + itoa(iNextMonth);
	}
	else
	{
		sNextDayDate = sNextDayDate + "-" + itoa(iNextMonth);
	}
	
	if (iNextDay < 10)
	{
		sNextDayDate = sNextDayDate + "-" + "0" + itoa(iNextDay);
	}
	else
	{
		sNextDayDate = sNextDayDate + "-" + itoa(iNextDay);
	}
	
	if (Debug_Logic)
	{
		trace ("  NextDayDate:%s\n", sNextDayDate);
	}
	
	return (sNextDayDate);
}

/////////////////////////////////////////////////////////////////////
//
// Function: GetIsPrivate()
//
// Parameters: <none>
//
// Return Value: <none>
//
// Description: xxxx.
//
//
/////////////////////////////////////////////////////////////////////
Function GetIsPrivate(string sMeetingID)
{
	string sXML[1000];
	
  if (Debug_Logic)
  {
  	trace ("\n** GetIsPrivate **\n");
  	trace ("  sMeetingID:%s\n", sMeetingID);
  }
  
  sXML = "";

	g_sIsPrivateRequestID = "IsPrivate" + itoa(gethseconds());
							
  sXML =
  	"<RequestSchedule>" +
   		"<RequestID>" + g_sIsPrivateRequestID + "</RequestID>" +
   		"<MeetingID>" + sMeetingID + "</MeetingID>" +
   		"<FieldList>" +
   			"<Field>MeetingID</Field>" +
   			"<Field>IsPrivate</Field>" +
   		"</FieldList>" +
   	"</RequestSchedule>";							
							
	do
	{
								
		if (len(sXML) > 240)
		{
			To_RV_ScheduleQuery$ = removebylength(240, sXML);
		}
		else
		{
			To_RV_ScheduleQuery$ = removebylength(len(sXML), sXML);
		}
								
	} until (len(sXML) = 0);
							  	
}

/////////////////////////////////////////////////////////////////////
//
// Function: GetSchedule()
//
// Parameters: <none>
//
// Return Value: <none>
//
// Description: xxxx.
//
//
/////////////////////////////////////////////////////////////////////
Function GetSchedule(integer iRequestType, string sStartDate, string sStartTime, string sHourSpan)
{  
  string sXML[1000];
  
  if (Debug_Logic)
  {
  	trace ("\n** GetShcedule **\n");
  	trace ("  RequestType:%u\n", iRequestType);
  	trace ("  StartDate:%s\n", sStartDate);
  	trace ("  StartTime:%s\n", sStartTime);
  	trace ("  HourSpan:%s\n", sHourSpan);
  }
  
  
  if (iRequestType = REQUEST_TODAY)
  {
		// Removed to prevent UI from flashing
    //Have_Valid_Workday_Sched = FALSE;
		
		Workday_Sched_Request_Mode = REQUEST_MODE_BUSY;
    
    g_sScheduleRequestID = "Workday" + itoa(gethseconds());
    
  	sXML =
   		"<RequestSchedule>" +
   		"<RequestID>" + g_sScheduleRequestID + "</RequestID>" +
   		"<Start>" + sStartDate + "T" + sStartTime + "</Start>" +
   		"<HourSpan>" + sHourSpan + "</HourSpan>" +
   		"<FieldList>" +
   			"<Field>MeetingID</Field>" +
   			"<Field>RVMeetingID</Field>" +
   			"<Field>InstanceID</Field>" +
   			"<Field>Recurring</Field>" +
   			"<Field>dtStart</Field>" +
   			"<Field>dtEnd</Field>" +
   			"<Field>Subject</Field>" +
   			"<Field>Organizer</Field>" +
   			"<Field>IsPrivate</Field>" +
   			"<Field>IsExchangePrivate</Field>" +
   		"</FieldList>" +
   		"</RequestSchedule>";
   		
  }
  else if (iRequestType = REQUEST_AUTO_UPDATE)
  {
    Auto_Update_Request_Mode = REQUEST_MODE_BUSY;
    
    g_sAutoUpdateRequestID = "AutoUpdate" + itoa(gethseconds());
    g_sAutoUpdateRequestDate = sStartDate;
    
  	sXML =
   		"<RequestSchedule>" +
   		"<RequestID>" + g_sAutoUpdateRequestID + "</RequestID>" +
   		"<Start>" + sStartDate + "T" + sStartTime + "</Start>" +
   		"<HourSpan>" + sHourSpan + "</HourSpan>" +
   		"<FieldList>" +
   			"<Field>MeetingID</Field>" +
   			"<Field>RVMeetingID</Field>" +
   			"<Field>InstanceID</Field>" +
   			"<Field>Recurring</Field>" +
   			"<Field>dtStart</Field>" +
   			"<Field>dtEnd</Field>" +
   			"<Field>Subject</Field>" +
   			"<Field>Organizer</Field>" +
   			"<Field>IsPrivate</Field>" +
   			"<Field>IsExchangePrivate</Field>" +
   		"</FieldList>" +
   		"</RequestSchedule>";
   		
  }
  else if (iRequestType = REQUEST_NEXT_RESERV)
  {
  	Next_Reserv_Request_Mode = REQUEST_MODE_BUSY;
  	
  	g_sNextReservRequestID = "NextReserv" + itoa(gethseconds());
  	
  	sXML =
   		"<RequestSchedule>" +
   		"<RequestID>" + g_sNextReservRequestID + "</RequestID>" +
   		"<Start>" + sStartDate + "T" + sStartTime + "</Start>" +
   		"<HourSpan>" + sHourSpan + "</HourSpan>" +
   		"<FieldList>" +
   			"<Field>MeetingID</Field>" +
   			"<Field>InstanceID</Field>" +
   			"<Field>dtStart</Field>" +
   			"<Field>dtEnd</Field>" +
   			"<Field>Subject</Field>" +
   			"<Field>Organizer</Field>" +
   			"<Field>IsPrivate</Field>" +
   			"<Field>IsExchangePrivate</Field>" +
   		"</FieldList>" +
   		"</RequestSchedule>";
  }
  else if (iRequestType = REQUEST_FIRST_APPT)
  {
  	First_Appt_Request_Mode = REQUEST_MODE_BUSY;
  	
  	g_sFirstApptRequestID = "FirstAppt" + itoa(gethseconds());
  	
  	sXML =
   		"<RequestSchedule>" +
   		"<RequestID>" + g_sFirstApptRequestID + "</RequestID>" +
   		"<Start>" + sStartDate + "T" + sStartTime + "</Start>" +
   		"<HourSpan>" + sHourSpan + "</HourSpan>" +
   		"<Action ID=\x22RequestFirstAppt\x22 />" +
   		"<FieldList>" +
   			"<Field>MeetingID</Field>" +
   			"<Field>InstanceID</Field>" +
   			"<Field>dtStart</Field>" +
   			"<Field>dtEnd</Field>" +
   			"<Field>Subject</Field>" +
   			"<Field>Organizer</Field>" +
   			"<Field>IsPrivate</Field>" +
   			"<Field>IsExchangePrivate</Field>" +
   		"</FieldList>" +
   		"</RequestSchedule>";
  }
	
  if (len(sXML) > 240)
  {
  	do
   	{
   			
   		if (len(sXML) > 240)
   		{
   			To_RV_ScheduleQuery$ = removebylength(240, sXML);   				
   		}
   		else
   		{
   			To_RV_ScheduleQuery$ = removebylength(len(sXML), sXML);
   		}
   			
   	} until (len(sXML) = 0);
  }
}

/////////////////////////////////////////////////////////////////////
//
// Function: GetScheduleDelay()
//
// Parameters: <none>
//
// Return Value: <none>
//
// Description: xxxx.
//
//
/////////////////////////////////////////////////////////////////////
Function GetScheduleDelay()
{
	integer iSeed,
					iDelay;
	
	if (Debug_Logic)
	{
		trace ("\n** GetScheduleDelay **\n"); 
	}
  
  iSeed = gethseconds();
  
  iDelay = (random(0, 10) * 60) * 100;

	if (Debug_Logic)
	{
		trace ("  iDelay:%u\n", iDelay); 
	}
	  
  wait (iDelay, GetScheduleDelayWait)
  {  
  	call GetSchedule(REQUEST_TODAY, g_sDateToday, "00:00:00", "24");
  }
}

/////////////////////////////////////////////////////////////////////
//
// Function: RegisterPush()
//
// Parameters: <none>
//
// Return Value: <none>
//
// Description: xxxx.
//
//
/////////////////////////////////////////////////////////////////////
Function RegisterPush(integer bRegister)
{
  string sDate[10],
  			 sTime[8],
  			 sStart[19];
  
  if (Debug_Logic)
  {
  	trace ("\n** RegisterPush **\n");
  	trace ("  bRegister:%u\n", bRegister);
  }
  
  Register_Push_Request_Mode = REQUEST_MODE_BUSY;
  
  sDate = date(3);
  sDate = left(sDate, 4) + "-" + mid(sDate, 6, 2) + "-" + right(sDate, 2);
  sTime = time();
  
  sStart = sDate + "T" + "00:00:00";
  
  
  
  
  if (bRegister)
  {   
  	g_sActionPushRequestID = "ActionRegisterPush" + itoa(gethseconds());
  	g_sPushRequestID = "Push" + itoa(gethseconds());
  	
  	g_sXML =
   		"<RequestAction>" +
   		"<RequestID>" + g_sActionPushRequestID + "</RequestID>" +
   		"<ActionID>RegisterPushModel</ActionID>" +
   			"<Parameters>" +
   				"<Parameter ID=\x22Enabled\x22 Value=\x221\x22 />" +
   				"<Parameter ID=\x22RequestID\x22 Value=\x22" + g_sPushRequestID + "\x22 />" +
   				"<Parameter ID=\x22Start\x22 Value=\x22" + sStart + "\x22 />" +
   				"<Parameter ID=\x22HourSpan\x22 Value=\x2224\x22 />" +
   				"<Parameter ID=\x22Field\x22 Value=\x22MeetingID\x22 />" +
   				"<Parameter ID=\x22Field\x22 Value=\x22RVMeetingID\x22 />" +
   				"<Parameter ID=\x22Field\x22 Value=\x22InstanceID\x22 />" +
   				"<Parameter ID=\x22Field\x22 Value=\x22Recurring\x22 />" +
   				"<Parameter ID=\x22Field\x22 Value=\x22dtStart\x22 />" +
   				"<Parameter ID=\x22Field\x22 Value=\x22dtEnd\x22 />" +
   				"<Parameter ID=\x22Field\x22 Value=\x22Subject\x22 />" +
   				"<Parameter ID=\x22Field\x22 Value=\x22Organizer\x22 />" +
   				"<Parameter ID=\x22Field\x22 Value=\x22IsPrivate\x22 />" +
   				"<Parameter ID=\x22Field\x22 Value=\x22IsExchangePrivate\x22 />" +
   			"</Parameters>" +
   		"</RequestAction>";
  }
  else
  {
  	g_sActionPushRequestID = "ActionUnRegisterPush" + itoa(gethseconds());
  	g_sPushRequestID = "";
  	
  	g_sXML =
   		"<RequestAction>" +
   		"<RequestID>" + g_sActionPushRequestID + "</RequestID>" +
   		"<ActionID>RegisterPushModel</ActionID>" +
   			"<Parameters>" +
   				"<Parameter ID=\x22Enabled\x22 Value=\x220\x22 />" +
   				"<Parameter ID=\x22RequestID\x22 Value=\x22DUMMY\x22 />" +
   				"<Parameter ID=\x22Start\x22 Value=\x22" + sStart + "\x22 />" +
   				"<Parameter ID=\x22HourSpan\x22 Value=\x220\x22 />" +
   			"</Parameters>" +
   		"</RequestAction>";  
  }
  
  
   
  if (len(g_sXML) > 240)
  {
  	do
  	{  		
  		// Not already waiting to send data.
  		if (!g_bWaitingToSendRVData)
  		{
  			g_bWaitingToSendRVData = TRUE;

  			if (len(g_sXML) > 240)
  			{
  				wait (Serial_Pacing_Time)
  				{
  					To_RV_ActionQuery$ = removebylength(240, g_sXML);
  					g_bWaitingToSendRVData = FALSE;
  				}
  			}
  			else
  			{
  				wait (Serial_Pacing_Time)
  				{
  					// Need this last check because
  					// loop happens before UNTIL has a
  					// chance to check string length.
  					
  					if (len(g_sXML) > 0)
  					{
  						To_RV_ActionQuery$ = removebylength(len(g_sXML), g_sXML);
  					}
  					
  					g_bWaitingToSendRVData = FALSE;
  				}
  			}
  		}
  		
  	} until (len(g_sXML) = 0);
  }
  else
  {
  	To_RV_ActionQuery$ = g_sXML;
  }
   		
}

/////////////////////////////////////////////////////////////////////
//
// Function: NextReservation()
//
// Parameters: <none>
//
// Return Value: Next Event number
//
// Description: Find the next reservation.
//
//
/////////////////////////////////////////////////////////////////////
Integer_Function NextReservation(integer bEnableRequestNextReserv)
{
  integer bDateValid;
  
  integer i,
  				iEventNum,
  				iNextEvent,
  				iEventStartTime,
  				iEventEndTime;
  
  string  sRequestTime[8],
  				sNextReservationIn[8];

  iEventNum = 0;
  iNextEvent = 0;
  bDateValid = FALSE;
  
  if (Debug_Logic)
  {
    trace ("\n** NextReservation **\n");
    trace ("  AllowRequestNextReserv:%u\n", bEnableRequestNextReserv);
  }
          
	  
	// Any events stored?
	if (g_iStoredEventCount > 0)
	{
  	if (Debug_Logic)
    {
    	trace ("  Events are stored.\n");
    }
	  
	  // Which event to use?
	  if (g_iStartedEventNum > 0)
	  {
	  	// Use started event
	  	
	  	if (Debug_Logic)
	  	 trace ("  Using started event.\n");
	  	
	  	// Event ends today?
	   	if (MeetingEvent[g_iStartedEventNum].EndDate = g_sDateToday)
	   	{
	   		// Yes, event ends today. Check time.
	   		
	   		if (Debug_Logic)
	   		 trace ("  Event ends today. Checking meeting end time against current time.\n");
	   		
	   		// Convert meeting end time to minutes.
		    iEventEndTime = TimeToInteger(MeetingEvent[g_iStartedEventNum].EndTime, TIME_FORMAT_HHMM);
	   	  
	   	  if (Debug_Logic)
	   	  {
	   	  	trace ("  iEventEndTime:%u\n", iEventEndTime);
	   	  	trace ("  g_iCurrentTime:%u\n", g_iCurrentTime);
	   	  }
	   	  
	   	  
	   	  // Event already ended?
	   	  if (g_iCurrentTime >= iEventEndTime)
	   	  {
	   	  	// Yes, event has already ended. Do not use it.
	   	  	
	   	  	if (Debug_Logic)
	   	  	 trace ("  Event has already ended. Use current event num.\n");
	   	  	
	   	  	iEventNum = g_iCurrentEventNum;
	   	  }
	   	  else
	   	  {
	   	  	// Event has not ended. Use it.
	   	  	
	   	  	if (Debug_Logic)
	   	  	 trace ("  Event has not ended. Use it.\n");
	   	  	
	   	  	iEventNum = g_iStartedEventNum;
	   	  }
	   	}
	  }
	  else if (g_iCurrentEventNum > 0)
	  {
	  	// Use current event
	  	
	  	iEventNum = g_iCurrentEventNum;
	  	
	  	if (Debug_Logic)
	  	 trace ("  Using current event.\n");
	  }
	  else
	  {
	  	if (Debug_Logic)
	  	 trace ("  No event started or current.\n");
	  }
	    
	  // Event?
	  if (iEventNum > 0)
	  {
	    // Yes, have current event.
	      
	    if (Debug_Logic)
	    {
	    	trace ("    Have Event:%u\n", iEventNum);
	    	trace ("    Event StartDate:%s\n", MeetingEvent[iEventNum].StartDate);
	    	trace ("    Event StartTime:%s\n", MeetingEvent[iEventNum].StartTime);
	    }	    
	      
	    // Any events after current?
	    if (iEventNum < g_iStoredEventCount)
	    {
	    	// Yes, look at the next event
	      	
	      if (Debug_Logic)
	      {
	      	trace ("  Looking at next event after active.\n");
	      }
	     		       	
	      iNextEvent = iEventNum + 1;
	      
	    	if (Debug_Logic)
	    	{
	    		trace ("    iNextEvent:%u\n", iNextEvent);
	    		trace ("    NextEvent StartDate:%s\n", MeetingEvent[iNextEvent].StartDate);
	    		trace ("    NextEvent StartTime:%s\n", MeetingEvent[iNextEvent].StartTime);
	    	}
	    }
	    else
	    {
	      // No events left after active.
	      	
	      if (Debug_Logic)
	      {
	      	trace ("  No events left after active.\n");
	      }
	      	
     		// Is the current event end date = today?
      	if (MeetingEvent[iEventNum].EndDate = g_sDateToday)
      	{
      		// Yes, the current event ends today.
      		
      		if (Debug_Logic)
      		 trace ("    Current event ends today.\n");
      		 
      		// Use tomorrow's date as the request date.
  				g_sNextReservRequestDate = NextDayDate(g_sDateToday, "1");
      			
  				// Use 00:00:00 as the request time.
  				sRequestTime = "00:00:00";	
      	}
      	else
      	{
      		// Event does not end today.
      		
      		if (Debug_Logic)
      		 trace ("    Current event does not end today\n");
      		
      		// Use the event's end date to find the next day.
      		g_sNextReservRequestDate = NextDayDate(MeetingEvent[iEventNum].EndDate, "1");
      			
      		// Use the event's end time to find the next minute.
      		sRequestTime = NextTimeMin(MeetingEvent[iEventNum].EndTime);      		
      	}
	    } 
	  }
	  else
	  {
	    // No event.
	      
	    if (Debug_Logic)
	     trace ("    No current event. Looking ...\n");
	      
      // Use tomorrow's date as the request date.
      g_sNextReservRequestDate = NextDayDate(g_sDateToday, "1");
      			
      // Use 00:00:00 as the request time.
      sRequestTime = "00:00:00";	      
	      
	    for (i = 1 to g_iStoredEventCount)
	    {
	      if (g_sDateToday = MeetingEvent[i].StartDate &&
	       g_sDateToday = MeetingEvent[i].EndDate)
	      {
	      	bDateValid = TRUE;
	      }
	      else if (g_sDateToday = MeetingEvent[i].StartDate &&
	       DateToInteger(g_sDateToday) < DateToInteger(MeetingEvent[i].EndDate))
	      {
	        bDateValid = TRUE;
	      }
	        
	        
	      if (bDateValid)
	      {		        
		      // Convert meeting start time to minutes.
		      iEventStartTime = TimeToInteger(MeetingEvent[i].StartTime, TIME_FORMAT_HHMM);
	          
	        if (iEventStartTime > g_iCurrentTime)
	        {
	        	if (Debug_Logic)
	        	{
	          	trace ("    Found Next Event:%u\n", i);
	    				trace ("    NextEvent StartDate:%s\n", MeetingEvent[i].StartDate);
	    				trace ("    NextEvent StartTime:%s\n", MeetingEvent[i].StartTime);
	          }
	            
	           iNextEvent = i;
	           break;
	        }
	      }
	        
	    } // End for(i = 1 to g_iStoredEventCount)
	      	      
	  } // End else g_iCurrentEventNum > 0
	    
	} // End if(g_iStoredEventCount > 0)
	else
	{
	  // No events stored.
	  	
	  if (Debug_Logic)
	  {
	  	trace ("  No events stored.\n");
	  }
	}
	
	
	// Was a next event found in current meeting data?
	if (iNextEvent > 0)
	{
		// Yes, next event found. Update outputs.
		// Since next event was found in today's data, no need to display date on UI.
      
    if (Debug_Logic)
    {
      trace ("  Next event found:%u. Updating output.\n", iNextEvent);
	    trace ("    NextEvent StartDate:%s\n", MeetingEvent[iNextEvent].StartDate);
	    trace ("    NextEvent StartTime:%s\n", MeetingEvent[iNextEvent].StartTime);
    }
        	
    NextEvent.MeetingID = MeetingEvent[iNextEvent].MeetingID;
    NextEvent.InstanceID = MeetingEvent[iNextEvent].InstanceID;
    NextEvent.StartDate = MeetingEvent[iNextEvent].StartDate;
    NextEvent.StartTime = MeetingEvent[iNextEvent].StartTime;
    NextEvent.EndDate = MeetingEvent[iNextEvent].EndDate;
    NextEvent.EndTime = MeetingEvent[iNextEvent].EndTime;
    NextEvent.Organizer = MeetingEvent[iNextEvent].Organizer;
		NextEvent.Subject = MeetingEvent[iNextEvent].Subject;
		NextEvent.IsPrivate = MeetingEvent[iNextEvent].IsPrivate;
		NextEvent.IsExchangePrivate = MeetingEvent[iNextEvent].IsExchangePrivate;
      
	  Next_Reservation_Date$ = FormatDate(MeetingEvent[iNextEvent].StartDate, 2);
	  Next_Reservation_HrMin$ = FormatTime(MeetingEvent[iNextEvent].StartTime);
	  
	  // Need date & time?
	  if (NextEvent.StartDate != g_sDateToday)		      
	   Next_reservation_DateTime$ = FormatDate(MeetingEvent[iNextEvent].StartDate, 2) + " " + FormatTime(MeetingEvent[iNextEvent].StartTime);
	  else
	   Next_reservation_DateTime$ = FormatTime(MeetingEvent[iNextEvent].StartTime);

    sNextReservationIn = TimeDiff(TIME_FORMAT_DD_HH_MM, g_sDateToday, g_sCurrentTime, MeetingEvent[iNextEvent].StartDate, MeetingEvent[iNextEvent].StartTime);
    Next_Reservation_In$ = FormatTimeDiff(sNextReservationIn);
    	  
	  SendFreeBusyAttributeData(MeetingEvent[iNextEvent].StartDate, MeetingEvent[iNextEvent].StartTime);

    Have_Next_Reservation = TRUE;
    
    // Private?
    if (NextEvent.IsPrivate || NextEvent.IsExchangePrivate)
     Next_Reservation_Private = TRUE;
    else
     Next_Reservation_Private = FALSE;
  		
  	// Push enabled?
  	if (g_bPushEnabled)
  	{
  		// Yes, push enabled.
  		// Reset need first appt so the next time a next event
  		// is not found, the first appt request is made.
  		
  		g_bNeedFirstApptRequest = TRUE;
  	}  	
  	
  	return (iNextEvent);			
	}
	else
	{
		// Next event was not found in current meting data.
			
		if (Debug_Logic)
		{
			trace ("  Next event was not found.\n");
		}
		
		// Clear next event data if not push registered & bEnNextReservationRequest
		// We will be getting next reserv data from the request response
		if (!g_bPushEnabled && bEnableRequestNextReserv)
		 NextEvent.MeetingID = "";
		
		// Next event stored from NextReserv or FirstAppt response?
		if (len(NextEvent.MeetingID) > 0)
		{
			// Yes, have next event. Update outputs.
			
			if (Debug_Logic)
			{
				trace ("  Have stored next event. Updating outputs\n");
			}
			
	  	Next_Reservation_Date$ = FormatDate(NextEvent.StartDate, 2);
	  	Next_Reservation_HrMin$ = FormatTime(NextEvent.StartTime);
	  	
	  	// Need date & time?
	  	if (NextEvent.StartDate != g_sDateToday)		      
	  	 Next_reservation_DateTime$ = FormatDate(NextEvent.StartDate, 2) + " " + FormatTime(NextEvent.StartTime);
	  	else
	  	 Next_reservation_DateTime$ = FormatTime(NextEvent.StartTime);  		
  		
  		SendFreeBusyAttributeData(NextEvent.StartDate, NextEvent.StartTime);
  		
    	sNextReservationIn = TimeDiff(TIME_FORMAT_DD_HH_MM, g_sDateToday, g_sCurrentTime, NextEvent.StartDate, NextEvent.StartTime);
   		Next_Reservation_In$ = FormatTimeDiff(sNextReservationIn);
  		
    	Have_Next_Reservation = TRUE;
    
    	// Private?
    	if (NextEvent.IsPrivate || NextEvent.IsExchangePrivate)
     	 Next_Reservation_Private = TRUE;
    	else
     	 Next_Reservation_Private = FALSE;			
		}
		else
		{
			// Do not have a stored next event.
		  
		  if (Debug_Logic)
		  {
		  	trace ("  Do not have stored next event.\n");
		  }
      
			// Use tomorrow's date as the request date.
      g_sNextReservRequestDate = NextDayDate(g_sDateToday, "1");
      			
      // Use 00:00:00 as the request time.
      sRequestTime = "00:00:00";
      
      // Clear outputs.
	  	Next_Reservation_Date$ = "";
	  	Next_Reservation_HrMin$ = "";	      
	  	Next_reservation_DateTime$ = "";
	  	
	  	// Free until = today + 4 days
	  	SendFreeBusyAttributeData(NextDayDate(g_sDateToday, "4"), "00:00:00");  		
  		  		
    	Have_Next_Reservation = FALSE;    
     	Next_Reservation_Private = FALSE;
     	   		
  		// Push enabled?
  		if (g_bPushEnabled)
  		{
  			// Yes, push enabled.
				
				if (Debug_Logic)
				{
					trace ("  Push enabled\n");
				}
				
				
				if (g_bNeedFirstApptRequest)
				{
					g_bNeedFirstApptRequest = FALSE;
					
					call GetSchedule(REQUEST_FIRST_APPT, g_sNextReservRequestDate, sRequestTime, "72");
				}  			
  		}
  		else
  		{
  			// Push not enabled.

				if (Debug_Logic)
				{
					trace ("  Push not enabled\n");
				}
				
				// Request next reservation?
				if (bEnableRequestNextReserv)
				{
					// Yes, allow request next reservation.
				
					if (Debug_Logic)
					{
						trace ("  Need NextReserv request.\n");
					}
				
					call GetSchedule(REQUEST_NEXT_RESERV, g_sNextReservRequestDate, sRequestTime, "72");
				}
			}
		}
		
		return (0);
	}
}

/////////////////////////////////////////////////////////////////////
//
// Function: SendNoShowData()
//
// Parameters: <none>
//
// Return Value: <none>
//
// Description: xxxx.
//
//
/////////////////////////////////////////////////////////////////////
Function SendNoShowData(integer Type, integer Index)
{
  integer bSend;
  
  string sTemp[500],
  			 sRecurring[5],
  			 sStatus[8],
  			 sDate[10];  
  
  if (Debug_Logic)
  {
  	trace ("\n** SendNoShowData **\n");
  	trace ("    Index:%u\n", Index);
  }
  
  if (Type = 0)
  {
  	// No current meeting. Send empty data so tech status is cleared.
  	
  	// Only send data once.
  	if (g_sLastSentNoShowID <> "")
  	{  	
  		To_NoShow_Mod_DataIn$ = "<NoShowData></NoShowData>";
  		
  		g_sLastSentNoShowID = "";
  	}
  }
  else
  {  
	  bSend = FALSE;
	  sDate = date(1);
	  
	  if (Type = 1)
	  {
	  	sStatus = "NoShow";
	  }
	  else
	  {
	  	sStatus = "Show";
	  }
	  
	  
	  if (Debug_Logic)   
	   trace ("    Type:%s\n", sStatus);
	  
	  // Only send data if it has not been sent yet
	  
	  // ID already sent?
	  if (MeetingEvent[Index].MeetingID <> g_sLastSentNoShowID)
	  {
	  	// No, ID has not been sent.
	  	
	  	if (Debug_Logic)
	  	 trace ("    Have not sent this ID yet\n");
	  	
	  	bSend = TRUE;
	  }
	  else
	  {
	  	// Already sent this ID.
	  	
	  	// Are we on the next day?
	  	if (sDate <> g_sLastSentNoShowDate)
	  	{
	  		// Yes, we are on different date. Need to send data again.
	  		
	  		if (Debug_Logic)
	  	 	 trace ("    Already sent this ID, but on different date\n");
	  	   		
	  		bSend = TRUE; 
	  	}
	  	else
	  	{
	  		if (Debug_Logic)
	  	 	 trace ("    Already sent this ID AND on same date\n");  	
	  	}
	  	
	  }
	  
	  
	  if (bSend)
	  {
	  	if (Debug_Logic)
	  	 trace ("    Sending data\n");
	  	
	  	
	  	g_sLastSentNoShowID = MeetingEvent[Index].MeetingID;
	  	g_sLastSentNoShowDate = date(1);
	  
	  
		  //recurring meeting?
		  if (MeetingEvent[Index].Recurring)
		  {
		    if (Debug_Logic)    
		     trace ("    Meeting type is Recurring\n");
		      
		    sTemp = "<NoShowData>" +
		             "<Status>" + sStatus + "</Status>" +
		             "<Subject>" + MeetingEvent[Index].Subject + "</Subject>" +
		             "<MeetingID>" + MeetingEvent[Index].MeetingID + "</MeetingID>" +
		             "<RVMeetingID>" + MeetingEvent[Index].RVMeetingID + "</RVMeetingID>" +
		             "<Recurring>True</Recurring>" +
		             "</NoShowData>";  
		  }
		  else
		  {
		    //single instance meeting
		    
		    if (Debug_Logic)
		     trace ("    Meeting type is Single\n");
		     
		    sTemp = "<NoShowData>" +
		              "<Status>" + sStatus + "</Status>" +
		              "<Subject>" + MeetingEvent[Index].Subject + "</Subject>" +
		              "<MeetingID>" + MeetingEvent[Index].MeetingID + "</MeetingID>" +
		              "<RVMeetingID>" + MeetingEvent[Index].RVMeetingID + "</RVMeetingID>" +
		              "<Recurring>False</Recurring>" +
		              "</NoShowData>";
		  }
		  
		  if (len(sTemp) > 0)
		  {
		    if (len(sTemp) > 240)
		    {
		      To_NoShow_Mod_DataIn$ = left(sTemp, 240);
		      To_NoShow_Mod_DataIn$ = right(sTemp, len(sTemp) - 240);
		    }
		    else
		     To_NoShow_Mod_DataIn$ = sTemp;
		  }
		}
		else
		{
			if (Debug_Logic)
			 trace ("    Not sending data\n");
		}
	}
}

/////////////////////////////////////////////////////////////////////
//
// Function: CheckNoShow()
//
// Parameters: <none>
//
// Return Value: <none>
//
// Description: xxxx.
//
//
/////////////////////////////////////////////////////////////////////
Function CheckNoShow()
{
  integer iEventIndex,
  				iEventEndTimeMin;
  				
  integer iDurationMinutes, iElapsedMinutes, iElapsedPercent;  
  
  if (Debug_Logic)
   trace ("\n** CheckNoShow **\n");  
    
  if (g_iCurrentEventNum > 0)
  {
  	if (Debug_Logic)
  	 trace ("    Current event num > 0.\n");
    
		iEventIndex = g_iCurrentEventNum;
		  
		iDurationMinutes = DurationMin();
		iElapsedMinutes = ElapsedTimeMin();
		iElapsedPercent = (iElapsedMinutes * 100) / iDurationMinutes; 
		
		//Set the outputs.
		Current_Meeting_Duration_Min = iDurationMinutes;
		Current_Meeting_Elapsed_Time = iElapsedMinutes;
		Current_Meeting_Elapsed_Percent = iElapsedPercent;    
    
    // Enable no show from config?
    if (Config_En_Decline_For_NoShow)
    {

  		if (Debug_Logic)
  	 	 trace ("    Config enable decline for no show.\n");	
		   
		  //Does meeting meet minimum requirements for no show logic?
		  if (iDurationMinutes <= Decline_Applies_Duration)
		  {
		    //Yes, meeting meets minimum.
		    
		    if (Debug_Logic)
		     trace ("    Meeting meets minimum\n");
		    
		    //Convert end time to minutes
		    iEventEndTimeMin = TimeToInteger(MeetingEvent[iEventIndex].EndTime, TIME_FORMAT_MINS);
		
		    if (Debug_Logic)
		    {
		    	trace ("    Date today:%s\n", g_sDateToday);
		    	trace ("    Event end date:%s\n", MeetingEvent[iEventIndex].EndDate);    	
		    	trace ("    Current time min:%u\n", g_iCurrentTimeMin);
		    	trace ("    Event end timemin:%u\n", iEventEndTimeMin);
		    }
		         
		    //Make sure the meeting is not over
		    if ((MeetingEvent[iEventIndex].EndDate = g_sDateToday &&
		      g_iCurrentTimeMin < iEventEndTimeMin) ||
		     DateToInteger(MeetingEvent[iEventIndex].EndDate) > DateToInteger(g_sDateToday))
		    {
		
		    	if (Debug_Logic)
		     	 trace ("    Meeting not over\n");    
		    
			    //Did someone start the meeting?
			    if (g_iStartedEventNum = iEventIndex)
			    {
			    	//Yes, someone started the meeting, so this is a Show
			    	call SendNoShowData(2, iEventIndex);
			    }
          else if (g_bStartMeetingConfirmed)
          {
            //Yes, someone started the meeting via confirmation btn, so this is a Show
			    	call SendNoShowData(2, iEventIndex);
          }
			    else
			    {
			    	//Meeting was not started.
			      
			      //Is the room already occupied?
			      if (Room_Occupied_FB)
			      {
              if (!Config_Decline_For_NoShow_En_CheckAtExactMin)
              {
			      	  //Yes. This is a show.
			      	  call SendNoShowData(2, iEventIndex);
			        }
              else
              {
                 //Check For On Exact Minute
                 if (iElapsedMinutes = Decline_Meeting_Min)
                 {
                   //Yes, This is a show.
                   call SendNoShowData(2, iEventIndex);
                 }
                 else
                 {
                    //Unsure...Wait and Do Nothing
                    if (Debug_Logic)
                    {
                       trace("\r** Decline For No Show Unsure **\r");
                    }
                 }
              }
            }
			      else
			      {
			        //Since room is not occupied, need to check for show
			      
				    	//Use minutes for no show?
				    	if (Decline_Meeting_Min > 0)
				    	{      
				      	//Yes, use minutes for no show
				      
				      	if (Debug_Logic)
				      	 trace ("    Using minutes. Current:%u\n", iElapsedMinutes);
				      
				      
				      	//Minutes reached?
				      	if (iElapsedMinutes >= Decline_Meeting_Min)
				      	{
				        	//Yes, minutes reached. Check occupied status.
				        
				        	if (Debug_Logic)
				         	 trace ("    Minutes reached. No Show!\n");
				            
				          call SendNoShowData(1, iEventIndex);  
				      	}
				    	}
				    	else
				    	{
				      	//Use percent for no show.
				      
				      	if (Debug_Logic)      
				        	trace ("    Using percent. Current:%u\n", iElapsedPercent);
				      
				      	//Percent reached?
				      	if (iElapsedPercent >= Decline_Meeting_Percent)
				      	{
				        	//Yes, percent reached. Check occupied status.
				        
				        	if (Debug_Logic)
				         	 trace ("    Percent reached. No show!\n");
				          
				          call SendNoShowData(1, iEventIndex);
				      	}
				    	}
				    }
				  }
				}
				else
				{
					// Meeting is over.
					
		    	if (Debug_Logic)
		     	 trace ("    Meeting is over\n");
				}
		  }
		  else
		  {
		  	//Meeting does not meet minimum requirements
		  	
		  	if (Debug_Logic)
		  	 trace ("    Meeting Does Not Meet Minimum");
		  }
		  
		} // end if (Config_En_Decline_For_NoShow)
		
		else
		{
			if (Debug_Logic)
  	 	 trace ("    Config disable decline for no show.\n");
		}
	  
	} // end  if (g_iCurrentEventNum > 0)
	
	else
	{
		// Current event num = 0. Send empty no show data.

  	if (Debug_Logic)
  	 trace ("    Current event num = 0.\n");
  	 		
		call SendNoShowData(0, 0);
	}
}

/////////////////////////////////////////////////////////////////////
//
// Function: SetDateTimeVars()
//
// Parameters: <none>
//
// Return Value: <none>
//
// Description: xxxx.
//
//
/////////////////////////////////////////////////////////////////////
Function SetDateTimeVars()
{
  string sDate[10];
  integer iMinuteBlock;
  
  if (Debug_Logic)
   trace ("\n** SetDateTimeVars **\n");
  
  
  //* set date vars *
  
  sDate = date(3);
  
  g_sDateToday = left(sDate, 4) + "-" + mid(sDate, 6, 2) + "-" + right(sDate, 2);  
  
  //* set time vars *
  
  g_sCurrentTime = time();
  g_sCurrentTime = left(g_sCurrentTime, 5);
  
  g_iCurrentHour = gethournum();
  g_iCurrentMinute = getminutesnum();
  g_iCurrentTime = (g_iCurrentHour * 100) + g_iCurrentMinute;
  
  //convert the time to minutes
  g_iCurrentTimeMin = (g_iCurrentHour * 60) + g_iCurrentMinute;

  //what minute block are we on?
  if (g_iCurrentMinute < 30)
   iMinuteBlock = 0;
  else
   iMinuteBlock = 1;

  //convert the local time to a time block
  g_iCurrentTimeBlock = (g_iCurrentHour * 2) + iMinuteBlock + 1;
  
  // * set outputs *
  Current_Time$ = LocalTime();
  Current_Time_Hour = g_iCurrentHour;
  Current_Time_Minute = g_iCurrentMinute;
  Current_Date$ = Date(Date_Format+1);	
}

/////////////////////////////////////////////////////////////////////
//
// Function: EventIndex()
//
// Parameters: <none>
//
// Return Value: <none>
//
// Description: xxxx.
//
//
/////////////////////////////////////////////////////////////////////
Integer_Function EventIndex(integer iType, integer iIDType, string sID)
{
	integer i,
					iIndex;
	
	if (Debug_Logic)
	{
		trace ("\n** EventIndex **\n");
		trace ("  Type:%u\n", iType);
		trace ("  IDType:%u\n", iIDType);
		trace ("  ID:%s\n", sID);
	}
	
	iIndex = 0;
	
	if (iType = TYPE_WORKDAY)
	{
	
		if (g_iStoredEventCount > 0)
		{
			for (i = 1 to g_iStoredEventCount)
			{			
				if (iIDType = TYPE_MEETING_ID)
				{
					if (MeetingEvent[i].MeetingID = sID)
					{
						iIndex = i;
				
						break;
					}					
				}
				else if (iIDType = TYPE_INSTANCE_ID)
				{
					if (MeetingEvent[i].InstanceID = sID)
					{
						iIndex = i;
				
						break;
					}				
				}
			}
		}
	}
	else if (iType = TYPE_AUTO_UPDATE)
	{
	
		if (g_iAutoUpdateStoredEventCount > 0)
		{
			for (i = 1 to g_iAutoUpdateStoredEventCount)
			{
				if (iIDType = TYPE_MEETING_ID)
				{
					if (AutoUpdateMeetingEvent[i].MeetingID = sID)
					{
						iIndex = i;
				
						break;
					}					
				}
				else if (iIDType = TYPE_INSTANCE_ID)
				{
					if (AutoUpdateMeetingEvent[i].InstanceID = sID)
					{
						iIndex = i;
				
						break;
					}				
				}
			}
		}
	}
	
	if (Debug_Logic)
	{
		trace ("  Index:%u\n", iIndex);
	}
	
	return (iIndex);
}

/////////////////////////////////////////////////////////////////////
//
// Function: UpdateNextReservInfo()
//
// Parameters: <none>
//
// Return Value: <none>
//
// Description: xxxx.
//
//
/////////////////////////////////////////////////////////////////////
Function UpdateNextReservInfo()
{
  if (Debug_Logic)
   trace ("\n** UpdateNextReservInfo **\n");
   
  // Have event?
  if (len(NextEvent.MeetingID) > 0)
  {
  	// Yes, have next event.

    Next_Reservation_Subject$ = NextEvent.Subject;
    Next_Reservation_Start_Date$ = FormatDate(NextEvent.StartDate, 2);
    Next_Reservation_Start_Time$ = FormatTime(NextEvent.StartTime);
    Next_Reservation_End_Date$ = FormatDate(NextEvent.EndDate, 2);
    Next_Reservation_End_Time$ = FormatTime(NextEvent.EndTime);
    
    // Organizer
    if (len(NextEvent.Organizer) = 0)
     Next_Reservation_Organizer$ = "Unknown";
    else
     Next_Reservation_Organizer$ = NextEvent.Organizer;   	
  }
  else
  {
    Next_Reservation_Organizer$ = "";
    Next_Reservation_Subject$ = "";
    Next_Reservation_Start_Date$ = "";
    Next_Reservation_Start_Time$ = "";
    Next_Reservation_End_Date$ = "";
    Next_Reservation_End_Time$ = "";  
  }
}

/////////////////////////////////////////////////////////////////////
//
// Function: GetMeetingInfo()
//
// Parameters: <none>
//
// Return Value: <none>
//
// Description: xxxx.
//
//
/////////////////////////////////////////////////////////////////////
Function GetMeetingInfo(integer iType, integer iRequestType, string sMeetingID)
{
	string sXML[500];
	
	if (Debug_Logic)
	{
		trace ("\n** GetMeetingInfo **\n");
		trace ("  iType:%u\n", iType);
		trace ("  iRequestType:%u\n", iRequestType);
		trace ("  sMeetingID:%s\n", sMeetingID); 
	}
	
	if (iType = MEETING_INFO_CURRENT)
	{
		// Type is Current Meeting
    
    if (iRequestType = MEETING_INFO_REQUEST_ATTENDEES)
    {
    	// Attendees request
  		
  		Current_Meeting_Info_Request_Mode = REQUEST_MODE_BUSY;
  		
  		g_sCurrentMeetingInfoRequestID = "CurrentInfoAttendees" + itoa(gethseconds());
  		
  		Current_Meeting_Required_Attendees$ = "Requesting data ...";
    	Current_Meeting_Optional_Attendees$ = "Requesting data ...";
		
			sXML =
  			"<RequestSchedule>" +
   				"<RequestID>" + g_sCurrentMeetingInfoRequestID + "</RequestID>" +
   				"<MeetingID>" + sMeetingID + "</MeetingID>" +
   					"<FieldList>" +
   						"<Field>Attendees</Field>" +
   						"<Field>Resources</Field>" +
   					"</FieldList>" +
   			"</RequestSchedule>";
   	}
   	else if (iRequestType = MEETING_INFO_REQUEST_PRESET_DATA)
   	{
   		// Preset data request
      
      g_sCurrentMeetingPresetDataRequestID = "CurrentInfoPresetData" + itoa(gethseconds());
      
			sXML =
  			"<RequestSchedule>" +
   				"<RequestID>" + g_sCurrentMeetingPresetDataRequestID + "</RequestID>" +
   				"<MeetingID>" + sMeetingID + "</MeetingID>" +
   					"<FieldList>" +
   						"<Field>MeetingPresets</Field>" +
   					"</FieldList>" +
   			"</RequestSchedule>";   		
   	}
	}
	else if (iType = MEETING_INFO_NEXT)
	{
		// Type is Next Meeting
    
    if (iRequestType = MEETING_INFO_REQUEST_ATTENDEES)
    {
    	// Attendees request
    	
    	Next_Meeting_Info_Request_Mode = REQUEST_MODE_BUSY;
    	
    	g_sNextMeetingInfoRequestID = "NextInfoAttendees" + itoa(gethseconds());
    	
  		Next_Reservation_Required_Attendees$ = "Requesting data ...";
    	Next_Reservation_Optional_Attendees$ = "Requesting data ...";
    		
			sXML =
  			"<RequestSchedule>" +
   				"<RequestID>" + g_sNextMeetingInfoRequestID + "</RequestID>" +
   				"<MeetingID>" + sMeetingID + "</MeetingID>" +
   					"<FieldList>" +
   						"<Field>Attendees</Field>" +
   						"<Field>Resources</Field>" +
   					"</FieldList>" +
   			"</RequestSchedule>";
		}
	}
	
  if (len(sXML) > 240)
  {
  	do
   	{
   			
   		if (len(sXML) > 240)
   		{
   			To_RV_ScheduleQuery$ = removebylength(240, sXML);   				
   		}
   		else
   		{
   			To_RV_ScheduleQuery$ = removebylength(len(sXML), sXML);
   		}
   			
   	} until (len(sXML) = 0);
  }
  else
   To_RV_ScheduleQuery$ = sXML;
}

/////////////////////////////////////////////////////////////////////
//
// Function: UpdateCurrentMeetingInfo()
//
// Parameters: <none>
//
// Return Value: <none>
//
// Description: xxxx.
//
//
/////////////////////////////////////////////////////////////////////
Function UpdateCurrentMeetingInfo()
{
  integer iEventNum;
  
  string sStartEnd[50];
  
  if (Debug_Logic)
   trace ("\n** UpdateCurrentMeetingInfo **\n");
  
  // Update current time id's
  if (g_iCurrentEventNum > 0)
  {
  	CurrentTime_Meeting_ID$ = MeetingEvent[g_iCurrentEventNum].MeetingID;
  	CurrentTime_RVMeeting_ID$ = MeetingEvent[g_iCurrentEventNum].RVMeetingID;
  }
  else
  {
  	CurrentTime_Meeting_ID$ = "";
  	CurrentTime_RVMeeting_ID$ = "";
  }
  
  
  // Set event number based on started, extended or current event.
  if (g_iStartedEventNum > 0)
   iEventNum = g_iStartedEventNum;
  else if (g_iCurrentEventNum > 0)
   iEventNum = g_iCurrentEventNum;
  else
   iEventNum = 0;
   
  // Event active?
  if (iEventNum > 0)
  {
  	// Yes, event active.
  	
  	// Did we get the welcome msg yet?
  	// If preset module is connected, it will take care of this.
  	
  	if(!g_bHaveMeetingPresetModule && g_sCurrentMeetingWelcomeMsgID != MeetingEvent[iEventNum].MeetingID)
  	{
  		// No, did not get welcome message and preset module not connected.
  		
  		g_sCurrentWelcomeMsg = "";
  		Current_Meeting_Welcome_Msg$ = g_sCurrentWelcomeMsg;
  		
  		g_sCurrentMeetingWelcomeMsgID = MeetingEvent[iEventNum].MeetingID;
  		
  		call GetMeetingInfo(MEETING_INFO_CURRENT, MEETING_INFO_REQUEST_PRESET_DATA, MeetingEvent[iEventNum].MeetingID);
  	}
  	
  	Current_Meeting_Meeting_ID$ = MeetingEvent[iEventNum].MeetingID;
  	Current_Meeting_RVMeeting_ID$ = MeetingEvent[iEventNum].RVMeetingID;
    Current_Meeting_Subject$ = MeetingEvent[iEventNum].Subject;
    Current_Meeting_Start_Date$ = FormatDate(MeetingEvent[iEventNum].StartDate, 2);
    Current_Meeting_Start_Time$ = FormatTime(MeetingEvent[iEventNum].StartTime);
    Current_Meeting_End_Date$ = FormatDate(MeetingEvent[iEventNum].EndDate, 2);
    Current_Meeting_End_Time$ = FormatTime(MeetingEvent[iEventNum].EndTime); 
    Current_Meeting_Welcome_Msg$ = g_sCurrentWelcomeMsg;
    
    // Organizer
    if (len(MeetingEvent[iEventNum].Organizer) = 0)
     Current_Meeting_Organizer$ = "Unknown";
    else
     Current_Meeting_Organizer$ = MeetingEvent[iEventNum].Organizer;

    // Format start end ...
    
    // Does event start today?
    
    if (MeetingEvent[iEventNum].StartDate = g_sDateToday)
    {
    	// Yes, meeting starts today. Just use start time.
    	
    	sStartEnd = FormatTime(MeetingEvent[iEventNum].StartTime);
    }
    else
    {
    	// Event does not start today. Need to show start date and time.
    	
    	sStartEnd = FormatDate(MeetingEvent[iEventNum].StartDate, 2) +
    	 " " + FormatTime(MeetingEvent[iEventNum].StartTime);
    }
    
    // Does event end today?
    if (MeetingEvent[iEventNum].EndDate = g_sDateToday)
    {
    	// Yes, meeting ends today. Just use end time.
    	
    	sStartEnd = sStartEnd + " - " + FormatTime(MeetingEvent[iEventNum].EndTime);
    }
    else
    {
    	// Event does not end today. Need to show end date and time.
    	
    	sStartEnd = sStartEnd + " - " + FormatDate(MeetingEvent[iEventNum].EndDate, 2) +
    	 " " + FormatTime(MeetingEvent[iEventNum].EndTime);
    }    
    
    Current_Meeting_StartEnd$ = sStartEnd;
  }
  else
  {
  	// No active event.
  	
		Current_Meeting_Meeting_ID$ = "";
		Current_Meeting_RVMeeting_ID$ = "";
		Current_Meeting_Organizer$ = "";
    Current_Meeting_Subject$ = "";
    Current_Meeting_Start_Date$ = "";
    Current_Meeting_Start_Time$ = "";
    Current_Meeting_End_Date$ = "";
    Current_Meeting_End_Time$ = "";
    Current_Meeting_StartEnd$ = "";
    g_sCurrentWelcomeMsg = "";
    Current_Meeting_Welcome_Msg$ = ""; 	
  } 	
}

/////////////////////////////////////////////////////////////////////
//
// Function: ClearPresetInfo()
//
// Parameters: <none>
//
// Return Value: <none>
//
// Description: xxxx.
//
//
/////////////////////////////////////////////////////////////////////
Function ClearPresetInfo()
{  
  string sXML[500];
  
  if (Debug_Logic)
  {
  	trace ("\n** ClearPresetInfo **\n"); 
	}
  
	// Already sent empty list?
	if (g_sLastSentGetPresetDataID != "-1")
	{
	  // No, have not sent empty list.
	
	  if (Debug_Logic)
	   trace ("  Have not empty list.\n");
	  		   		
	  g_sLastSentGetPresetDataID = "-1";
	  		
	  To_MeetingPreset_Mod_DataIn$ =
	   "<ScheduleInterfaceData><Type=\x22PresetData\x22 />";
	
	  To_MeetingPreset_Mod_DataIn$ =
	   "<MeetingPresets></MeetingPresets>";
	  		 
	  To_MeetingPreset_Mod_DataIn$ =
	   "</ScheduleInterfaceData>";
	}
	else
	{
	  // Already sent empty list.
	  		
	  if (Debug_Logic)
	   trace ("  Already sent empty list.\n");
	}
}

/////////////////////////////////////////////////////////////////////
//
// Function: GetPresetInfo()
//
// Parameters: <none>
//
// Return Value: <none>
//
// Description: xxxx.
//
//
/////////////////////////////////////////////////////////////////////
Function GetPresetInfo(integer iEventIndex)
{
  integer i,
  				iEventStartTimeMin;
  
  string sXML[500];
  
  if (Debug_Logic)
  {
  	trace ("\n** GetPresetInfo **\n");
    trace ("  iEventIndex:%u\n", iEventIndex); 
	}
	   	 	 	 	 	   
	// Get preset data?
	if (iEventIndex > 0)
	{
	  // Yes, get preset data.
	
		if (Debug_Logic)
    {
      trace ("  Subject:%s.\n", MeetingEvent[iEventIndex].Subject);
	  }
    		   	
	  // Have we retrieved this data yet?
	  if (g_sLastSentGetPresetDataID != MeetingEvent[iEventIndex].MeetingID)
	  {
			if (Debug_Logic)
	  	 trace ("  Have not retrieved this data yet.\n");
	  		
	  	g_sLastSentGetPresetDataID = MeetingEvent[iEventIndex].MeetingID;
	  	g_iLastSentGetPresetDataIndex = iEventIndex;
	  		
	  	call GetMeetingInfo(MEETING_INFO_CURRENT, MEETING_INFO_REQUEST_PRESET_DATA, MeetingEvent[iEventIndex].MeetingID);
	  }
	  else
	  {
	  	// Already retrieved this data.
	  		
			if (Debug_Logic)
	  	 trace ("  Already retrieved this data.\n");
	  }
	}
	else
	{
	  // Do not an event index. This means there is no active event.
	
		if (Debug_Logic)
	   trace ("  Do not have an event index.\n");
	}
}

/////////////////////////////////////////////////////////////////////
//
// Function: GetRVMeetingID()
//
// Parameters: <none>
//
// Return Value: <none>
//
// Description: xxxx.
//
//
/////////////////////////////////////////////////////////////////////
Function GetRVMeetingID(string sMeetingID)
{
	string sXML[500];
	
	if (Debug_Logic)
	{
		print ("\n** GetRVMeetingID **\n");
		print ("    sMeetingID:%s\n", sMeetingID);
	}
	
	//Has this request already been sent?
	if (sMeetingID <> g_sLastSentGetMeetingID)
	{
	  g_sLastSentGetMeetingID = sMeetingID;
	  
	  g_sActionRVIDRequestID = "ActionRVID" + itoa(gethseconds());
	  
		sXML = "";
	
		sXML =
			"<RequestAction>" +
				"<RequestID>" + g_sActionRVIDRequestID + "</RequestID>" +
				"<ActionID>RequestRVID</ActionID>" +
				"<Parameters>" +
					"<Parameter ID = \x22MeetingID\x22 Value = \x22" + sMeetingID + "\x22 />" +
				"</Parameters>" +
			"</RequestAction>";
			
		if (len(sXML) > 240)
		{
			do
			{
				if (len(sXML) > 240)
				{
					To_RV_ActionQuery$ = removebylength(240, sXML);
				}
				else
				{
					To_RV_ActionQuery$ = removebylength(len(sXML), sXML);
				}
			
			} until (len(sXML) = 0);
		}
		else
		{
			To_RV_ActionQuery$ = sXML;
		}
	} 
}

/////////////////////////////////////////////////////////////////////
//
// Function: CheckRoomStatus()
//
// Parameters: <none>
//
// Return Value: <none>
//
// Description: xxxx.
//
//
/////////////////////////////////////////////////////////////////////
Function CheckRoomStatus(integer bEnableRequestNextReserv)
{
  integer i,
  				bNeedNextEvent,
  				bNextEventDateValid,
  				bStartTimeValid,
  				bEndTimeValid,
          bPresetStartTimeValid,
          bPresetEndTimeValid,
  				iMinuteBlock;

  integer iEventStartTimeMin,
  				iEventEndTimeMin,
  				iNextReservation;
  
  integer iPresetEventIndex;
  
  if (Debug_Logic)
   trace ("\n** CheckRoomStatus **\n");
	  
	// Reset vars.
	bNextEventDateValid = FALSE;
	bNeedNextEvent = FALSE;
	
	g_iCurrentEventNum = 0;  
  
  if (Debug_Logic)
  {
  	trace ("    Started Event Num:%u\n", g_iStartedEventNum);
  }
  
  
  // Have Next Reservation?
  if (len(NextEvent.MeetingID) > 0)
  {
    // Yes, have Next Reservation.
    	
    if (Debug_Logic)
    {
    	trace ("    Have Next Reservation.\n");
    }
    
    // Is NextReserv start date valid?
	  if (g_sDateToday = NextEvent.StartDate || DateToInteger(g_sDateToday) < DateToInteger(NextEvent.StartDate))
	  {
	  	if (Debug_Logic)
	  	{
	  		trace ("    Next Reservation start date still valid.\n");
	  	}
	  	
	  	// NextReserv start date = today?
	  	if (g_sDateToday = NextEvent.StartDate)
	  	{
	  		// Yes, NextReserv start date = today
	  		
	  		if (Debug_Logic)
	  		{
	  			trace ("    Next Reservation start date = today. Need to check start time.\n");
	  		}
	  		
	  		// Is current time past?
	  		iEventStartTimeMin = TimeToInteger(NextEvent.StartTime, TIME_FORMAT_MINS);

				if (Debug_Logic)
				{
					trace ("    NextEvent.StartTime:%s\n", NextEvent.StartTime);
					trace ("    iEventStartTimeMin:%u\n", iEventStartTimeMin);
					trace ("    g_iCurrentTimeMin:%u\n", g_iCurrentTimeMin);
				}
	  		
	  		if (g_iCurrentTimeMin >= iEventStartTimeMin)
	  		{
	  			// Yes, current time past. Clear data.
	  			
	  			if (Debug_Logic)
	  			{
	  				trace ("    Next Reservation time not valid anymore. Clearing data.\n");
	  			}
	  			
	  			NextEvent.MeetingID = "";
	  			NextEvent.InstanceID = "";
	  			NextEvent.StartDate = "";
	  			NextEvent.StartTime = "";
	  			NextEvent.EndDate = "";
	  			NextEvent.EndTime = "";
	  			NextEvent.Organizer = "";
	  			NextEvent.Subject = ""; 
	  		}
	  		else
	  		{
	  			// Current time is not past Next Reserv start time.
	  			
	  			if (Debug_Logic)
	  			{
	  				trace ("    Next Reservation time still valid.\n");
	  			}
	  		}
	  	}
	  	else
	  	{
	  		// NextReserv start date != today. Event is still valid.
	  		
	  		if (Debug_Logic)
	  		{
	  			trace ("    Next Reservation start date > today. Event still valid.\n");
	  		}
	  	}
	  }
	  else
	  {
	  	if (Debug_Logic)
	  	{
	  		trace ("    Next Reservation start date not valid. Clearing data.\n");
	  	}

	  	NextEvent.MeetingID = "";
	  	NextEvent.InstanceID = "";
	  	NextEvent.StartDate = "";
	  	NextEvent.StartTime = "";
	  	NextEvent.EndDate = "";
	  	NextEvent.EndTime = "";
	  	NextEvent.Organizer = "";
	  	NextEvent.Subject = "";	
	  }
	}
  
  // Any events?
  if (g_iStoredEventCount > 0)
  {
	  // Have a started event?
	  if (g_iStartedEventNum > 0)
	  {
	  	// Have a started event. See if it is still valid.

	  	if (Debug_Logic)
	  	{
	  		trace ("    Have a started event number. See if ID still valid.\n");
	  	}
	  	
	  	bStartTimeValid = FALSE;
	    bEndTimeValid = FALSE;
	  	
	  	if (EventIndex(TYPE_WORKDAY, TYPE_MEETING_ID, MeetingEvent[g_iStartedEventNum].MeetingID))
	  	{
	  		// ID is still valid.

	  		if (Debug_Logic)
	  		{
	  			trace ("    ID is still valid. Check dates & times.\n");
	  		}
	  		  	
				// Check start date
				if (MeetingEvent[g_iStartedEventNum].StartDate = g_sDateToday)
				{
					// Event starts today. Need to check start time
					
					iEventStartTimeMin = TimeToInteger(MeetingEvent[g_iStartedEventNum].StartTime, TIME_FORMAT_MINS);
					
					// Adjust event start time based on parameter (only if meeting start > preset start time)
          // to prevent roll back into previous day.
          if (iEventStartTimeMin >= Meeting_Preset_Start_Time)
					 iEventStartTimeMin = iEventStartTimeMin - Meeting_Preset_Start_Time;
							
					if (g_iCurrentTimeMin >= iEventStartTimeMin)
						bStartTimeValid = TRUE;
				}
				else if (DateToInteger(MeetingEvent[g_iStartedEventNum].StartDate) < DateToInteger(g_sDateToday)) 
				{
					// Event starts before today.
							
					bStartTimeValid = TRUE;
				}
				
				// Check end date					
				if (MeetingEvent[g_iStartedEventNum].EndDate = g_sDateToday)
				{
					// Event end today. Need to check end time
							
					iEventEndTimeMin = TimeToInteger(MeetingEvent[g_iStartedEventNum].EndTime, TIME_FORMAT_MINS);
							
					if (g_iCurrentTimeMin < iEventEndTimeMin)
					 bEndTimeValid = TRUE;
				}
				else if (DateToInteger(MeetingEvent[g_iStartedEventNum].EndDate) > DateToInteger(g_sDateToday)) 
				{
					// Event end after today.
							
					bEndTimeValid = TRUE;
				}
				
				// Start/End times valid?
				if (bStartTimeValid && bEndTimeValid)
				{
					// Start/end times still valid.
					
					if (Debug_Logic)
	  			{
	  				trace ("    Start/end times still valid. Start meeting index still valid.\n");
	  			} 
				}
				else
				{
					if (Debug_Logic)
	  			{
	  				trace ("    Start/end times not valid. Start meeting index not valid.\n");
	  			}
	  			
	  			g_iStartedEventNum = 0;
	  			g_sStartedEventID = "";
          
          if (g_bHaveMeetingPresetModule)
           call ClearPresetInfo();				
				}
	  		
	  	} // *end if (MeetingEvent[g_iStartedEventNum].MeetingID = g_sStartedEventID)
	  	
	  	else
	  	{
	  		// Meeting id not valid anymore. Clear start meeting.
	  		
	  		if (Debug_Logic)
	  		{
	  			trace ("    Meeting id not valid anymore. Clear variable.\n");
	  		}
	  		
	  		g_iStartedEventNum = 0;
	  		g_sStartedEventID = "";
        
        if (g_bHaveMeetingPresetModule)
         call ClearPresetInfo();	  		
	  	}
	  	
	  } // *end if (g_iStartedEventNum > 0)
	  
	  // Need to find the current meeting and any meeting to request a preset for.
	  
    iPresetEventIndex = 0;
      
	  for (i = 1  to g_iStoredEventCount)
	  {
	    bStartTimeValid = FALSE;
	    bEndTimeValid = FALSE;
      
      bPresetStartTimeValid = FALSE;
      bPresetEndTimeValid = FALSE;
	    
			// Dates are already validated when the meeting events come down.
			// We only have to check the start/end times based on the start/end dates to see if this
			// meeting is active.	    


			// Check start date
			if (MeetingEvent[i].StartDate = g_sDateToday)
			{
				// Event starts today. Need to check start time
						
				iEventStartTimeMin = TimeToInteger(MeetingEvent[i].StartTime, TIME_FORMAT_MINS);
						
				if (g_iCurrentTimeMin >= iEventStartTimeMin)
				 bStartTimeValid = TRUE;
         
        if (iEventStartTimeMin >= Meeting_Preset_Start_Time)
	   	 	 iEventStartTimeMin = iEventStartTimeMin - Meeting_Preset_Start_Time;
	   	 			
				if (g_iCurrentTimeMin >= iEventStartTimeMin)
				 bPresetStartTimeValid = TRUE;
			}
			else if (DateToInteger(MeetingEvent[i].StartDate) < DateToInteger(g_sDateToday)) 
			{
				// Event starts before today.
						
				bStartTimeValid = TRUE;
        
        bPresetStartTimeValid = TRUE;
			}
			
			// Check end date					
			if (MeetingEvent[i].EndDate = g_sDateToday)
			{
				// Event end today. Need to check end time
						
				iEventEndTimeMin = TimeToInteger(MeetingEvent[i].EndTime, TIME_FORMAT_MINS);
						
				if (g_iCurrentTimeMin < iEventEndTimeMin)
        {
				  bEndTimeValid = TRUE;
          bPresetEndTimeValid = TRUE;
			  }
      }
			else if (DateToInteger(MeetingEvent[i].EndDate) > DateToInteger(g_sDateToday)) 
			{
				// Event end after today.
						
				bEndTimeValid = TRUE;
        bPresetEndTimeValid = TRUE;
			}

	  	if (Debug_Logic)
	  	{
	  		trace ("    bStartTimeValid:%d bEndTimeValid:%d\n", bStartTimeValid, bEndTimeValid);
        trace ("    bPresetStartTimeValid:%d bPresetEndTimeValid:%d\n", bPresetStartTimeValid, bPresetEndTimeValid);
	  	}
        
      // Event valid for preset?
      if (bPresetStartTimeValid && bPresetEndTimeValid)
      {
        // Yes, event valid for preset.
          
        iPresetEventIndex = i;
      }
		
			// Event valid?
			if (bStartTimeValid && bEndTimeValid)
			{
				// Yes, event valid.
						
				g_iCurrentEventNum = i;
								
				break;						
			}
	      
	  } // End for loop
    
    // Found preset event?
    if (iPresetEventIndex > 0)
    {
      // Yes, found preset event index.

	    if (Debug_Logic)
      {
	      trace ("    Found Preset Event Index.\n");
	      trace ("     Index:%u\n", iPresetEventIndex);
      }      
      
      if (g_bHaveMeetingPresetModule) 
       call GetPresetInfo(iPresetEventIndex);      
    }
    else
    {
      // Did not find preset evnt index.
      
      if (g_bHaveMeetingPresetModule)
       call ClearPresetInfo();
    } 
      
    // Found current event?
	  if (g_iCurrentEventNum > 0)
	  {
	    // Yes, found current event.
	      
	    if (Debug_Logic)
      {
	      trace ("    Found Current Event.\n");
	      trace ("     Index:%u\n", g_iCurrentEventNum);
        trace ("     StartDate:%s\n", MeetingEvent[g_iCurrentEventNum].StartDate);
        trace ("     StartTime:%s\n", MeetingEvent[g_iCurrentEventNum].StartTime);
        trace ("     EndDate:%s\n", MeetingEvent[g_iCurrentEventNum].EndDate);
        trace ("     EndTime:%s\n", MeetingEvent[g_iCurrentEventNum].EndTime);
	    }
	    
	    // Do not have an RVMeetingID?
	    if (len(MeetingEvent[g_iCurrentEventNum].RVMeetingID) = 0)
	    {
	    	// Do not have an RVMeetingID. Request one.
	    	
	    	call GetRVMeetingID(MeetingEvent[g_iCurrentEventNum].MeetingID); 
	    }
	  }
	  else
	  {
	    // No, did not find current event.
	      
	    if (Debug_Logic)
       trace ("    No Current Event Found\n");
    
      Current_Meeting_Duration_Min = 0;
      Current_Meeting_Elapsed_Time = 0;
      Current_Meeting_Elapsed_Percent = 0;      
	  }     
  }
  else //no stored events
  {    
    // No stored events.
    
    Meeting_Active = FALSE;
    
    Current_Meeting_Duration_Min = 0;
    Current_Meeting_Elapsed_Time = 0;
    Current_Meeting_Elapsed_Percent = 0;
    
    // If no events are stored, a meeting cannot be started.
    g_iStartedEventNum = 0;
    g_sStartedEventID = "";   
  }

	if (g_iStartedEventNum > 0)
  {
  	if (Debug_Logic)
  	 trace ("    Event is started. Use it for time remaining.\n");
  	
  	Time_Remaining_HrMin$ = TimeRemaining(2);
  }
  else
  {
  	if (Debug_Logic)
  	 trace ("    Event is not extended or started. See if there is a current event.\n");
  	 
  	if (g_iCurrentEventNum > 0)
  	{
    	// Current meeting found.

  		if (Debug_Logic)
  	 	 trace ("    Have current meeting. Use it for time remaining.\n");      		
  		
  		Time_Remaining_HrMin$ = TimeRemaining(1);
  	}
  	else
  	{
  		if (Debug_Logic)
  	 	 trace ("    Do not have current meeting. Clear time remaining.\n");      		
  		
  		Time_Remaining_HrMin$ = "";
  	} 
  }
    
  // Meeting Active?  
  if (g_iCurrentEventNum > 0)
   Meeting_Active = TRUE;
  else
  {
    Meeting_Active = FALSE;
    g_bStartMeetingConfirmed = FALSE;
  }             
  
  // Meeting Started?
  if (g_iStartedEventNum > 0)
   Meeting_Started = TRUE;
  else
   Meeting_Started = FALSE;
  
  // Update current meeting info.
  call UpdateCurrentMeetingInfo();
  
  // Get next reservation?
  iNextReservation = NextReservation(bEnableRequestNextReserv);
  
  // Set BookNow
  call SetReserveNow();
  
  // Set the end/next meeting warn
  if (End_Next_Meeting_Warn_Time > 0)
   call SetEndNextMeetingWarn();   

  // Set current time bargraph
  if (Field_Qty > 0 && Current_Page > 0)
	 call SetCurrentTimeBargraphValue();
	
  // Check no show
  call CheckNoShow();
  
  // Remote system module connected?
  if (g_bHaveRemoteSysModule)
  {
  	call SendRemoteSystemData(REM_SYS_DATA_CURR_MEETING, "");
  	call SendRemoteSystemData(REM_SYS_DATA_NEXT_RESERV, "");
  }
  
  // Check Start Meeting
  call SetStartMeetingBtn();
  
  // Check End Meeting Early/Free Up Room
  call SetEndMeetingBtn();
}

/////////////////////////////////////////////////////////////////////
//
// Function: SendUICreateData()
//
// Parameters: <none>
//
// Return Value: <none>
//
// Description: xxxx.
//
//
/////////////////////////////////////////////////////////////////////
Function SendUICreateData(string sData)
{
	if (Debug_Logic)
	{
		trace ("\n** SendUICreateData **\n");
	}

	To_UI_Mod_DataIn$ =
		"<Data>" +
			"<Type>CreateResponse</Type>";
  
  if (len(sData) > 240)
  {
  	do
   	{  			
   		
   		if (len(sData) > 240)
   		{
   			To_UI_Mod_DataIn$ = removebylength(240, sData);   				
   		}
   		else
   		{
   			To_UI_Mod_DataIn$ = removebylength(len(sData), sData);
   		}
   			
   	} until (len(sData) = 0);
  }
  else
  {
  	To_UI_Mod_DataIn$ = sData;
  }
  
	To_UI_Mod_DataIn$ =
		"</Data>";	
}

/////////////////////////////////////////////////////////////////////
//
// Function: SendUISchedData()
//
// Parameters: <none>
//
// Return Value: <none>
//
// Description: xxxx.
//
//
/////////////////////////////////////////////////////////////////////
Function SendUISchedData(string sData)
{
	if (Debug_Logic)
	{
		trace ("\n** SendUISchedData **\n");
	}
	
	To_UI_Mod_DataIn$ =
		"<Data>" +
			"<Type>ScheduleResponse</Type>";
  
  if (len(sData) > 240)
  {
  	do
   	{  			
   		
   		if (len(sData) > 240)
   		{
   			To_UI_Mod_DataIn$ = removebylength(240, sData);   				
   		}
   		else
   		{
   			To_UI_Mod_DataIn$ = removebylength(len(sData), sData);
   		}
   			
   	} until (len(sData) = 0);
  }
  else
  {
  	To_UI_Mod_DataIn$ = sData;
  }
  
	To_UI_Mod_DataIn$ =
		"</Data>"; 
}

/////////////////////////////////////////////////////////////////////
//
// Function: SendUIEventList()
//
// Parameters: <none>
//
// Return Value: <none>
//
// Description: xxxx.
//
//
/////////////////////////////////////////////////////////////////////
Function SendUIEventList()
{
	integer i;
	
	if (Debug_Logic)
	{
		trace ("\n** SendUIEventList **\n");
	}
	
	if (g_iStoredEventCount > 0)
	{
		To_UI_Mod_DataIn$ =
			"<Data>" +
				"<Type>EventList</Type>";
		
		for (i = 1 to g_iStoredEventCount)
		{
			To_UI_Mod_DataIn$ =
				"<Event>" +
					"<MeetingID>" + MeetingEvent[i].MeetingID + "</MeetingID>";
			
			To_UI_Mod_DataIn$ =
					"<RVMeetingID>" + MeetingEvent[i].RVMeetingID + "</RVMeetingID>";
					
			To_UI_Mod_DataIn$ =		
					"<StartDate>" + MeetingEvent[i].StartDate + "</StartDate>" +
					"<StartTime>" + MeetingEvent[i].StartTime + "</StartTime>" +
					"<StartBlock>" + itoa(MeetingEvent[i].StartBlock) + "</StartBlock>";
			
			 To_UI_Mod_DataIn$ =
					"<EndDate>" + MeetingEvent[i].EndDate + "</EndDate>" +
					"<EndTime>" + MeetingEvent[i].EndTime + "</EndTime>" +
					"<EndBlock>" + itoa(MeetingEvent[i].EndBlock) + "</EndBlock>";
			
			To_UI_Mod_DataIn$ =
					"<Organizer>" + MeetingEvent[i].Organizer + "</Organizer>";
			
			To_UI_Mod_DataIn$ =
					"<Subject>" + MeetingEvent[i].Subject + "</Subject>" +
					"<IsPrivate>" + itoa(MeetingEvent[i].IsPrivate) + "</IsPrivate>" +
					"<IsExchangePrivate>" + itoa(MeetingEvent[i].IsExchangePrivate) + "</IsExchangePrivate>" +
				"</Event>";			
		}
		
		To_UI_Mod_DataIn$ =
			"</Data>";
	}
	else
	{
		To_UI_Mod_DataIn$ =
			"<Data>" +
				"<Type>EventList</Type>" +
			"</Data>";
	}
}

/////////////////////////////////////////////////////////////////////
//
// Function: SendAvailRoomsCreateData()
//
// Parameters: <none>
//
// Return Value: <none>
//
// Description: xxxx.
//
//
/////////////////////////////////////////////////////////////////////
Function SendAvailRoomsCreateData(string sData)
{
	if (Debug_Logic)
	{
		trace ("\n** SendAvailRoomsCreateData **\n");
	}

	To_Avail_Rooms_Mod_DataIn$ =
		"<Data>" +
			"<Type>CreateResponse</Type>";
  
  if (len(sData) > 240)
  {
  	do
   	{  			
   		
   		if (len(sData) > 240)
   		{
   			To_Avail_Rooms_Mod_DataIn$ = removebylength(240, sData);   				
   		}
   		else
   		{
   			To_Avail_Rooms_Mod_DataIn$ = removebylength(len(sData), sData);
   		}
   			
   	} until (len(sData) = 0);
  }
  else
  {
  	To_Avail_Rooms_Mod_DataIn$ = sData;
  }
  
	To_Avail_Rooms_Mod_DataIn$ =
		"</Data>";	
}

/////////////////////////////////////////////////////////////////////
//
// Function: WrapBlockText()
//
// Parameters: <none>
//
// Return Value: <none>
//
// Description: xxxx.
//
//
/////////////////////////////////////////////////////////////////////
Function WrapBlockText(string sText, integer iStartBlock, integer iEndBlock)
{
	integer i,
					iColumnWidth,
					iSpacePos,
					iLastSpacePos,
					iStartPos,
					bFindSpace;
	
	string sTextChunk[255];
	
	if (Debug_Logic)
	{
		trace ("\n** WrapBlockText **\n");
		trace ("  TextLen:%u\n", len(sText));
		trace ("  StartBlock:%u\n", iStartBlock);
		trace ("  EndBlock:%u\n", iEndBlock);
	}
	
	iColumnWidth = Column_Width;
	
	// Wrap the text down the blocks
	for (i = iStartBlock to iEndBlock)
	{
		
		// Still need to wrap?
		if (len(sText) > iColumnWidth)
		{
			// Yes, still need to wrap text.
			
			// Look at a chunk of text based on column width
			sTextChunk = left(sText, iColumnWidth);
			
			// Does the chunk contain any spaces?
			if (find(" ", sTextChunk))
			{
				bFindSpace = TRUE;
				iStartPos = 1;
				
				// Yes, found spaces. Find the last one.
				do
				{
					iSpacePos = find(" ", sTextChunk, iStartPos);
						
					if (Debug_Logic)
					{
						trace ("  iSpacePos:%u\n", iSpacePos);
					}
						
					if (iSpacePos > 0)
					{
						// Found a space.
							
						iLastSpacePos = iSpacePos;
							
						// Can we look beyound this spot?
						if (iSpacePos < iColumnWidth)
						{
							// Yes, there are still chars left
							iStartPos = iSpacePos + 1;					
						}
						else
						{
							// The space is at the last char
							bFindSpace = FALSE;
						}
					}
					else
					{
						// Did not find a space.
							
						bFindSpace = FALSE;
					}
					
				} until (!bFindSpace);
				
				// Remove all text including the last space.
				sTextChunk = removebylength(iLastSpacePos, sText);
			}
			else
			{
				// Did not find any spaces.
			}
		}
		else
		{
			// Do not need to wrap text.
			if (len(sText))
			{
				sTextChunk = removebylength(len(sText), sText);
			}
			else
			{
				sTextChunk = "";
			}
		}
		
		if (Debug_Logic)
		{
			trace ("  Block:%u\n", i);
			trace ("  TextChunk:%s\n", sTextChunk);
		}
		
		Time_Block_Text$[i] = sTextChunk;			
						
	}
}

/////////////////////////////////////////////////////////////////////
//
// Function: UpdateCalendar()
//
// Parameters: <none>
//
// Return Value: <none>
//
// Description: xxxx.
//
//
/////////////////////////////////////////////////////////////////////
Function UpdateCalendar()
{
  integer i,
  				j,
  				bValidEvent,
  				bPrivateEvent,
  				bNeedTextWrap,
  				iStartBlock,
  				iEndBlock,
  				iStartIndex,
  				iEndIndex,
  				iEventCount,
  				iSpan,
  				iPreviousEndBlock;
  				
  string sEventOrganizer[MAX_ORGANIZER_LEN],
  			 sEventSubject[MAX_SUBJECT_LEN],
  			 sBlockText[500];
  
  if (Debug_Logic)
  {
    trace ("\n** UpdateCalendar **\n");
  }
  

  iEventCount = g_iStoredEventCount;	
	iPreviousEndBlock = 0;
	
	if (Debug_Logic)
	{
		trace ("  EventCount:%u\n", iEventCount);
	}
	
	// Any events?
	if (iEventCount > 0)
	{
	
		// Loop through each event and set output
	  for (i = 1 to iEventCount)
	  {
			iStartBlock = 0;
	    iEndBlock = 0;
	    bPrivateEvent = FALSE;
			bValidEvent = FALSE;
			bNeedTextWrap = FALSE;
			
	
	    // Check for organizer
      if (len(MeetingEvent[i].Organizer) > 0)
       sEventOrganizer = MeetingEvent[i].Organizer;
      else
       sEventOrganizer = "Unknown";
       
	    sEventSubject = MeetingEvent[i].Subject;
				
			iStartBlock = MeetingEvent[i].StartBlock;
			iEndBlock = MeetingEvent[i].EndBlock;
			
			if (MeetingEvent[i].IsPrivate = TRUE || MeetingEvent[i].IsExchangePrivate = TRUE)
			 bPrivateEvent = TRUE;
			else
			 bPrivateEvent = FALSE;    
				
	  	// Calculate the span.
			if (iStartBlock = iEndBlock)
			{
				iSpan = 1;
			}
				
			else
			{
				iSpan = (iEndBlock - iStartBlock) + 1;				
			}
				
			if (Debug_Logic)
			{
				trace ("  Event:%u\n", i);
				trace ("  Span:%u\n", iSpan);
			}
				
			// Clear calendar?
			if (iStartBlock > iPreviousEndBlock + 1)
			{
				if (iPreviousEndBlock = 0)
				{
					// Previous end block = 0, so this is a fresh update.
						
					// Clear from beginning to now.
					call ClearCalendar(1, iStartBlock - 1);
				}
				else
				{
					// Previous end block <> 0, so we have a previous event on calendar.
						
					// Clear from previous end block to now.
					call ClearCalendar(iPreviousEndBlock + 1, iStartBlock - 1);
				}
			}	
				
			// Set block text
			if (Privacy_Level = 0)
			{
				// Public room. Check individual meeting privacy.
				
				if (bPrivateEvent)
				{
					sBlockText = "Private";		
				}
				else
				{		
					sBlockText =  "[" + sEventOrganizer + "] " + sEventSubject;
				}
			}
			else if (Privacy_Level = 1)
			{
				// Semi-Private room.
				
				// Check meeting privacy.
				if (bPrivateEvent)
				{
					sBlockText = "Private";
				}
				else
				{
					sBlockText = "[" + sEventOrganizer + "] " + "Private";
				}				
			}
			else if (Privacy_Level = 2)
			{
				// Private room. Hide everything.
					
				sBlockText = "Private";
			}
				
				
			// ** Set actual block modes **
				
			iPreviousEndBlock = iEndBlock;
				
			iStartIndex = iStartBlock;
			iEndIndex = iEndBlock;
				
	    if (Debug_Logic)
	    {
	    	trace ("  EventIndex:%u\n", i);
	    	trace ("  EventStartBlock:%u\n", iStartBlock);
				trace ("  EventEndBlock:%u\n", iEndBlock);
				trace ("  EventOrganizer:%s\n", sEventOrganizer);
				trace ("  EventSubject:%s\n", sEventSubject); 
	    }
				
				
	
			if (iSpan = 1)
			{
				Time_Block_Mode[iStartIndex] = 1;
				g_iBlockEventIndex[iStartIndex] = i;
						
				// Need to crop block text?
				if (len(sBlockText) > Column_Width)
				{
					sBlockText = left(sBlockText, Column_Width);	
				}
						
				Time_Block_Text$[iStartIndex] = sBlockText;			
			}
			else if (iSpan = 2)
			{
				// Need to wrap text?
				if (len(sBlockText) > Column_Width)
				{
				  bNeedTextWrap = TRUE;
				}
	
				// Set start.
				Time_Block_mode[iStartIndex] = 2;
				g_iBlockEventIndex[iStartIndex] = i;
					
				// Set end.
				Time_Block_Mode[iEndIndex] = 4;
				g_iBlockEventIndex[iEndIndex] = i;
						
				// Need to wrap text?
				if (bNeedTextWrap)
				{
					call WrapBlockText(sBlockText, iStartIndex, iEndIndex);
				}
				else
				{
					Time_Block_Text$[iStartIndex] = sBlockText;
					Time_Block_Text$[iEndIndex] = "";
				}			
			}
			else
			{
				// Need to wrap text?
				if (len(sBlockText) > Column_Width)
				{
				  bNeedTextWrap = TRUE;
				}
					
				// Set start.
				Time_Block_Mode[iStartIndex] = 2;
				g_iBlockEventIndex[iStartIndex] = i;			  
				  
				// Set in-between.
				if (iSpan > 2)
				{
					for (j = iStartIndex + 1 to iEndIndex - 1)
					{
						Time_Block_Mode[j] = 3;
						g_iBlockEventIndex[j] = i;
							
						if (!bNeedTextWrap)
						{
							Time_Block_Text$[j] = "";							
						}			
					}
				}
						
				// Set end.
				Time_Block_Mode[iEndIndex] = 4;
				g_iBlockEventIndex[iEndIndex] = i;
						
				// Need to wrap text?
				if (bNeedTextWrap)
				{
					call WrapBlockText(sBlockText, iStartIndex, iEndIndex);
				}
				else
				{
					Time_Block_Text$[iStartIndex] = sBlockText;
					Time_Block_Text$[iEndIndex] = "";			
				} 		
			}
			
	  }	// End for loop
	}
  
  // Clear end of calendar?
  if (iPreviousEndBlock = 0)
  {
  	// If PreviousEndBlock = 0, no events were found within UI.
  	// Clear entire calendar.
  	
  	call ClearCalendar(1, MAX_TIME_BLOCKS);
  }
  else 
  {
  	// PreviousEndBlock has value, so look at last end block.
  	
  	if (iEndIndex < MAX_TIME_BLOCKS)
  	{  	
  		call ClearCalendar(iEndIndex + 1, MAX_TIME_BLOCKS);
  	}
  }
  
  Schedule_Updated = TRUE;
  Schedule_Updated = FALSE;
}




Function ReserveNowSetLabels(Integer Max_Time, Integer iDurationMinutes)
{
  if (Max_Time = 30)
  {
    Reserve_Now_Select_30$ = ItoA(iDurationMinutes) + " Min";
  }
  else if (Max_Time = 60)
  {
    Reserve_Now_Select_60$ = ItoA(iDurationMinutes) + " Min";
  }
  else if (Max_Time = 90)
  {
    Reserve_Now_Select_90$ = ItoA(iDurationMinutes) + " Min";
  }
  else
  {
    //Do Nothing? Error Handling?
  }
}



Function CopyReserveNowData(ReserveNowData Dest, ReserveNowData Src)
{
  Dest.iStartYear     = Src.iStartYear;
  Dest.iStartMonth    = Src.iStartMonth;
  Dest.iStartDay      = Src.iStartDay;
  Dest.iStartHour     = Src.iStartHour;
  Dest.iStartMin      = Src.iStartMin;
  Dest.iStartSec      = Src.iStartSec;

  Dest.iEndYear       = Src.iEndYear;
  Dest.iEndMonth      = Src.iEndMonth;
  Dest.iEndDay        = Src.iEndDay;
  Dest.iEndHour       = Src.iEndHour;
  Dest.iEndMin        = Src.iEndMin;
  Dest.iEndSec        = Src.iEndSec;
}

Function SetReserveNowData(ReserveNowData Dest,
                           Integer iStartYear, Integer iStartMonth, Integer iStartDay, Integer iStartHour, Integer iStartMin, Integer iStartSec,
                           Integer iEndYear, Integer iEndMonth, Integer iEndDay, Integer iEndHour, Integer iEndMin, Integer iEndSec
                          )
{
  Dest.iStartYear     = iStartYear;
  Dest.iStartMonth    = iStartMonth;
  Dest.iStartDay      = iStartDay;
  Dest.iStartHour     = iStartHour;
  Dest.iStartMin      = iStartMin;
  Dest.iStartSec      = iStartSec;

  Dest.iEndYear       = iEndYear;
  Dest.iEndMonth      = iEndMonth;
  Dest.iEndDay        = iEndDay;
  Dest.iEndHour       = iEndHour;
  Dest.iEndMin        = iEndMin;
  Dest.iEndSec        = iEndSec;
}

Function ReserveNowSetData(Integer Max_Time, ReserveNowData Temp)
{
	if (Max_Time = 30)
	{
	  CopyReserveNowData(Select30Min, Temp);
	}
	else if (Max_Time = 60)
	{
	  CopyReserveNowData(Select60Min, Temp);
	}
	else if (Max_Time = 90)
	{
	  CopyReserveNowData(Select90Min, Temp);
	}
}

/////////////////////////////////////////////////////////////////////
//
// Function: SetReserveNowStartEnd()
//
// Parameters: <Min_Time, Max_Time>
//
// Return Value: <none>
//
// Description: xxxx.
//
//
/////////////////////////////////////////////////////////////////////

Integer_Function SetReserveNowStartEnd(Integer Min_Time, Integer Max_Time)
{
  integer iCurrentTime,
  				iNextEvent,
  				iStartTimeMinutes,
  				iEndTimeMinutes,
  				iNextStartTimeMinutes,
          iDurationMinutes;
  
  string sCurrentDate[10],
  			 sCurrentTime[8],
  			 sNextStartTime[8],
  			 sDTStart[20],
  			 sDTEnd[20];
  
  integer iCurrentMonth,
  				iCurrentDay,
  				iCurrentYear,
  				iCurrentDaysInMonth;
  
  integer iStartMonth,
  				iStartDay,
  				iStartYear,
  				iEndMonth,
  				iEndDay,
  				iEndYear;
  
  integer iStartHour,
  				iStartMin,
  				iEndHour,
  				iEndMin;
  				
  string sStartTime[5],
  			 sEndTime[5];
	
  ReserveNowData Temp;
  
	// Set current date/time vars
  sCurrentDate = g_sDateToday;
  sCurrentTime = time();
  sCurrentTime = left(sCurrentTime, 5);
  iCurrentTime = TimeToInteger(sCurrentTime, TIME_FORMAT_HHMM);	

	iCurrentMonth = atoi(mid(sCurrentDate, 6, 2));
	iCurrentDay = atoi(right(sCurrentDate, 2));
	iCurrentYear = atoi(left(sCurrentDate, 4));
		  
	// Get the next event.
	iNextEvent = NextReservation(FALSE);
	
	if (iNextEvent > 0)
	{
		// There is a next event, so we need to see how long we can book.
		
		if (Debug_Logic)
		{
			trace ("  There is a next reservation. Need to calculate duration.\n");
		}
		
		// Get the next reservation start time.
		sNextStartTime = MeetingEvent[iNextEvent].StartTime;
		iNextStartTimeMinutes = TimeToInteger(sNextStartTime, TIME_FORMAT_MINS);
		
		// Set the start time in minutes.
		iStartTimeMinutes = TimeToInteger(sCurrentTime, TIME_FORMAT_MINS);
		
		// Set the end time minutes
		iEndTimeMinutes = iStartTimeMinutes + Max_Time;
		
		// Is the end time into the next meeting?
		if (iEndTimeMinutes > iNextStartTimeMinutes)
		{
			// Yes, end time is into next meeting. Need to trim back.
			
			if (Debug_Logic)
			{
				trace ("  End time into next meeting. Need to trim back\n");
			}
			
			// Make end time = next start time
			iEndTimeMinutes = iNextStartTimeMinutes;
			
		}
		else
		{
			// No, end time not into next meeting. Leave existing end time.
			
			if (Debug_Logic)
			{
				trace ("  End time not into next meeting. Leave as is.\n");
			}
      
      if (Reserve_Now_Even_End_Time)
			{
	      if (Debug_Logic)
				{
	       	trace ("Force Even End Time");
				}      
        
        iEndTimeMinutes = iEndTimeMinutes - iEndTimeMinutes mod 30;
      }
		}
	}
	else
	{
		// There is not a next event. Book as long as we can.
		
		if (Debug_Logic)
		{
			trace ("  There is not a next reservation. Book as long as possible.\n");
		}
		
		// Set the start time in minutes.
		iStartTimeMinutes = TimeToInteger(sCurrentTime, TIME_FORMAT_MINS);
		
		// Set the end time in minutes.		
		iEndTimeMinutes = iStartTimeMinutes + Max_Time;
    
    if (Reserve_Now_Even_End_Time)
		{
      if (Debug_Logic)
			{
       	trace ("Force Even End Time");
			}      
       
       iEndTimeMinutes = iEndTimeMinutes - iEndTimeMinutes mod 30;
     }
	}
	
	if (Debug_Logic)
	{
		trace ("  iStartTimeMinutes:%u\n", iStartTimeMinutes);
		trace ("  iEndTimeMinutes:%u\n", iEndTimeMinutes);
	}
	
	
	// Check the end time hour value.
	iEndHour = iEndTimeMinutes / 60;
		
	// See if end hour is next day.
	if (iEndHour >= 24)
	{
		// Yes, end hour is next day.
		
		
				
		// ** Are we on the last day of the month?
			
		// Days in month
		iCurrentDaysInMonth = DaysInMonth(iCurrentMonth, iCurrentYear);
			
		// Last day?
		if (iCurrentDay < iCurrentDaysInMonth)
		{
			// No. Still have days left. Goto next day.
				
			iStartMonth = iCurrentMonth;
			iStartDay = iCurrentDay + 1;
			iStartYear = iCurrentYear; 
		}
		else
		{
			// Yes, on last day. Need to goto next month.
				
			// Before going to next month, see if we need to goto next year.
			if (iCurrentMonth < 12)
			{
				// No, do not need to goto next year.
					
				iStartMonth = iStartMonth + 1;
				iStartDay = 1;
				iStartYear = iCurrentYear;
			}
			else
			{
				// Yes, on the last month of the year. Goto next year.
					
				iStartMonth = 1;
				iStartDay = 1;
				iStartYear = iStartYear + 1;
			}
		}
	}
	else
	{
		// End hour is not next day.
		
		iStartMonth = iCurrentMonth;
		iStartDay = iCurrentDay;
		iStartYear = iCurrentYear;
		
		iStartHour = iStartTimeMinutes / 60;
		iStartMin = iStartTimeMinutes MOD 60;		
		
		iEndMonth = iCurrentMonth;
		iEndDay = iCurrentDay;
		iEndYear = iCurrentYear;
		
		iEndHour = iEndTimeMinutes / 60;
		iEndMin = iEndTimeMinutes MOD 60;
	}
  
  sStartTime = itoa(iStartHour) + ":" + itoa(iStartMin);
 	sEndTime = itoa(iEndHour) + ":" + itoa(iEndMin);
   
  sStartTime = FormatTime(sStartTime);
	sEndTime =   FormatTime(sEndTime);
	
  iDurationMinutes = iEndTimeMinutes - iStartTimeMinutes;
  	
	if (Debug_Logic)
	{
		trace ("  iStartMonth:%u\n", iStartMonth);
		trace ("  iStartDay:%u\n", iStartDay);
		trace ("  iStartYear:%u\n", iStartYear);
		trace ("  iStartHour:%u\n", iStartHour);
		trace ("  iStartMin:%u\n", iStartMin);
		trace ("  iEndMonth:%u\n", iEndMonth);
		trace ("  iEndDay:%u\n", iEndDay);
		trace ("  iEndYear:%u\n", iEndYear);
		trace ("  iEndHour:%u\n", iEndHour);
		trace ("  iEndMin:%u\n", iEndMin);
    trace ("  iDurationMinutes: %u\n", iDurationMinutes);
	}
	
  Temp.iStartYear     = iStartYear;
  Temp.iStartMonth    = iStartMonth;
  Temp.iStartDay      = iStartDay;
  Temp.iStartHour     = iStartHour;
  Temp.iStartMin      = iStartMin;
  Temp.iStartSec      = 0;

  Temp.iEndYear       = iEndYear;
  Temp.iEndMonth      = iEndMonth;
  Temp.iEndDay        = iEndDay;
  Temp.iEndHour       = iEndHour;
  Temp.iEndMin        = iEndMin;
  Temp.iEndSec        = 0;    
  
  if (Reserve_Now_Time_Select)
  {
    ReserveNowSetLabels(Max_Time, iDurationMinutes);
    ReserveNowSetData(Max_Time, Temp);
    
  }
  else
  {  			
	  // Set labels
	  Reserve_Now_Start_Time$ = sStartTime;
		Reserve_Now_End_Time$ = sEndTime;
		
		// Create dtStart & dtEnd
		g_sReserveNowDTStart = ReserveNowToIntDateFormat(Temp, "Start");							
		g_sReserveNowDTEnd = ReserveNowToIntDateFormat(Temp, "End");
 	}
  
  if (iDurationMinutes < Min_Time)
  {
     return (FALSE);
  }
  
	return (TRUE);
}


/////////////////////////////////////////////////////////////////////
//
// Function: ReserveNow()
//
// Parameters: <none>
//
// Return Value: <none>
//
// Description: xxxx.
//
//
/////////////////////////////////////////////////////////////////////
Function ReserveNow()
{
  
  string sXML[1000];
  			 	
	if (Debug_Logic)
	{
		trace ("\n** ReserveNow **\n");
	}
	
	Enable_Reserve_Now = FALSE;
  g_bStartMeetingConfirmed = TRUE;
	
	Reserve_Now_Request_Mode = REQUEST_MODE_BUSY;
	
	Reserve_Now_Message$ = "Please wait while the request\ris processed.";
	
	// Create RequestID
	g_sReserveNowRequestID = "RSRVNOW" + itoa(getHSeconds());
	
	// Build XML
	sXML =
		"<CreateSchedule>" +
		"<RequestID>" + g_sReserveNowRequestID + "</RequestID>" +
			"<Event>" +
				"<dtStart>" + g_sReserveNowDTStart + "</dtStart>" +
				"<dtEnd>" + g_sReserveNowDTEnd + "</dtEnd>" +
				"<Organizer>" + Reserve_Now_Organizer$ + "</Organizer>" +
				"<Subject>" + Reserve_Now_Subject$ + "</Subject>" +
			"</Event>" +
		"</CreateSchedule>";
	
	// Send request out.
	do
	{
		
		if (len(sXML) > 240)
		{
			To_RV_CreateMeeting$ = removebylength(240, sXML);
		}
		else
		{
			To_RV_CreateMeeting$ = removebylength(len(sXML), sXML);
		}
		
	} until (len(sXML) = 0);
		
}

/////////////////////////////////////////////////////////////////////
//
// Function: StartMeeting()
//
// Parameters: <none>
//
// Return Value: <none>
//
// Description: xxxx.
//
//
/////////////////////////////////////////////////////////////////////

Function StartMeeting()
{
  if (Debug_Logic)
  {
     trace ("Start Meeting Confirmed");
  }
  g_bStartMeetingConfirmed = TRUE;
  
  //Hide Start Btn and Sub
  Start_Meeting_Confirm_Sub = FALSE;
  Start_Meeting_Btn_FB = FALSE;
  Start_Meeting_Btn_Sub = FALSE;
}

/////////////////////////////////////////////////////////////////////
//
// Function: EndMeeting()
//
// Parameters: <none>
//
// Return Value: <none>
//
// Description: xxxx.
//
//
/////////////////////////////////////////////////////////////////////

Function EndMeeting()
{
  string sXML[1000];
  			 	
	if (Debug_Logic)
	{
		trace ("\n** EndMeeting **\n");
	}
	
	End_Meeting_confirm_sub = FALSE;
  End_Meeting_Btn_Sub = FALSE;
  End_Meeting_Btn_FB = FALSE;
	
	End_Meeting_Request_Mode = REQUEST_MODE_BUSY;
	
	Reserve_Now_Message$ = "Please wait while the request\ris processed.";
	
	// Create RequestID
	g_sEndMeetingRequestID = "EndMeeting" + itoa(getHSeconds());
    
  // Store Event ID
  g_sEndMeetingReqMeetingID = MeetingEvent[g_iCurrentEventNum].MeetingID;
  
  if (Debug_Logic)
  {
     trace ("Request ID = %s", g_sEndMeetingRequestID);
     trace ("Meeting ID = %s", g_sEndMeetingReqMeetingID);
  }
   	
	// Build XML
	sXML =
		"<RequestAction>" + 
    "<RequestID>" + g_sEndMeetingRequestID + "</RequestID>" + 
    "<ActionID>MeetingChange</ActionID>" + "<Parameters>" + 
    "<Parameter ID=\x22MeetingID\x22 Value=\x22" + g_sEndMeetingReqMeetingID + "\x22 />" + 
    "<Parameter ID=\x22EndTime\x22 Value=\x22" + g_sDateToday + "T" + g_sCurrentTime + ":00" + "\x22 />" + 
    "</Parameters>" + 
    "</RequestAction>";
	
  
  if (Debug_Logic)
  {
     trace ("sXML = %s",sXML);
  }
  
	// Send request out.
	do
	{
		
		if (len(sXML) > 240)
		{
			To_RV_ActionQuery$ = removebylength(240, sXML);
		}
		else
		{
			To_RV_ActionQuery$ = removebylength(len(sXML), sXML);
		}
		
	} until (len(sXML) = 0);
}


Function ShiftEvents(integer iType, string sDirection, integer iStartIndex, integer iEndIndex)
{
	integer i,
					iNew;
	
	if (Debug_Logic)
	{
		trace ("\n** ShiftEvents **\n");
		trace ("  Type:%u\n", iType);
		trace ("  Direction:%s\n", sDirection);
		trace ("  StartIndex:%u\n", iStartIndex);
		trace ("  EndIndex:%u\n", iEndIndex);
	}	
	
	if (sDirection = "Up")
	{
		if (iType = TYPE_WORKDAY)
		{
			// Type is Today
		
			for (i = iStartIndex to iEndIndex)
			{
				MeetingEvent[i].StartBlock = MeetingEvent[i + 1].StartBlock;
				MeetingEvent[i].EndBlock = MeetingEvent[i + 1].EndBlock;
				MeetingEvent[i].StartDate = MeetingEvent[i + 1].StartDate;
				MeetingEvent[i].EndDate = MeetingEvent[i + 1].EndDate;
				MeetingEvent[i].StartTime = MeetingEvent[i + 1].StartTime;
				MeetingEvent[i].EndTime = MeetingEvent[i + 1].EndTime;
				MeetingEvent[i].MeetingID = MeetingEvent[i + 1].MeetingID;
				MeetingEvent[i].RVMeetingID = MeetingEvent[i + 1].RVMeetingID;
				MeetingEvent[i].InstanceID = MeetingEvent[i + 1].InstanceID;
				MeetingEvent[i].Subject = MeetingEvent[i + 1].Subject;
				MeetingEvent[i].IsPrivate = MeetingEvent[i + 1].IsPrivate;
				MeetingEvent[i].IsExchangePrivate = MeetingEvent[i + 1].IsExchangePrivate;
				MeetingEvent[i].Organizer = MeetingEvent[i + 1].Organizer;
				MeetingEvent[i].Recurring = MeetingEvent[i + 1].Recurring;
			}
		}
		else if (iType = TYPE_AUTO_UPDATE)
		{
			// Type is AutoUpdate
			
			for (i = iStartIndex to iEndIndex)
			{
				AutoUpdateMeetingEvent[i].StartBlock = AutoUpdateMeetingEvent[i + 1].StartBlock;
				AutoUpdateMeetingEvent[i].EndBlock = AutoUpdateMeetingEvent[i + 1].EndBlock;
				AutoUpdateMeetingEvent[i].StartDate = AutoUpdateMeetingEvent[i + 1].StartDate;
				AutoUpdateMeetingEvent[i].EndDate = AutoUpdateMeetingEvent[i + 1].EndDate;
				AutoUpdateMeetingEvent[i].StartTime = AutoUpdateMeetingEvent[i + 1].StartTime;
				AutoUpdateMeetingEvent[i].EndTime = AutoUpdateMeetingEvent[i + 1].EndTime;
				AutoUpdateMeetingEvent[i].MeetingID = AutoUpdateMeetingEvent[i + 1].MeetingID;
				AutoUpdateMeetingEvent[i].RVMeetingID = AutoUpdateMeetingEvent[i + 1].RVMeetingID;
				AutoUpdateMeetingEvent[i].InstanceID = AutoUpdateMeetingEvent[i + 1].InstanceID;
				AutoUpdateMeetingEvent[i].Subject = AutoUpdateMeetingEvent[i + 1].Subject;
				AutoUpdateMeetingEvent[i].IsPrivate = AutoUpdateMeetingEvent[i + 1].IsPrivate;
				AutoUpdateMeetingEvent[i].IsExchangePrivate = AutoUpdateMeetingEvent[i + 1].IsExchangePrivate;
				AutoUpdateMeetingEvent[i].Organizer = AutoUpdateMeetingEvent[i + 1].Organizer;
				AutoUpdateMeetingEvent[i].Recurring = AutoUpdateMeetingEvent[i + 1].Recurring;
			}
		}						
	}
	else if (sDirection = "Down")
	{
		if (iType = TYPE_WORKDAY)
		{
			// Type is Today
		
			for (i = iEndIndex to iStartIndex Step -1)
			{				
				MeetingEvent[i + 1].StartBlock = MeetingEvent[i].StartBlock;
				MeetingEvent[i + 1].EndBlock = MeetingEvent[i].EndBlock;
				MeetingEvent[i + 1].StartDate = MeetingEvent[i].StartDate;
				MeetingEvent[i + 1].EndDate = MeetingEvent[i].EndDate;
				MeetingEvent[i + 1].StartTime = MeetingEvent[i].StartTime;
				MeetingEvent[i + 1].EndTime = MeetingEvent[i].EndTime;
				MeetingEvent[i + 1].MeetingID = MeetingEvent[i].MeetingID;
				MeetingEvent[i + 1].RVMeetingID = MeetingEvent[i].RVMeetingID;
				MeetingEvent[i + 1].InstanceID = MeetingEvent[i].InstanceID;
				MeetingEvent[i + 1].Subject = MeetingEvent[i].Subject;
				MeetingEvent[i + 1].IsPrivate = MeetingEvent[i].IsPrivate;
				MeetingEvent[i + 1].IsExchangePrivate = MeetingEvent[i].IsExchangePrivate;
				MeetingEvent[i + 1].Organizer = MeetingEvent[i].Organizer;
				MeetingEvent[i + 1].Recurring = MeetingEvent[i].Recurring; 			
			}
		}
		else if (iType = TYPE_AUTO_UPDATE)
		{
			// Type is AutoUpdate
			
			for (i = iEndIndex to iStartIndex Step -1)
			{
				AutoUpdateMeetingEvent[i + 1].StartBlock = AutoUpdateMeetingEvent[i].StartBlock;
				AutoUpdateMeetingEvent[i + 1].EndBlock = AutoUpdateMeetingEvent[i].EndBlock;
				AutoUpdateMeetingEvent[i + 1].StartDate = AutoUpdateMeetingEvent[i].StartDate;
				AutoUpdateMeetingEvent[i + 1].EndDate = AutoUpdateMeetingEvent[i].EndDate;
				AutoUpdateMeetingEvent[i + 1].StartTime = AutoUpdateMeetingEvent[i].StartTime;
				AutoUpdateMeetingEvent[i + 1].EndTime = AutoUpdateMeetingEvent[i].EndTime;
				AutoUpdateMeetingEvent[i + 1].MeetingID = AutoUpdateMeetingEvent[i].MeetingID;
				AutoUpdateMeetingEvent[i + 1].RVMeetingID = AutoUpdateMeetingEvent[i].RVMeetingID;
				AutoUpdateMeetingEvent[i + 1].InstanceID = AutoUpdateMeetingEvent[i].InstanceID;
				AutoUpdateMeetingEvent[i + 1].Subject = AutoUpdateMeetingEvent[i].Subject;
				AutoUpdateMeetingEvent[i + 1].IsPrivate = AutoUpdateMeetingEvent[i].IsPrivate;
				AutoUpdateMeetingEvent[i + 1].IsExchangePrivate = AutoUpdateMeetingEvent[i].IsExchangePrivate;
				AutoUpdateMeetingEvent[i + 1].Organizer = AutoUpdateMeetingEvent[i].Organizer;
				AutoUpdateMeetingEvent[i + 1].Recurring = AutoUpdateMeetingEvent[i].Recurring;			
			}			
		}
	}
}

Integer_Function EventInsertIndex(integer iDataType, string sStartDate, string sStartTime)
{
	integer i,
					iIndex;
	
	if (Debug_Logic)
	{
		trace ("\n** EventInsertIndex **\n");
		trace ("  DataType:%u\n", iDataType);
		trace ("  StartDate:%s\n", sStartDate);
		trace ("  StartTime:%s\n", sStartTime);
	}
	
	iIndex = 0;
	
	if (iDataType = TYPE_WORKDAY)
	{
		// Type is for Today
	
		// Event starts prior to first event?
		if (DateToInteger(sStartDate) < DateToInteger(MeetingEvent[1].StartDate))
		{
			// Yes, event starts prior to first.
			
			if (Debug_Logic)
			{
				trace ("  Event start date prior to first event start date.\n");
			}
			
			iIndex = 1;
		}
		else
		{
			// Event does not start prior to first.
			
			if (Debug_Logic)
			{
				trace ("  Event does not start prior to first. Check start time.\n");
			}
			
			for (i = 1 to g_iStoredEventCount)
			{
				if (sStartDate = MeetingEvent[i].StartDate)
				{
					if (sStartTime < MeetingEvent[i].StartTime)
					{
						iIndex = i;
					
						break;
					}				
				}
			}
		}
		
		// If event did not start before any others, insert at end
		if (iIndex = 0)
		{
			iIndex = g_iStoredEventCount + 1;
		}
	}
	else if (iDataType = TYPE_AUTO_UPDATE)
	{
		// Type is for AutoUpdate

		// Event starts prior to first event?
		if (DateToInteger(sStartDate) < DateToInteger(AutoUpdateMeetingEvent[1].StartDate))
		{
			// Yes, event starts prior to first.
			
			if (Debug_Logic)
			{
				trace ("  Event start date prior to first event start date.\n");
			}
			
			iIndex = 1;
		}
		else
		{
			// Event does not start prior to first.
			
			if (Debug_Logic)
			{
				trace ("  Event does not start prior to first. Check start time.\n");
			}
			
			for (i = 1 to g_iAutoUpdateStoredEventCount)
			{
				if (sStartTime < AutoUpdateMeetingEvent[i].StartTime)
				{
					iIndex = i;
					
					break;
				}
			}
		}
		
		// If event did not start before any others, insert at end
		if (iIndex = 0)
		{
			iIndex = g_iAutoUpdateStoredEventCount + 1;
		}
	}	
	if (Debug_Logic)
	{
		trace ("  InsertIndex:%u\n", iIndex);
	}
	
	return (iIndex);
}

Integer_Function MoveEvent(integer iType, integer iEventCurrentIndex, string sNewStartDate, string sNewStartTime)
{
	integer iLastIndex,
					iMoveToIndex;
	
	if (Debug_Logic)
	{
		trace ("\n** MoveEvent **\n");
		trace ("  Type:%u\n", iType);
		trace ("  CurrentIndex:%u\n", iEventCurrentIndex);
		trace ("  NewStartDate:%s\n", sNewStartDate);
		trace ("  NewStartTime:%s\n", sNewStartTime);
	}  
  
	// Find out where the event can be moved.
	iMoveToIndex = EventInsertIndex(iType, sNewStartDate, sNewStartTime);
	
	// Move to index != current index?
	if (iMoveToIndex != iEventCurrentIndex)
	{
		// Move to index != current index. Continue on ...
		
		if (Debug_Logic)
		{
			trace ("  Move to index != current index.\n");
		}
		
		// Store current event in temp var
	
		if (iType = TYPE_WORKDAY)
		{
			// Type is Workday
		  
		  iLastIndex = g_iStoredEventCount;
		  
			TempMoveEvent.StartBlock = MeetingEvent[iEventCurrentIndex].StartBlock;
			TempMoveEvent.EndBlock = MeetingEvent[iEventCurrentIndex].EndBlock;
			TempMoveEvent.StartDate = MeetingEvent[iEventCurrentIndex].StartDate;
			TempMoveEvent.EndDate = MeetingEvent[iEventCurrentIndex].EndDate;
			TempMoveEvent.StartTime = MeetingEvent[iEventCurrentIndex].StartTime;
			TempMoveEvent.EndTime = MeetingEvent[iEventCurrentIndex].EndTime;
			TempMoveEvent.MeetingID = MeetingEvent[iEventCurrentIndex].MeetingID;
			TempMoveEvent.RVMeetingID = MeetingEvent[iEventCurrentIndex].RVMeetingID;
			TempMoveEvent.InstanceID = MeetingEvent[iEventCurrentIndex].InstanceID;
			TempMoveEvent.Subject = MeetingEvent[iEventCurrentIndex].Subject;
			TempMoveEvent.IsPrivate = MeetingEvent[iEventCurrentIndex].IsPrivate;
			TempMoveEvent.IsExchangePrivate = MeetingEvent[iEventCurrentIndex].IsExchangePrivate;
			TempMoveEvent.Organizer = MeetingEvent[iEventCurrentIndex].Organizer;
			TempMoveEvent.Recurring = MeetingEvent[iEventCurrentIndex].Recurring; 
		}
		else if (iType = TYPE_AUTO_UPDATE)
		{
			// Type is AutoUpdate
			
			iLastIndex = g_iAutoUpdateStoredEventCount;
			
			TempMoveEvent.StartBlock = AutoUpdateMeetingEvent[iEventCurrentIndex].StartBlock;
			TempMoveEvent.EndBlock = AutoUpdateMeetingEvent[iEventCurrentIndex].EndBlock;
			TempMoveEvent.StartDate = AutoUpdateMeetingEvent[iEventCurrentIndex].StartDate;
			TempMoveEvent.EndDate = AutoUpdateMeetingEvent[iEventCurrentIndex].EndDate;
			TempMoveEvent.StartTime = AutoUpdateMeetingEvent[iEventCurrentIndex].StartTime;
			TempMoveEvent.EndTime = AutoUpdateMeetingEvent[iEventCurrentIndex].EndTime;
			TempMoveEvent.MeetingID = AutoUpdateMeetingEvent[iEventCurrentIndex].MeetingID;
			TempMoveEvent.RVMeetingID = AutoUpdateMeetingEvent[iEventCurrentIndex].RVMeetingID;
			TempMoveEvent.InstanceID = AutoUpdateMeetingEvent[iEventCurrentIndex].InstanceID;
			TempMoveEvent.Subject = AutoUpdateMeetingEvent[iEventCurrentIndex].Subject;
			TempMoveEvent.IsPrivate = AutoUpdateMeetingEvent[iEventCurrentIndex].IsPrivate;
			TempMoveEvent.IsExchangePrivate = AutoUpdateMeetingEvent[iEventCurrentIndex].IsExchangePrivate;
			TempMoveEvent.Organizer = AutoUpdateMeetingEvent[iEventCurrentIndex].Organizer;
			TempMoveEvent.Recurring = AutoUpdateMeetingEvent[iEventCurrentIndex].Recurring;
		}
		
		// Is the move to index > last index?
		if (iMoveToIndex > iLastIndex)
		{
			// Yes, move to index > last index.
			// Shift events up.
			
			if (Debug_Logic)
			{
				trace ("  Move to index > last index. Shift events up.\n");
			}
			
			// Need to adjust move to index.
			iMoveToIndex = iMoveToIndex - 1;
			
			// Actual change?
			if (iMoveToindex != iEventCurrentIndex)
			{
				// Yes, actual change. Shift events up.
	
				if (Debug_Logic)
				{
					trace ("  Adjusted move to index <> current index. Shift events up.\n");
				}
				
				call ShiftEvents(iType, "Up", iEventCurrentIndex, iMoveToIndex - 1);			
			}
			else
			{
				if (Debug_Logic)
				{
					trace ("  Adjusted move to index = current index. Do nothing.\n");
				}
			}
		}
		else if (iMoveToIndex < iEventCurrentIndex)
		{
			// Move to index < current index.
			// Shift events down.
	
			if (Debug_Logic)
			{
				trace ("  Move to index < current index. Shift events down.\n");
			}
			
			call ShiftEvents(iType, "Down", iMoveToIndex, iEventCurrentIndex - 1); 
		}
		else if (iMoveToindex > iEventCurrentIndex)
		{
			// Move to index > current index. Moving event down in the list.
			// Shift events up.
	
			if (Debug_Logic)
			{
				trace ("  Move to index > current index.\n");
			}
					
			// Need to adjust move to index.
			iMoveToIndex = iMoveToIndex - 1;
			
			// Actual change?
			if (iMoveToIndex <> iEventCurrentIndex)
			{
				// Yes, actual change. Shift events up.
	
				if (Debug_Logic)
				{
					trace ("  Adjusted move to index <> current index. Shift events up.\n");
				}
				
				call ShiftEvents(iType, "Up", iEventCurrentIndex, iMoveToIndex - 1);
			}
			else
			{
				if (Debug_Logic)
				{
					trace ("  Adjusted move to index = current index. Do nothing.\n");
				}
			}
		}
		
		// Insert temp data into new spot
		
		if (iType = TYPE_WORKDAY)
		{
			MeetingEvent[iMoveToIndex].StartBlock = TempMoveEvent.StartBlock;
			MeetingEvent[iMoveToIndex].EndBlock = TempMoveEvent.EndBlock;
			MeetingEvent[iMoveToIndex].StartDate = TempMoveEvent.StartDate;
			MeetingEvent[iMoveToIndex].EndDate = TempMoveEvent.EndDate;
			MeetingEvent[iMoveToIndex].StartTime = TempMoveEvent.StartTime;
			MeetingEvent[iMoveToIndex].EndTime = TempMoveEvent.EndTime;
			MeetingEvent[iMoveToIndex].MeetingID = TempMoveEvent.MeetingID;
			MeetingEvent[iMoveToIndex].RVMeetingID = TempMoveEvent.RVMeetingID;
			MeetingEvent[iMoveToIndex].InstanceID = TempMoveEvent.InstanceID;
			MeetingEvent[iMoveToIndex].Subject = TempMoveEvent.Subject;
			MeetingEvent[iMoveToIndex].IsPrivate = TempMoveEvent.IsPrivate;
			MeetingEvent[iMoveToIndex].IsExchangePrivate = TempMoveEvent.IsExchangePrivate;
			MeetingEvent[iMoveToIndex].Organizer = TempMoveEvent.Organizer;
			MeetingEvent[iMoveToIndex].Recurring = TempMoveEvent.Recurring;
		}
		else if (iType = TYPE_AUTO_UPDATE)
		{
			AutoUpdateMeetingEvent[iMoveToIndex].StartBlock = TempMoveEvent.StartBlock;
			AutoUpdateMeetingEvent[iMoveToIndex].EndBlock = TempMoveEvent.EndBlock;
			AutoUpdateMeetingEvent[iMoveToIndex].StartDate = TempMoveEvent.StartDate;
			AutoUpdateMeetingEvent[iMoveToIndex].EndDate = TempMoveEvent.EndDate;
			AutoUpdateMeetingEvent[iMoveToIndex].StartTime = TempMoveEvent.StartTime;
			AutoUpdateMeetingEvent[iMoveToIndex].EndTime = TempMoveEvent.EndTime;
			AutoUpdateMeetingEvent[iMoveToIndex].MeetingID = TempMoveEvent.MeetingID;
			AutoUpdateMeetingEvent[iMoveToIndex].RVMeetingID = TempMoveEvent.RVMeetingID;
			AutoUpdateMeetingEvent[iMoveToIndex].InstanceID = TempMoveEvent.InstanceID;
			AutoUpdateMeetingEvent[iMoveToIndex].Subject = TempMoveEvent.Subject;
			AutoUpdateMeetingEvent[iMoveToIndex].IsPrivate = TempMoveEvent.IsPrivate;
			AutoUpdateMeetingEvent[iMoveToIndex].IsExchangePrivate = TempMoveEvent.IsExchangePrivate;
			AutoUpdateMeetingEvent[iMoveToIndex].Organizer = TempMoveEvent.Organizer;
			AutoUpdateMeetingEvent[iMoveToIndex].Recurring = TempMoveEvent.Recurring;
		}
	}
	else
	{
		if (Debug_Logic)
		{
			trace ("  Move to index = current index. Do nothing.\n");
		}
	}
	
	if (Debug_Logic)
	{
		trace ("  MoveToIndex:%u\n", iMoveToIndex);
	}
	
	return (iMoveToIndex);
}


String_Function CalendarBlock(integer iType, string sStartDate, string sStartTime, string sEndDate, string sEndTime)
{
	integer	i,
					bNeedCalcStartBlock,
					bNeedCalcEndBlock,
					iStartBlock,
					iEndBlock,
					iStartTimeMinutes,
					iEndTimeMinutes,
					iBlockStartTimeMinutes,
					iBlockEndTimeMinutes;
					
	string sDate[10],
				 sReturnData[5];
	
	if (Debug_Logic)
	{
		trace ("\n** CalendarBlock **\n");
		trace ("  Type:%u\n", iType);
		trace ("  StartDate:%s\n", sStartDate);
		trace ("  StartTime:%s\n", sStartTime);
		trace ("  EndDate:%s\n", sEndDate);
		trace ("  EndTime:%s\n", sEndTime);
	}
	
	iStartBlock = 0;
	iEndBlock = 0;
	bNeedCalcStartBlock = FALSE;
	bNeedCalcEndBlock = FALSE;
	
	if (iType = TYPE_WORKDAY)
	{
		sDate = g_sDateToday;
	}
	else
	{
		sDate = g_sAutoUpdateRequestDate;
	}
	
	// Determine if event falls within UI
	if (sDate = sStartDate && sDate = sEndDate)
	{
		// Event starts and ends on the date
		
		if (Debug_Logic)
		{
			trace ("  Event starts and ends on date\n");
		}
		
		bNeedCalcStartBlock = TRUE;
		bNeedCalcEndBlock = TRUE;			
	}
	else if (DateToInteger(sDate) > DateToInteger(sStartDate) && sDate = sEndDate)
	{
		// Event starts prior to the date and ends on the date

		if (Debug_Logic)
		{
			trace ("  Event starts prior to date and ends on date\n");
		}
				
		iStartBlock = 1;
		
		bNeedCalcEndBlock = TRUE;
	}
	else if (sDate = sStartDate && DateToInteger(sDate) < DateToInteger(sEndDate))
	{
		// Event starts on the date, but ends after the date

		if (Debug_Logic)
		{
			trace ("  Event starts on date and ends after date\n");
		}
				
		iEndBlock = 48;
		
		bNeedCalcStartBlock = TRUE;		
	}
	else if (DateToInteger(sDate) > DateToInteger(sStartDate) && DateToInteger(sDate) < DateToInteger(sEndDate))
	{
		// Event starts prior to the date and ends after the date

		if (Debug_Logic)
		{
			trace ("  Event starts prior to date and ends after date\n");
		}
				
		iStartBlock = 1;
		iEndBlock = 48;
	}
	
	// Need to calc start block?
	if (bNeedCalcStartBlock)
	{
		iStartTimeMinutes = TimeToInteger(sStartTime, TIME_FORMAT_MINS);
		
		// Find the block
		for (i = 1 to 48)
		{
			iBlockStartTimeMinutes = (i * 30) - 30;
			iBlockEndTimeMinutes = i * 30;
					
			if (iStartTimeMinutes >= iBlockStartTimeMinutes &&
					 iStartTimeMinutes < iBlockEndTimeMinutes)
			{
				iStartBlock = i;
				break;
			}
		}		
	}

	// Need to calc end block?
	if (bNeedCalcEndBlock)
	{
		iEndTimeMinutes = TimeToInteger(sEndTime, TIME_FORMAT_MINS);
				
		// Find the block
		for (i = 1 to 48)
		{
			iBlockStartTimeMinutes = (i * 30) - 30;
			iBlockEndTimeMinutes = i * 30;
					
			if (iEndTimeMinutes > iBlockStartTimeMinutes &&
					 iEndTimeMinutes <= iBlockEndTimeMinutes)
			{
				iEndBlock = i;
				break;
			}					
		}
	}	

	if (Debug_Logic)
	{
		trace ("  StartBlock:%u\n", iStartBlock);
		trace ("  EndBlock:%u\n", iEndBlock);
	}
	
	sReturnData = itoa(iStartBlock) + "," + itoa(iEndBlock);
	
	return(sReturnData);
}

Integer_Function NewNextEvent(string sStartDate, string sStartTime)
{
	integer bNewNextEvent;
	
	if (Debug_Logic)
	{
		trace ("\n** NewNextEvent **\n");
	}
	
	bNewNextEvent = FALSE;
	
	// Is start date earlier?
	if (DateToInteger(sStartDate) < DateToInteger(NextEvent.StartDate))
	{
		// Start date is earlier than current NextEvent start date.
		
		if (Debug_Logic)
		{
			trace ("  Start date is earlier than current NextEvent.\n");
		}
		
		bNewNextEvent = TRUE;	
	}
	else if (sStartDate = NextEvent.StartDate)
	{
		// Start date = NextEvent start date.
		
		if (Debug_Logic)
		{
			trace ("  Start date = current NextEvent. Check event start time.\n");
		}
		
		// Start time earlier?
		if (TimeToInteger(sStartTime, TIME_FORMAT_HHMM) < TimeToInteger(NextEvent.StartTime, TIME_FORMAT_HHMM))
		{
			// Yes, start time earlier.
			
			if (Debug_Logic)
			{
				trace ("  Start time is earlier than current NextEvent.\n");
			}
			
			bNewNextEvent = TRUE;
		}
	}
	
	if (Debug_Logic)
	{
		trace ("  bNewNextEvent:%u\n", bNewNextEvent);
	}
	
	return (bNewNextEvent);
}

Function ProcessScheduleResponse(integer iResponseType, string sData)
{  
  integer i,
  				iNode,
  				iLen;
  				
  string sRemovedData[2000],
  			 sTemp[1000];
  
  integer iHour,
  				iMinute;
  				
  integer iStoredEventIndex,
  				iAutoUpdateStoredEventIndex;
  
	string sEventMeetingID[MAX_MEETING_ID_LEN],
       	 sEventInstanceID[MAX_INSTANCE_ID_LEN],
       	 sEventRVMeetingID[MAX_RV_MEETING_ID_LEN],
         sEventStartDate[10],
         sEventStartTime[5],
         sEventEndDate[10],
         sEventEndTime[5],
         sEventStartEndBlock[5],
         sEventStartBlock[3],
         sEventEndBlock[3],
         sEventOrganizer[MAX_NAME_LEN],
         sEventSubject[MAX_TEMP_SUBJECT_LEN],
         sEventLiveMeetURL[200];
  
  integer iEventIndex,
  				iAutoUpdateEventIndex,
  				iEventType;
	
	integer bFoundEvent,
					bOKToStore,
					bEventRecurring,
					bEventPrivate,
					bEventExchangePrivate;

  string sPushAction[6];
  
  integer bNeedEventDelete,
  				bNeedEventMove,
  				bStorePushEvent,
  				bHaveNextEvent,
  				bHaveFirstAppt;  

	integer bUpdatedWorkday,
					bNeedUpdateCalendar,
					bNeedSendInfoList,
					bNeedSendUIList,
					bNeedCheckRoomStatus,
					bAllowNextReservRequest,
					bEventPrivateChange,
					bNextEventChange;
  
  string sEventPrevEndDate[18],
  			 sEventPrevEndTime[18];
  
  string sNextDate[10];
  
  integer bEventIsNewNextEvent;
  
  if (Debug_Logic)
  {
  	trace ("\n** ProcessScheduleResponse **\n");
  	trace ("  Type:%u\n", iResponseType);
  	trace ("  DataLen:%u\n", len(sData));
  }
  
	if (iResponseType = REQUEST_TODAY)
	{		
		g_bReserveNowSuccessNeedSched = FALSE;		
	}
	else if (iResponseType = REQUEST_PUSH)
	{
	}
	else if (iResponseType = REQUEST_AUTO_UPDATE)
	{
	}
	else if (iResponseType = REQUEST_NEXT_RESERV)
	{
	}
	else if (iResponseType = REQUEST_FIRST_APPT)
	{
	}
	else if (iResponseType = REQUEST_IS_PRIVATE)
	{
		bEventPrivateChange = FALSE;
	}
  
  //Only process schedule data if no errors returned
  if (!find("<Errors>", sData))
  {		
		iNode = SCHED_NODE_ROOT;
		
		bUpdatedWorkday = FALSE;
		bNextEventChange = FALSE;
		
		bFoundEvent = FALSE;
		
		sEventPrevEndDate = "";
		sEventPrevEndTime = "";
		
		if (iResponseType = REQUEST_TODAY)
		{			
			bUpdatedWorkday = TRUE;
			
			Workday_Sched_Request_Mode = REQUEST_MODE_PROCESSING;
			
			Schedule_Label$ = "Processing new schedule ...";
  		
  		iStoredEventIndex = 0;
  		g_iStoredEventCount = 0;		
		}
		else if (iResponseType = REQUEST_PUSH)
		{
		}
		else if (iResponseType = REQUEST_AUTO_UPDATE)
		{
			Auto_Update_Need_Sched = FALSE;
			
			Auto_Update_Request_Mode = REQUEST_MODE_PROCESSING;
			
			iAutoUpdateStoredEventIndex = 0;
			g_iAutoUpdateStoredEventCount = 0;
			
			g_bHaveAutoUpdateSchedule = TRUE;
		}
		else if (iResponseType = REQUEST_NEXT_RESERV)
		{
			Next_Reserv_Request_Mode = REQUEST_MODE_PROCESSING;
			
			bHaveNextEvent = FALSE;
		}
		else if (iResponseType = REQUEST_FIRST_APPT)
		{
			First_Appt_Request_Mode = REQUEST_MODE_PROCESSING;
			
			bHaveFirstAppt = FALSE;
		}
		else if (iResponseType = REQUEST_IS_PRIVATE)
		{
		}
		
	  do
	  {
	  	sRemovedData = remove(">", sData);
	    
		  //what type of data?
		  if (iNode = SCHED_NODE_ROOT)
		  {
			  // In root node.
			  
			  // Reset all vars at the start of event data
			  if (find("<Event>", sRemovedData))
			  {
			  	bFoundEvent = TRUE;
			  	
			  	bOKToStore = FALSE;
			  	
			  	sEventStartDate = "";
			  	sEventEndDate = "";
			  	sEventStartTime = "";
			  	sEventEndTime = "";
			  	sEventStartEndBlock = "";
			  	
			  	sEventMeetingID = "";
			  	sEventRVMeetingID = "";
			  	sEventInstanceID = "";
			  	
			  	sEventOrganizer = "";
			  	sEventSubject = "";
			  	
			  	sEventLiveMeetURL = "";
			  	
			  	bEventRecurring = FALSE;
			  	
			  	sPushAction = "";
			  	
			  	bEventPrivate = FALSE;
			  	bEventExchangePrivate = FALSE;
			  	bNextEventChange = FALSE;
			  	
			  	bNeedEventDelete = FALSE;
			  	
			  	bEventIsNewNextEvent = FALSE;
			  }
			  else if (find("</Event>", sRemovedData))
			  {
			    // End event tag found
			    
			    if (Debug_Logic)
			    {
			    	trace ("  End Event tag found.\n");
			    	trace ("   Event StartDate:%s\n", sEventStartDate);
			    	trace ("   Event StartTime:%s\n", sEventStartTime);
			    	trace ("   Event EndDate:%s\n", sEventEndDate);
			    	trace ("   Event EndTime:%s\n", sEventEndTime);
			    }			    
			    
			    if (iResponseType = REQUEST_TODAY)
			    {
			    	if (Debug_Logic)
			    	{
			    		trace ("  Event is part of Today response\n");
			    	}
			    	
			    	if (iStoredEventIndex < MAX_STORED_EVENTS)
			    	{			    		
			    		// Start and End Block
		        	sEventStartEndBlock = CalendarBlock(TYPE_WORKDAY, sEventStartDate, sEventStartTime, sEventEndDate, sEventEndTime);

		        	sEventStartBlock = remove(",", sEventStartEndBlock);
		        	sEventStartBlock = left(sEventStartBlock, len(sEventStartBlock) - 1);
		        	sEventEndBlock = sEventStartEndBlock;
		        					    		
			    		// Make sure EventStartEndBlock <> 0
			    		if (sEventStartBlock <> "0" && sEventEndBlock <> "0")
			    		{
			    			// Make sure event does not overlap previous event
			    			
			    			// Have prev end date?
			    			if (len(sEventPrevEndDate) = 0)
			    			{
			    				// Do not have previous end date. Probably first event.

			    				if (Debug_Logic)
			    				{
			    					trace ("  Do not have previous end date. OK to store.\n");  
			    				}
			    							    				
			    				bOKToStore = TRUE;
			    			}
			    			else if (sEventPrevEndDate = g_sDateToday)
			    			{
			    				// Previous end date = today. See if new event overlaps previous.
			    				
			    				if (Debug_Logic)
			    				{
			    					trace ("  Have previous end date. Need to check for overlap.\n");  
			    				}
			    				
									if (sEventStartTime > sEventPrevEndTime)
									{
										// New event start time > previous start time.

			    					if (Debug_Logic)
			    					{
			    						trace ("  New event start time > previous start time. OK to store.\n");  
			    					}
										
										bOKToStore = TRUE;
									}
									else if (sEventStartTime = sEventPrevEndTime)
									{
										// New event start time = previous end time.
										
			    					if (Debug_Logic)
			    					{
			    						trace ("  New event start time = previous start time. OK to store.\n");  
			    					}
										
										bOKToStore = TRUE;
									}
									else
									{
			    					if (Debug_Logic)
			    					{
			    						trace ("  Not OK to store.\n");  
			    					}
									}			    							    				
			    			}		
			    			
			    			
			    			if (bOKToStore)
			    			{
			    				// Event OK to store.
			    				
			    				sEventPrevEndDate = sEventEndDate;
			    				sEventPrevEndTime = sEventEndTime;
			    			
			    				iStoredEventIndex = iStoredEventIndex + 1;
			    		
			    				if (Debug_Logic)
		         				trace ("    Storing New Event:%u\n", iStoredEventIndex);
			      		
			      			MeetingEvent[iStoredEventIndex].StartDate = sEventStartDate;
		        			MeetingEvent[iStoredEventIndex].EndDate = sEventEndDate;
			      			MeetingEvent[iStoredEventIndex].StartTime = sEventStartTime;
			      			MeetingEvent[iStoredEventIndex].EndTime = sEventEndTime;
		        			MeetingEvent[iStoredEventIndex].MeetingID = sEventMeetingID;
		        			MeetingEvent[iStoredEventIndex].RVMeetingID = sEventRVMeetingID;
		        			MeetingEvent[iStoredEventIndex].InstanceID = sEventInstanceID;
		        			MeetingEvent[iStoredEventIndex].Organizer = sEventOrganizer;
		        			MeetingEvent[iStoredEventIndex].Subject = sEventSubject;
		        			MeetingEvent[iStoredEventIndex].IsPrivate = bEventPrivate;
		        			MeetingEvent[iStoredEventIndex].IsExchangePrivate = bEventExchangePrivate;
		        			MeetingEvent[iStoredEventIndex].Recurring = bEventRecurring;
		        
		        			MeetingEvent[iStoredEventIndex].StartBlock = atoi(sEventStartBlock);
		        			MeetingEvent[iStoredEventIndex].EndBlock = atoi(sEventEndBlock);
		        		}			    		
			    		}
			    		else
			    		{
			    			// 0 was returned with StartEndBlock.
			    			
			    			if (Debug_Logic)
			    			{
			    				trace ("  0 was returned with StartEnd block. Do not store event.\n");
			    			}
			    		}
			    	}			    
			    }
			    else if (iResponseType = REQUEST_AUTO_UPDATE)
			    {
			    	if (Debug_Logic)
			    	{
			    		trace ("  Event is part of Auto Update response\n");
			    	}
			    	
			    	if (iAutoUpdateStoredEventIndex < MAX_STORED_EVENTS)
			    	{
			    		// Start and End Block
		        	sEventStartEndBlock = CalendarBlock(TYPE_AUTO_UPDATE, sEventStartDate, sEventStartTime, sEventEndDate, sEventEndTime);

		        	sEventStartBlock = remove(",", sEventStartEndBlock);
		        	sEventStartBlock = left(sEventStartBlock, len(sEventStartBlock) - 1);
		        	sEventEndBlock = sEventStartEndBlock;
		        					    		
			    		// Make sure EventStartEndBlock <> 0
			    		if (sEventStartBlock <> "0" && sEventEndBlock <> "0")
			    		{ 
			    			iAutoUpdateStoredEventIndex = iAutoUpdateStoredEventIndex + 1;
			    		
			    			if (Debug_Logic)
		         			trace ("    Storing New AutoUpdate Event:%u\n", iAutoUpdateStoredEventIndex);
			      		
			      		AutoUpdateMeetingEvent[iAutoUpdateStoredEventIndex].StartDate = sEventStartDate;
		        		AutoUpdateMeetingEvent[iAutoUpdateStoredEventIndex].EndDate = sEventEndDate;
			      		AutoUpdateMeetingEvent[iAutoUpdateStoredEventIndex].StartTime = sEventStartTime;
			      		AutoUpdateMeetingEvent[iAutoUpdateStoredEventIndex].EndTime = sEventEndTime;
		        		AutoUpdateMeetingEvent[iAutoUpdateStoredEventIndex].MeetingID = sEventMeetingID;
		        		AutoUpdateMeetingEvent[iAutoUpdateStoredEventIndex].RVMeetingID = sEventRVMeetingID;
		        		AutoUpdateMeetingEvent[iAutoUpdateStoredEventIndex].InstanceID = sEventInstanceID;
		        		AutoUpdateMeetingEvent[iAutoUpdateStoredEventIndex].Organizer = sEventOrganizer;
		        		AutoUpdateMeetingEvent[iAutoUpdateStoredEventIndex].Subject = sEventSubject;
		        		AutoUpdateMeetingEvent[iAutoUpdateStoredEventIndex].IsPrivate = bEventPrivate;
		        		AutoUpdateMeetingEvent[iAutoUpdateStoredEventIndex].IsExchangePrivate = bEventExchangePrivate;
		        		AutoUpdateMeetingEvent[iAutoUpdateStoredEventIndex].Recurring = bEventRecurring;
		        
		        		AutoUpdateMeetingEvent[iAutoUpdateStoredEventIndex].StartBlock = atoi(sEventStartBlock);
		        		AutoUpdateMeetingEvent[iAutoUpdateStoredEventIndex].EndBlock = atoi(sEventEndBlock);
			    		}
			    	}			    
			    }
			    else if (iResponseType = REQUEST_NEXT_RESERV)
			    {
			    	if (Debug_Logic)
			    	{
			    		trace ("  Event is part of Next Reserv response\n");
			    	}
			    	
			    	// Have the next event yet?
			    	if (!bHaveNextEvent)
			    	{
			    		// Do not have next event. Now we have it.
			    		bHaveNextEvent = TRUE;

			    		// Store the data
			    		NextEvent.MeetingID = sEventMeetingID;
			    		NextEvent.InstanceID = sEventInstanceID;
			    		NextEvent.StartDate = sEventStartDate;
			    		NextEvent.StartTime = sEventStartTime;
			    		NextEvent.EndDate = sEventEndDate;
			    		NextEvent.EndTime = sEventEndTime;
			    		NextEvent.Organizer = sEventOrganizer;
			    		NextEvent.Subject = sEventSubject;
			    		NextEvent.IsPrivate = bEventPrivate;
			    		NextEvent.IsExchangePrivate = bEventExchangePrivate;
			    		
			    		SendFreeBusyAttributeData(sEventStartDate, sEventStartTime);			    		
			    	}			    	
			    }
			    else if (iResponseType = REQUEST_FIRST_APPT)
			    {
			    	// Response is First Appointment.
			    	
			    	if (Debug_Logic)
			    	{
			    		trace ("  Event is part of First Appt response\n");
			    	}
			    	
			    	bHaveFirstAppt = TRUE;
			    				    	
			    	// Store the data
			    	NextEvent.MeetingID = sEventMeetingID;
			    	NextEvent.InstanceID = sEventInstanceID;
			    	NextEvent.StartDate = sEventStartDate;
			    	NextEvent.StartTime = sEventStartTime;
			    	NextEvent.EndDate = sEventEndDate;
			    	NextEvent.EndTime = sEventEndTime;
			    	NextEvent.Organizer = sEventOrganizer;
			    	NextEvent.Subject = sEventSubject;
			    	NextEvent.IsPrivate = bEventPrivate;
			    	NextEvent.IsExchangePrivate = bEventExchangePrivate;
			    	
			    	SendFreeBusyAttributeData(sEventStartDate, sEventStartTime);			    				    
			    }
			    else if (iResponseType = REQUEST_IS_PRIVATE)
			    {
			    	// Response is IsPrivate.
			    	
			    	if (Debug_Logic)
			    	{
			    		trace ("  Event is IsPrivate response.\n");
			    	}
			    	
			    	// ** See if the event exists in the workday data
			    	iStoredEventIndex = EventIndex(TYPE_WORKDAY, TYPE_MEETING_ID, sEventMeetingID);
			    	
			    	if (iStoredEventIndex > 0)
			    	{
			    		// Did the flag change?
			    		if (bEventPrivate <> MeetingEvent[iStoredEventIndex].IsPrivate)
			    		{
			    			bEventPrivateChange = TRUE;
			    		}
			    		
			    		// Store the IsPrivate data.
			    		MeetingEvent[iStoredEventIndex].IsPrivate = bEventPrivate;
			    	}
			    	
			    	// ** If AutoUpdateProcess active, need to check auto update data too
			    	if (Auto_Update_Process_Active)
			    	{			    		
			    		iAutoUpdateStoredEventIndex = EventIndex(TYPE_AUTO_UPDATE, TYPE_MEETING_ID, sEventMeetingID);
			    		
			    		if (iAutoUpdateStoredEventIndex > 0)
			    		{
			    			// Store the IsPrivate data.
			    			AutoUpdateMeetingEvent[iAutoUpdateStoredEventIndex].IsPrivate = bEventPrivate;
			    		}
			    	}
			    	
			    	
			    }
			    else if (iResponseType = REQUEST_PUSH)
			    {
			    	if (Debug_Logic)
			    	{
			    		trace ("  Event is part of Push response\n");
			    		trace ("   Action:%s\n", sPushAction);
			    	}
            
            Processed_Push_Responses = Processed_Push_Responses + 1;
			    	Last_Processed_Push_Response_DateTime$ = date(1) + " " + time();
			    	
			    	// Are we waiting for the ReserveNow meeting to come down?
			    	if (g_bReserveNowSuccessNeedSched)
			    	{
			    		// Yes, we are waiting for the ReserveNow meeting.
			    		
			    		if (Debug_Logic)
			    		{
			    			trace ("  Waiting for ReserveNow meeting to come down.\n");
			    		}
			    		
			    		// Is this the meeting?
			    		if (sEventMeetingID = g_sReserveNowMeetingID)
			    		{
			    			// Yes, this is the meeting. Clear vars.
			    			 
			    			if (Debug_Logic)
			    			{
			    				trace ("  This is the ReserveNow meeting.\n");
			    			}
			    			
			    			g_bReserveNowSuccessNeedSched = FALSE;
			    			g_sReserveNowMeetingID = "";
			    		}
			    	}			    	
			    	
			    	// Is AutoUpdate active?			    	
			    	if (Auto_Update_Process_Active)
			    	{
			    		// Yes, auto update active. Need to check second structure.
			    		
			    		if (Debug_Logic)
			    		{
			    			trace ("  AutoUpdate active. Processing event.\n");
			    		}
			    		
			    		bNeedEventDelete = FALSE;
			    		bNeedEventMove = FALSE;
			    		bStorePushEvent = FALSE;
			    		iAutoUpdateEventIndex = 0;
			    		iAutoUpdateStoredEventIndex = 0;
			    		
			    		// See if we have this meeting using MeetingID
			    		if (len(sEventMeetingID) > 0)
			    		{
			    			if (Debug_Logic)
			    			{
			    				trace ("  Using MeetingID.\n");
			    			}
			    			
			    			iAutoUpdateEventIndex = EventIndex(TYPE_AUTO_UPDATE, TYPE_MEETING_ID, sEventMeetingID);
			    		}
			    		
			    		// If we did not find the meeting using MeetingID, try InstanceID
			    		if (iAutoUpdateEventIndex = 0 && len(sEventInstanceID) > 0)
			    		{
			    			if (Debug_Logic)
			    			{
			    				trace ("  Using InstanceID.\n");
			    			}
			    			
			    			iAutoUpdateEventIndex = EventIndex(TYPE_AUTO_UPDATE, TYPE_INSTANCE_ID, sEventInstanceID);			    			
			    		}
			    		
			    		
			    		// Event already stored?
			    		if (iAutoUpdateEventIndex > 0)
			    		{
			    			// Yes, event already stored.
			    			
				    		// Event already stored in today structure.
				    		
				    		if (Debug_Logic)
				    		{
				    			trace ("  AutoUpdate Event already stored\n");
				    		}
				    		
				    		// Remove?
				    		if (sPushAction = "Remove")
				    		{
				    			// Yes, remove event.
				    			
				    			if (Debug_Logic)
				    			{
				    				trace ("  AutoUpdate Removing event\n");
				    			}
				    			
				    			// Deleting event = shifting the list up and removing one from the stored qty.			    				
				    				
				    			// Need to shift list?
				    			if (iAutoUpdateEventIndex < g_iAutoUpdateStoredEventCount)
				    			{
				    				call ShiftEvents(TYPE_AUTO_UPDATE, "Up", iAutoUpdateEventIndex, g_iAutoUpdateStoredEventCount);
				    					
				    				g_iAutoUpdateStoredEventCount = g_iAutoUpdateStoredEventCount - 1;
				    			}
				    			else
				    			{
				    				// Event was last on list. No need to shift.
				    				g_iAutoUpdateStoredEventCount = g_iAutoUpdateStoredEventCount - 1;
				    			}
				    		}
				    		else
				    		{
				    		  // Action not remove. Look at start/end date.
				    		  
				    		  if (Debug_Logic)
				    		  {
				    		  	trace ("  AutoUpdate Action not remove. Check event date/time\n");
				    		  }
				    		  
				    		  // Date changed?
				    		  if (sEventStartDate <> AutoUpdateMeetingEvent[iAutoUpdateEventIndex].StartDate ||
				    		   sEventEndDate <> AutoUpdateMeetingEvent[iAutoUpdateEventIndex].EndDate)
				    		  {
				    		  	// Date has changed.
				    		  	
				    		  	if (Debug_Logic)
				    		  	{
				    		  		trace ("  AutoUpdate Date has changed\n.");
				    		  	}
				    		  		
					    			// New date within event start/end?
					    			if (g_sAutoUpdateDate = sEventStartDate && g_sAutoUpdateDate = sEventEndDate)
					    			{
					    				// Event starts and ends today.
					    			}	
					    			else if (DateToInteger(g_sAutoUpdateDate) > DateToInteger(sEventStartDate) && g_sAutoUpdateDate = sEventEndDate)
					    			{
					    				// Event starts prior, but ends today.
					    			}
					    			else if (g_sAutoUpdateDate = sEventStartDate && DateToInteger(g_sAutoUpdateDate) < DateToInteger(sEventEndDate))
					    			{
					    				// Event starts today, but ends after.
					    			}
					    			else if (DateToInteger(g_sAutoUpdateDate) > DateToInteger(sEventStartDate) && DateToInteger(g_sAutoUpdateDate) < DateToInteger(sEventEndDate))
					    			{
					    				// Event starts prior and ends after.
					    			}
					    			else
					    			{
					    				// Event now falls outside of today. Delete event.
					    				
					    				bNeedEventDelete = TRUE;				    				
					    			}
				    		  }
				    		  
				    		  // Need to check time?
				    		  if (!bNeedEventDelete)
				    		  {
				    		  	// Yes, need to check time..
				    		  	
				    		  	if (Debug_Logic)
				    		  	{
				    		  		trace ("  AutoUpdate Need to check time.\n");
				    		  	}
				    		  	
				    		  	// Time change?
				    		  	if (sEventStartTime <> AutoUpdateMeetingEvent[iAutoUpdateEventIndex].StartTime ||
				    		   		sEventEndTime <> AutoUpdateMeetingEvent[iAutoUpdateEventIndex].EndTime)
				    		  	{	
				    		  		// Yes, time has changed.
				    		  		
				    		  		if (Debug_Logic)
				    		  		{
				    		  			trace ("  AutoUpdate Time has changed.\n");
				    		  		}
				    		  		
				    		  		bNeedEventMove = TRUE;			    		  					    		  	
				    		  	}
				    		  	else
				    		  	{
				    		  		// Time has not changed (neither has date). Just store the new data in the original index.
				    		  		
				    		  		if (Debug_Logic)
				    		  		{
				    		  			trace ("  AutoUpdate Time has not changed. Just update event.\n");
				    		  		}
				    		  	}
				    		  }
				    		  
				    		  // What needs to be done?
				    		  
				    		  if (Debug_Logic)
				    		  {
				    		  	trace ("  AutoUpdate NeedEventDelete:%u\n", bNeedEventDelete);
				    		  	trace ("  AutoUpdate NeedEventMove:%u\n", bNeedEventMove);
				    		  }
				    		  
				    		  // Need delete?
				    		  if (bNeedEventDelete)
				    		  {
				    				// Deleting event = shifting the list up and removing one from the stored qty.			    				
				    				
				    				// Need to shift list?
				    				if (iAutoUpdateEventIndex < g_iAutoUpdateStoredEventCount)
				    				{
				    					call ShiftEvents(TYPE_AUTO_UPDATE, "Up", iAutoUpdateEventIndex, g_iAutoUpdateStoredEventCount);
				    					
				    					g_iAutoUpdateStoredEventCount = g_iAutoUpdateStoredEventCount - 1;
				    				}
				    				else
				    				{
				    					// Event was last on list. No need to shift.
				    					g_iAutoUpdateStoredEventCount = g_iAutoUpdateStoredEventCount - 1;
				    				}			    		  	
				    		  }
				    		  else if (bNeedEventMove)
				    		  {
					    			// Need event move.
					    			
					    			// More than one event stored?
					    			if (g_iAutoUpdateStoredEventCount > 1)
					    			{
					    				// Yes, more than one event stored. Need to move event index.
					    			  
					    			  if (Debug_Logic)
					    			  {
					    			  	trace ("  AutoUpdate More than one event stored. Moving event.\n");
					    			  }
					    			
					    				// Move the event from it's current index.
					    				iAutoUpdateEventIndex = MoveEvent(TYPE_AUTO_UPDATE, iAutoUpdateEventIndex, sEventStartDate, sEventStartTime);	
					    			}
					    			else
					    			{
					    				if (Debug_Logic)
					    				{
					    					trace ("  AutoUpdate Only one event stored. No need to move event index.\n");
					    				}
					    			} 			    		  	
				    		  }
				    		  
				    		 	// Store the updated data in auto update structure.
			         		
			         		// Start and End Block
			        		sEventStartEndBlock = CalendarBlock(TYPE_AUTO_UPDATE, sEventStartDate, sEventStartTime, sEventEndDate, sEventEndTime);

				        	sEventStartBlock = remove(",", sEventStartEndBlock);
				        	sEventStartBlock = left(sEventStartBlock, len(sEventStartBlock) - 1);
				        	sEventEndBlock = sEventStartEndBlock;
				        					         		
			         		// Make sure StartEndBlock <> 0
			         		if (sEventStartBlock <> "0" && sEventEndBlock <> "0")
			         		{
			         			trace ("    Updating AutoUpdate Event Data:%u\n", iAutoUpdateEventIndex);
			         
				      			AutoUpdateMeetingEvent[iAutoUpdateEventIndex].StartDate = sEventStartDate;
			        			AutoUpdateMeetingEvent[iAutoUpdateEventIndex].EndDate = sEventEndDate;
				      			AutoUpdateMeetingEvent[iAutoUpdateEventIndex].StartTime = sEventStartTime;
				      			AutoUpdateMeetingEvent[iAutoUpdateEventIndex].EndTime = sEventEndTime;			        		
				        		AutoUpdateMeetingEvent[iAutoUpdateEventIndex].Organizer = sEventOrganizer;
				        		AutoUpdateMeetingEvent[iAutoUpdateEventIndex].Subject = sEventSubject;
				        		AutoUpdateMeetingEvent[iAutoUpdateEventIndex].IsPrivate = bEventPrivate;
				        		AutoUpdateMeetingEvent[iAutoUpdateEventIndex].IsExchangePrivate = bEventExchangePrivate;
				        		AutoUpdateMeetingEvent[iAutoUpdateEventIndex].Recurring = bEventRecurring;
				        
				        		AutoUpdateMeetingEvent[iAutoUpdateEventIndex].StartBlock = atoi(sEventStartBlock);
				        		AutoUpdateMeetingEvent[iAutoUpdateEventIndex].EndBlock = atoi(sEventEndBlock);
				        	}
				    		   
				    		} // End Action not Remove
			    		}
			    		else
			    		{
			    			// Event is not stored.

				    		if (Debug_Logic)
				    		{
				    			trace ("  AutoUpdate Event not stored.\n");
				    		}
				    					    			
				    		// Action != Remove?
				    		if (sPushAction != "Remove")
				    		{
				    		  // Action not remove. Look at start/end date.
				    		  
				    		  if (Debug_Logic)
				    		  {
				    		  	trace ("  AutoUpdate Action not remove. Look at start/end dates.\n");
				    		  }
				    		  
				    		  
					    		// Current date within event start/end?
					    		if (g_sAutoUpdateDate = sEventStartDate && g_sAutoUpdateDate = sEventEndDate)
					    		{
					    			// Event starts and ends today. Store new event.
										bStorePushEvent = TRUE;
					    		}
					    		else if (g_sAutoUpdateDate > sEventStartDate && g_sAutoUpdateDate = sEventEndDate)
					    		{
					    			// Event starts prior, but ends today. Store new event.
										bStorePushEvent = TRUE;
					    		}
					    		else if (g_sAutoUpdateDate = sEventStartDate && DateToInteger(g_sAutoUpdateDate) < DateToInteger(sEventEndDate))
					    		{
					    			// Event starts today, but ends after. Store new event.
										bStorePushEvent = TRUE;
					    		}
					    		else if (g_sAutoUpdateDate > sEventStartDate && DateToInteger(g_sAutoUpdateDate) < DateToInteger(sEventEndDate))
					    		{
					    			// Event starts prior and ends after. Store new event.
	                  bStorePushEvent = TRUE;
					    		}
					    		
					    		if (bStorePushEvent)
					    		{
					    			if (Debug_Logic)
					    			{
					    				trace ("  AutoUpdate Current date falls within event start/end. Adding event.\n");
					    			}
					    			
					    			// Find out where event can be inserted.
					    			
					    			// Anthing stored?
					    			if (g_iAutoUpdateStoredEventCount = 0)
					    			{
					    				// Nothing stored. Store event in first index slot.
					    				
					    				g_iAutoUpdateStoredEventCount = g_iAutoUpdateStoredEventCount + 1;
					    				iAutoUpdateStoredEventIndex = g_iAutoUpdateStoredEventCount;
					    			}
					    			else
					    			{
					    				// Events stored.
					    								    				
					    				// Get insert index.
					    				iAutoUpdateStoredEventIndex = EventInsertIndex(TYPE_AUTO_UPDATE, sEventStartDate, sEventStartTime);    				
					    								    				 
					    				// Insert index within list?
					    				if (iAutoUpdateStoredEventIndex <= g_iAutoUpdateStoredEventCount)
					    				{
					    					// Yes, insert is within list. Need to shift the list down.
					    					
					    					call ShiftEvents(TYPE_AUTO_UPDATE, "Down", iAutoUpdateStoredEventIndex, g_iAutoUpdateStoredEventCount);
					    				}
					    				
					    				// Add to global count.
					    				g_iAutoUpdateStoredEventCount = g_iAutoUpdateStoredEventCount + 1;				    				
					    			}				    			
					    		}
					    		else
					    		{
					    			if (Debug_Logic)
					    			{
					    				trace ("  AutoUpdate Current date does NOT fall within event start/end. Do nothing.\n");
					    			}				    		
					    		}
					    	}
					    	
					    	// Can event be stored?
		      			if (iAutoUpdateStoredEventIndex > 0)
		      			{
			      			// Yes, event can be stored.
			      		  
			      		  // Start and End Block
		        			sEventStartEndBlock = CalendarBlock(TYPE_AUTO_UPDATE, sEventStartDate, sEventStartTime, sEventEndDate, sEventEndTime);

			        		sEventStartBlock = remove(",", sEventStartEndBlock);
			        		sEventStartBlock = left(sEventStartBlock, len(sEventStartBlock) - 1);
			        		sEventEndBlock = sEventStartEndBlock;
			        						      		  
			      		  // Make sure StartEndBlock <> 0
			      		  if (sEventStartBlock <> "0" && sEventEndBlock <> "0")
			      		  {			      		  
				      			if (Debug_Logic)
			         				trace ("    AutoUpdate Storing New AutoUpdate Event:%u\n", iAutoUpdateStoredEventIndex);
				      		
				      			AutoUpdateMeetingEvent[iAutoUpdateStoredEventIndex].StartDate = sEventStartDate;
			        			AutoUpdateMeetingEvent[iAutoUpdateStoredEventIndex].EndDate = sEventEndDate;
				      			AutoUpdateMeetingEvent[iAutoUpdateStoredEventIndex].StartTime = sEventStartTime;
				      			AutoUpdateMeetingEvent[iAutoUpdateStoredEventIndex].EndTime = sEventEndTime;
			        			AutoUpdateMeetingEvent[iAutoUpdateStoredEventIndex].MeetingID = sEventMeetingID;
			        			AutoUpdateMeetingEvent[iAutoUpdateStoredEventIndex].RVMeetingID = sEventRVMeetingID;
			        			AutoUpdateMeetingEvent[iAutoUpdateStoredEventIndex].InstanceID = sEventInstanceID;
			        			AutoUpdateMeetingEvent[iAutoUpdateStoredEventIndex].Organizer = sEventOrganizer;
			        			AutoUpdateMeetingEvent[iAutoUpdateStoredEventIndex].Subject = sEventSubject;
			        			AutoUpdateMeetingEvent[iAutoUpdateStoredEventIndex].IsPrivate = bEventPrivate;
			        			AutoUpdateMeetingEvent[iAutoUpdateStoredEventIndex].IsExchangePrivate = bEventExchangePrivate;
			        			AutoUpdateMeetingEvent[iAutoUpdateStoredEventIndex].Recurring = bEventRecurring;
			        
			        			AutoUpdateMeetingEvent[iAutoUpdateStoredEventIndex].StartBlock = atoi(sEventStartBlock);
			        			AutoUpdateMeetingEvent[iAutoUpdateStoredEventIndex].EndBlock = atoi(sEventEndBlock);
			        		}
		        		
		        		}
					    	
			    		} // End event is not stored
			    			
			    	} // End if AutoUpdate active
			    	
			    	// Reset vars before looking at regular event data
			    	bNeedEventDelete = FALSE;
			    	bNeedEventMove = FALSE;
			    	bStorePushEvent = FALSE;
			    	iEventIndex = 0;
			    	iStoredEventIndex = 0;

			    	// See if we have this meeting using MeetingID
			    	if (len(sEventMeetingID) > 0)
			    	{
			    		if (Debug_Logic)
			    		{
			    			trace ("  Using MeetingID.\n");
			    		}
			    			
			    		iEventIndex = EventIndex(TYPE_WORKDAY, TYPE_MEETING_ID, sEventMeetingID);
			    	}
			    		
			    	// If we did not find the meeting using MeetingID, try InstanceID
			    	if (iEventIndex = 0 && len(sEventInstanceID) > 0)
			    	{
			    		if (Debug_Logic)
			    		{
			    			trace ("  Using InstanceID.\n");
			    		}
			    			
			    		iEventIndex = EventIndex(TYPE_WORKDAY, TYPE_INSTANCE_ID, sEventInstanceID);			    			
			    	}
			    	
			    	// Event NextEvent ID?
			    	if (len(NextEvent.MeetingID) > 0 && sEventMeetingID = NextEvent.MeetingID ||
			    	 len(NextEvent.InstanceID) > 0 && sEventInstanceID = NextEvent.InstanceID)
			    	{
			    		// Event is stored NextEvent.
			    			
			    		if (Debug_Logic)
			    		{
			    			trace ("  Event is stored NextMeeting.\n");
			    		}
			    		
			    		bNextEventChange = TRUE;
			    		
			    		// Remove?
			    		if (sPushAction = "Remove")
			    		{
			    			// Yes, action is remove.

				    		if (Debug_Logic)
				    		{
				    			trace ("  Action is remove. Clearing NextMeeting\n");
				    		}
				    						    			
				    		NextEvent.MeetingID = "";
				    		NextEvent.InstanceID = "";
				    		NextEvent.StartDate = "";
				    		NextEvent.StartTime = "";
				    		NextEvent.EndDate = "";
				    		NextEvent.EndTime = "";
			    			NextEvent.Organizer = "";
			    			NextEvent.Subject = "";
			    			NextEvent.IsPrivate = FALSE;
			    			NextEvent.IsExchangePrivate = FALSE;
			    							    				
				    		g_bNeedFirstApptRequest = TRUE;				    					    			
			    		}
			    		else
			    		{
              	// Action not remove.

				    		if (Debug_Logic)
				    		{
				    			trace ("  Action not remove.\n");
				    		}
				    						    				
				    		// Anything changed?
				    		if (sEventStartDate <> NextEvent.StartDate || sEventStartTime <> NextEvent.StartTime)
				    		{
				    			// Yes, event has changed. Clear the data and force another FirstAppt request.
				    				
				    			if (Debug_Logic)
				    			{
				    				trace ("  Event Date/Time has changed. Clear the NextEvent data.\n");
				    				trace ("   EventStartDate: %s\n", sEventStartDate);
				    				trace ("   NextEvent.StartDate: %s\n", NextEvent.StartDate);
				    				trace ("   EventStartTime: %s\n", sEventStartTime);
				    				trace ("   NextEvent.StartTime: %s\n", NextEvent.StartTime);
				    			}
				    				
				    			NextEvent.MeetingID = "";
				    			NextEvent.InstanceID = "";
				    			NextEvent.StartDate = "";
				    			NextEvent.StartTime = "";
				    			NextEvent.EndDate = "";
				    			NextEvent.EndTime = "";
			    				NextEvent.Organizer = "";
			    				NextEvent.Subject = "";
			    				NextEvent.IsPrivate = FALSE;
			    				NextEvent.IsExchangePrivate = FALSE;
			    						    				
				    			g_bNeedFirstApptRequest = TRUE;		
				    		}
				    		else
				    		{
				    			if (Debug_Logic)
				    			{
				    				trace ("  Event Date/Time has not changed.\n");
				    			}
				    		}
				    	}

			    	} // End if event NextEvent
			    	else
			    	{
			    		if (Debug_Logic)
			    		{
			    			trace ("  Event is not stored NextMeeting.\n");
			    			trace ("   Current:\n");
			    			trace ("    NextEvent.MeetingID:%s\n", NextEvent.MeetingID);
			    			trace ("    NextEvent.InstanceID:%s\n", NextEvent.InstanceID);
			    			trace ("    NextEvent.StartDate:%s\n", NextEvent.StartDate);
			    			trace ("    NextEvent.StartTime:%s\n", NextEvent.StartTime);			    			
			    		}
			    	}
			    	  
			    	// Event already stored?
			    	if (iEventIndex > 0)
			    	{
			    		// Yes, event already stored.
			    			
				    	// Event already stored in today structure.
				    		
				    	if (Debug_Logic)
				    	{
				    		trace ("  Event already stored\n");
				    	}
				    		
				    	// Remove?
				    	if (sPushAction = "Remove")
				    	{
				    		// Yes, remove event.
				    			
				    		if (Debug_Logic)
				    		{
				    			trace ("  Removing event\n");
				    		}
				    			
				    		bUpdatedWorkday = TRUE;
				    			
				    		// Deleting event = shifting the list up and removing one from the stored qty.			    				
				    				
				    		// Need to shift list?
				    		if (iEventIndex < g_iStoredEventCount)
				    		{
				    			call ShiftEvents(TYPE_WORKDAY, "Up", iEventIndex, g_iStoredEventCount);
				    					
				    			g_iStoredEventCount = g_iStoredEventCount - 1;
				    		}
				    		else
				    		{
				    			// Event was last on list. No need to shift.
				    			g_iStoredEventCount = g_iStoredEventCount - 1;
				    		}
				    	}
				    	else
				    	{
				    		 // Action not remove. Look at start/end date.
				    		  
				    		 if (Debug_Logic)
				    		 {
				    		  trace ("  Action not remove. Check event date/time\n");
				    		 }
				    		  
				    		 // Date changed?
				    		 if (sEventStartDate <> MeetingEvent[iEventIndex].StartDate ||
				    		  sEventEndDate <> MeetingEvent[iEventIndex].EndDate)
				    		 {
				    		  // Date has changed.
				    		  	
				    		  if (Debug_Logic)
				    		  {
				    		  	trace ("  Date has changed\n.");
				    		  }
				    		  	
				    		  bUpdatedWorkday = TRUE;
				    		  	
				    		  			
					    		// New date within event start/end?
					    		if (g_sDateToday = sEventStartDate && g_sDateToday = sEventEndDate)
					    		{
					    			// Event starts and ends today.
					    		}	
					    		else if (DateToInteger(g_sDateToday) > DateToInteger(sEventStartDate) && g_sDateToday = sEventEndDate)
					    		{
					    			// Event starts prior, but ends today.
					    		}
					    		else if (g_sDateToday = sEventStartDate && DateToInteger(g_sDateToday) < DateToInteger(sEventEndDate))
					    		{
					    			// Event starts today, but ends after.
					    		}
					    		else if (DateToInteger(g_sDateToday) > DateToInteger(sEventStartDate) && DateToInteger(g_sDateToday) < DateToInteger(sEventEndDate))
					    		{
					    			// Event starts prior and ends after.
					    		}
					    		else
					    		{
					    			// Event now falls outside of today. Delete event.
					    				
					    			bNeedEventDelete = TRUE;				    				
					    		}
				    		}
				    		  
				    		// Need to check time?
				    		if (!bNeedEventDelete)
				    		{
				    		  // Yes, need to check time..
				    		  	
				    		  if (Debug_Logic)
				    		  {
				    		  	trace ("  Need to check time.\n");
				    		  }
				    		  	
				    		  // Time change?
				    		  if (sEventStartTime <> MeetingEvent[iEventIndex].StartTime ||
				    		   sEventEndTime <> MeetingEvent[iEventIndex].EndTime)
				    		  {	
				    		  	// Yes, time has changed.
				    		  		
				    		  	if (Debug_Logic)
				    		  	{
				    		  		trace ("  Time has changed.\n");
				    		  	}
				    		  		
				    		  	bNeedEventMove = TRUE;			    		  					    		  	
				    		  }
				    		  else
				    		  {
				    		  	// Time has not changed (neither has date). Just store the new data in the original index.
				    		  		
				    		  	if (Debug_Logic)
				    		  	{
				    		  		trace ("  Time has not changed. Just update event.\n");
				    		  	}
				    		  }
				    		}
				    		  
				    		// What needs to be done?
				    		  
				    		if (Debug_Logic)
				    		{
				    		  trace ("  NeedEventDelete:%u\n", bNeedEventDelete);
				    		  trace ("  NeedEventMove:%u\n", bNeedEventMove);
				    		}
				    		  
				    		// Need delete?
				    		if (bNeedEventDelete)
				    		{
				    			// Deleting event = shifting the list up and removing one from the stored qty.			    				
				    				
				    			bUpdatedWorkday = TRUE;
				    				
				    			// Need to shift list?
				    			if (iEventIndex < g_iStoredEventCount)
				    			{
				    				call ShiftEvents(TYPE_WORKDAY, "Up", iEventIndex, g_iStoredEventCount);
				    					
				    				g_iStoredEventCount = g_iStoredEventCount - 1;
				    			}
				    			else
				    			{
				    				// Event was last on list. No need to shift.
				    				g_iStoredEventCount = g_iStoredEventCount - 1;
				    			}			    		  	
				    		}
				    		else if (bNeedEventMove)
				    		{
					    		// Need event move.
					    			
					    		bUpdatedWorkday = TRUE;
					    			
					    		// More than one event stored?
					    		if (g_iStoredEventCount > 1)
					    		{
					    			// Yes, more than one event stored. Need to move event index.
					    			  
					    			if (Debug_Logic)
					    			{
					    			  trace ("  More than one event stored. Moving event.\n");
					    			}
					    			
					    			// Move the event from it's current index.
					    			iEventIndex = MoveEvent(TYPE_WORKDAY, iEventIndex, sEventStartDate, sEventStartTime);	
					    		}
					    		else
					    		{
					    			if (Debug_Logic)
					    			{
					    				trace ("  Only one event stored. No need to move event index.\n");
					    			}
					    		} 			    		  	
				    		}
				    		  
				    		// Store the updated data in auto update structure.

			        	// Start and End Block
			        	sEventStartEndBlock = CalendarBlock(TYPE_WORKDAY, sEventStartDate, sEventStartTime, sEventEndDate, sEventEndTime);

				        sEventStartBlock = remove(",", sEventStartEndBlock);
				        sEventStartBlock = left(sEventStartBlock, len(sEventStartBlock) - 1);
				        sEventEndBlock = sEventStartEndBlock;
				        					        		
			        	// Make sure StartEndBlock <> 0
			        	if (sEventStartBlock <> "0" && sEventEndBlock <> "0")
			        	{
			        		if (Debug_Logic)
			        		{			        					         		
			         			trace ("    Updating Event Data:%u\n", iEventIndex);
			            }
			              
			            bUpdatedWorkday = TRUE;
			              
				      		MeetingEvent[iEventIndex].StartDate = sEventStartDate;
			        		MeetingEvent[iEventIndex].EndDate = sEventEndDate;
				      		MeetingEvent[iEventIndex].StartTime = sEventStartTime;
				      		MeetingEvent[iEventIndex].EndTime = sEventEndTime;			        		
				        	MeetingEvent[iEventIndex].Organizer = sEventOrganizer;
				        	MeetingEvent[iEventIndex].Subject = sEventSubject;
				        	MeetingEvent[iEventIndex].IsPrivate = bEventPrivate;
				        	MeetingEvent[iEventIndex].IsExchangePrivate = bEventExchangePrivate;
				        	MeetingEvent[iEventIndex].Recurring = bEventRecurring;			    		  
				        
				        	MeetingEvent[iEventIndex].StartBlock = atoi(sEventStartBlock);
				        	MeetingEvent[iEventIndex].EndBlock = atoi(sEventEndBlock);
				        }
				    		   
				    	} // End Action not Remove
			    	}
			    	else
			    	{
			    		// Event is not stored.

				    	if (Debug_Logic)
				    	{
				    		trace ("  Event not stored\n");
				    	}
				    					    			
				    	// Action != Remove?
				    	if (sPushAction != "Remove")
				    	{
				    		// Action not remove. Look at start/end date.

				    		if (Debug_Logic)
				    		{
				    			trace ("  Action not remove.\n");
				    		}
				    		  					    							    		  
					    	// Current date within event start/end?
					    	if (g_sDateToday = sEventStartDate && g_sDateToday = sEventEndDate)
					    	{
					    		// Event starts and ends today. Store new event.
					    			
									bStorePushEvent = TRUE;
					    	}
					    	else if (DateToInteger(g_sDateToday) > DateToInteger(sEventStartDate) && g_sDateToday = sEventEndDate)
					    	{
					    		// Event starts prior, but ends today. Store new event.
					    			
									bStorePushEvent = TRUE;
					    	}
					    	else if (g_sDateToday = sEventStartDate && DateToInteger(g_sDateToday) < DateToInteger(sEventEndDate))
					    	{
					    		// Event starts today, but ends after. Store new event.
					    			
									bStorePushEvent = TRUE;
					    	}
					    	else if (DateToInteger(g_sDateToday) > DateToInteger(sEventStartDate) && DateToInteger(g_sDateToday) < DateToInteger(sEventEndDate))
					    	{
					    		// Event starts prior and ends after. Store new event.
					    			
	                 bStorePushEvent = TRUE;
					    	}
					    		
					    	if (bStorePushEvent)
					    	{
					    		if (Debug_Logic)
					    		{
					    			trace ("  Current date falls within event start/end. Adding event.\n");
					    		}
					    			
					    		// Find out where event can be inserted.
					    			
					    		// Anthing stored?
					    		if (g_iStoredEventCount = 0)
					    		{
					    			// Nothing stored. Store event in first index slot.
					    				
					    			g_iStoredEventCount = g_iStoredEventCount + 1;
					    			iStoredEventIndex = g_iStoredEventCount;
					    		}
					    		else
					    		{
					    			// Events stored.
					    								    				
					    			// Get insert index.
					    			iStoredEventIndex = EventInsertIndex(TYPE_WORKDAY, sEventStartDate, sEventStartTime);    				
					    								    				 
					    			// Insert index within list?
					    			if (iStoredEventIndex <= g_iStoredEventCount)
					    			{
					    				// Yes, insert is within list. Need to shift the list down.
					    					
					    				call ShiftEvents(TYPE_WORKDAY, "Down", iStoredEventIndex, g_iStoredEventCount);
					    			}
					    				
					    			// Add to global count.
					    			g_iStoredEventCount = g_iStoredEventCount + 1;				    				
					    		}				    			
					    	}
					    	else
					    	{
					    		if (Debug_Logic)
					    		{
					    			trace ("  Current date does NOT fall within event start/end.\n");
					    			trace ("  Need to see if this event is new next event.\n");
					    		}
					    		
					    		// *** Need to see if this event could be new next event *** //
					    		
					    		// Have next event?
					    		if (len(NextEvent.MeetingID) > 0)
					    		{
					    			// Yes, have next event.
					    		
					    			if (Debug_Logic)
					    			{
					    				trace ("  Have next event.\n");
					    			}
					    			
					    			// Does the next event start after today?
					    			if (DateToInteger(NextEvent.StartDate) > DateToInteger(g_sDateToday))
					    			{
					    				// Yes, next event start after today.
					    				
					    				if (Debug_Logic)
					    				{
					    					trace ("  Next event starts after today.\n");
					    				}
					    				
					    				// New event start date before next event?
					    				if (DateToInteger(sEventStartDate) < DateToInteger(NextEvent.StartDate))
					    				{
					    					// Yes, new event start date before next event.
					    					
					    					if (Debug_Logic)
					    					{
					    						trace ("  New event start date before next event. Event is new next event.\n");
					    					}
					 
					    					bEventIsNewNextEvent = TRUE;				    										    					
					    				}
					    				else if (sEventStartDate = NextEvent.StartDate)
					    				{
					    					// New event starts on same date.
					    					
					    					if (Debug_Logic)
					    					{
					    						trace ("  New event start date = next event.\n");
					    					}
					    					
					    					// New event start time before next event?
					    					if (sEventStartTime < NextEvent.StartTime)
					    					{
					    						// Yes, new event start time before next event.
					    						
					    						if (Debug_Logic)
					    						{
					    							trace ("  New event start time before next event. New event is new next event.\n");
					    						}
					    						
					    						bEventIsNewNextEvent = TRUE;					    						
					    					}
					    				}
					    				else
					    				{
					    					if (Debug_Logic)
					    					{
					    						trace ("  New event does not start before or on same date as next event.\n");
					    						trace ("  Nothing to do.\n");
					    					}					    					
					    				}
					    			}
					    			else
					    			{
					    				// Next event does not start after today.

					    				if (Debug_Logic)
					    				{
					    					trace ("  Next event does not start after today. Nothing to do.\n");
					    				}					    				
					    			}
					    			
					    		} // end if (len(NextEvent.MeetingID) > 0)
					    		
					    		else
					    		{
					    			// Do not have next event.
					    			
					    			if (Debug_Logic)
					    			{
					    				trace ("  Do not have next event.\n");
					    			}
					    			
					    			// Does the new event start after today?
					    			if (sEventStartDate > g_sDateToday)
					    			{
					    				// Yes, new event starts after today.
					    				
					    				if (Debug_Logic)
					    				{
					    					trace ("  New event starts after today. New event is new next event.\n");
					    				}
					    				
					    				bEventIsNewNextEvent = TRUE;
					    			}
					    			else
					    			{
					    				// New event does not start after today. Nothing to do.
					    				
					    				if (Debug_Logic)
					    				{
					    					trace ("  New event does not start after today. Nothing to do.\n");
					    				}
					    			}
					    							    			
					    		} // end else - if (len(NextEvent.MeetingID) > 0)
					    		
					    		// New event is new next event?
					    		if (bEventIsNewNextEvent)
					    		{
					    			// Yes, new event is new next event.

					    			if (Debug_Logic)
					    			{
					    				trace ("  Storing new event as next next event.\n");
					    			}
					    			
					    			bNextEventChange = TRUE;
					    									    			
					    			NextEvent.MeetingID = sEventMeetingID;
					    			NextEvent.InstanceID = sEventInstanceID;
					    			NextEvent.StartDate = sEventStartDate; 
					    			NextEvent.StartTime = sEventStartTime;
					    			NextEvent.EndDate = sEventEndDate;
					    			NextEvent.EndTIme = sEventEndTime;
					    			NextEvent.Subject = sEventSubject;
					    			NextEvent.Organizer = sEventOrganizer;
					    			NextEvent.IsPrivate = bEventPrivate;
					    			NextEvent.IsExchangePrivate = bEventExchangePrivate;					    			
					    		}
					    						    		
					    	} // end else - if (bStorePushEvent)
					    	
					    }
					    	
					    // Can event be stored?
		      		if (iStoredEventIndex > 0)
		      		{
			      		// Yes, event can be stored.
                  
                bUpdatedWorkday = TRUE;
                  
		        		// Start and End Block
		        		sEventStartEndBlock = CalendarBlock(TYPE_WORKDAY, sEventStartDate, sEventStartTime, sEventEndDate, sEventEndTime);

			        	sEventStartBlock = remove(",", sEventStartEndBlock);
			        	sEventStartBlock = left(sEventStartBlock, len(sEventStartBlock) - 1);
			        	sEventEndBlock = sEventStartEndBlock;
			        					        			
		        		// Make sure StartEndBlock <> 0
		        		if (sEventStartBlock <> "0" && sEventEndBlock <> "0")
		        		{			      		
			      			if (Debug_Logic)
		         			 trace ("    Storing New Event:%u\n", iStoredEventIndex);
			      		
				      		MeetingEvent[iStoredEventIndex].StartDate = sEventStartDate;
			        		MeetingEvent[iStoredEventIndex].EndDate = sEventEndDate;
				      		MeetingEvent[iStoredEventIndex].StartTime = sEventStartTime;
				      		MeetingEvent[iStoredEventIndex].EndTime = sEventEndTime;
			        		MeetingEvent[iStoredEventIndex].MeetingID = sEventMeetingID;
			        		MeetingEvent[iStoredEventIndex].RVMeetingID = sEventRVMeetingID;
			        		MeetingEvent[iStoredEventIndex].InstanceID = sEventInstanceID;
			        		MeetingEvent[iStoredEventIndex].Organizer = sEventOrganizer;
			        		MeetingEvent[iStoredEventIndex].Subject = sEventSubject;
			        		MeetingEvent[iStoredEventIndex].IsPrivate = bEventPrivate;
			        		MeetingEvent[iStoredEventIndex].IsExchangePrivate = bEventExchangePrivate;
			        		MeetingEvent[iStoredEventIndex].Recurring = bEventRecurring;
			        
			        		MeetingEvent[iStoredEventIndex].StartBlock = atoi(sEventStartBlock);
			        		MeetingEvent[iStoredEventIndex].EndBlock = atoi(sEventEndBlock);
			        	}
		        	}
					    	
			    	} // End event is not stored
			    			    	
			    } // End If Event Push

			  }
			  else if (find("<Action ID=", sRemovedData))
			  {
			  	if (find("New", sRemovedData))
			  	{
			  		sPushAction = "New";
			  	}
			  	else if (find("Change", sRemovedData))
			  	{
			  		sPushAction = "Change";
			  	}
			  	else if (find("Remove", sRemovedData))
			  	{
			  		sPushAction = "Remove";
			  	}
			  }
		    else if (find("</MeetingID>", sRemovedData))
		    {
		      sEventMeetingID = left(sRemovedData, len(sRemovedData) - 12);
		    }
		    else if (find("</RVMeetingID>", sRemovedData))
		    {
		      sEventRVMeetingID = left(sRemovedData, len(sRemovedData) - 14);
		    }
		    else if (find("</Recurring>", sRemovedData))
		    {
		      if (find("True", sRemovedData))
		       bEventRecurring = TRUE;
		      else
		       bEventRecurring = FALSE;
		    }
		    else if (find("</InstanceID>", sRemovedData))
		    {
		      sEventInstanceID = left(sRemovedData, len(sRemovedData) - 13);
		    }   
			  else if (find("</dtStart>", sRemovedData))
			  {	      
		      //remove the date
			    sEventStartDate = left(sRemovedData, 10);
		      
			    //remove the time
		      sEventStartTime = mid(sRemovedData, 12, 5);    
			  }
			  else if (find("</dtEnd>", sRemovedData))
			  {
		      //remove the date
			    sEventEndDate = left(sRemovedData, 10);
		      
			    //remove the time
		      sEventEndTime = mid(sRemovedData, 12, 5);
			  }
			  else if (find("</Organizer>", sRemovedData))
			  {
			    sEventOrganizer = left(sRemovedData, len(sRemovedData) - 12);
		      
		      if (sEventOrganizer = "Unknown Name" && len(Default_Organizer$) > 0)
		      {
		      	sEventOrganizer = Default_Organizer$;
		    	}
		    	else if (sEventOrganizer = Room_Name$)
		    	{
		    		sEventOrganizer = Default_Organizer$;
		    	}  
			  
			  }
			  else if (find("</IsPrivate>", sRemovedData))
			  {
		      if (find("1", sRemovedData))
		       bEventPrivate = TRUE;
			  }
			  else if (find("</IsExchangePrivate>", sRemovedData))
			  {
		      if (find("1", sRemovedData))
		       bEventExchangePrivate = TRUE;
			  }
			  else if (find("<LiveMeeting>", sRemovedData))
		    {
			    iNode = SCHED_NODE_LIVE_MEETING;
		    }
		    else if (find("<Subject>", sRemovedData))
		    {
		      iNode = SCHED_NODE_MEETING_SUBJECT;
		    }
		    else if (find("</ScheduleResponse>", sRemovedData))
		    {
		    	// Have processed entire response
		    	
			    if (iResponseType = REQUEST_NEXT_RESERV)
			    {
			    	// Response is Next Reservation 
			    	 
			    	// Any events found?
			    	if (!bFoundEvent)
			    	{
			    		if (Debug_Logic)
			    		{
			    			trace ("  End of next reservation response. No events. Clear NextEvent.\n");
			    		}
			    		
			    		// Clear the data
			    		NextEvent.MeetingID = "";
			    		NextEvent.InstanceID = "";
			    		NextEvent.StartDate = "";
			    		NextEvent.StartTime = "";
			    		NextEvent.EndDate = "";
			    		NextEvent.EndTime = "";
			    		NextEvent.Organizer = "";
			    		NextEvent.Subject = "";
			    		NextEvent.IsPrivate = FALSE;
			    		NextEvent.IsExchangePrivate = FALSE;			    		
			    	}
			    
			    }
			    else if (iResponseType = REQUEST_FIRST_APPT)
			    {
			    	// Response is First Appointment.
			    	
			    	// Any events found?
			    	if (!bFoundEvent)
			    	{			    	
			    		if (Debug_Logic)
			    		{
			    			trace ("  End of first appointment response. No events. Clear NextEvent.\n");
			    		}
			    		
			    		// Clear the data
			    		NextEvent.MeetingID = "";
			    		NextEvent.InstanceID = "";
			    		NextEvent.StartDate = "";
			    		NextEvent.StartTime = "";
			    		NextEvent.EndDate = "";
			    		NextEvent.EndTime = "";
			    		NextEvent.Organizer = "";
			    		NextEvent.Subject = "";
			    		NextEvent.IsPrivate = FALSE;
			    		NextEvent.IsExchangePrivate = FALSE;
			    	}
			    }
		    }
		  }
		  else if (iNode = SCHED_NODE_LIVE_MEETING) //LiveMeeting data
		  {
		    if (find("</LiveMeeting>", sRemovedData)) //end of LiveMeeting data
		    {
		      iNode = SCHED_NODE_ROOT;
		    }
		    else if (find("</URL>", sRemovedData))
		    {
			    sEventLiveMeetURL = left(sRemovedData, len(sRemovedData) - 6); 
		    }
		  }
		  else if (iNode = SCHED_NODE_MEETING_SUBJECT) //Subject data
		  {
		    if (find("</Subject>", sRemovedData))
		    {
		      //found the end of the subject, so process all data 
		      
			    sEventSubject = sEventSubject + left(sRemovedData, len(sRemovedData) - 10); 
		      
		      if (len(sEventSubject) > 230)
		       sEventSubject = left(sEventSubject, 230);
		      
		      iNode = SCHED_NODE_ROOT;
		    }
		    else
		    { 
			    //did not find the end tag, so just keep adding data
			    sEventSubject = sEventSubject + sRemovedData;
		    }
		  }
	
	  } until (len(sData) = 0);
	  
	  // Post process items.
	  
		bNeedUpdateCalendar = FALSE;
	 	bNeedSendInfoList = FALSE;
	 	bNeedSendUIList = FALSE;
	  bNeedCheckRoomStatus = FALSE;
	  bAllowNextReservRequest = FALSE;
	  
	  if (iResponseType = REQUEST_TODAY)
	  {
	  	Workday_Sched_Request_Mode = REQUEST_MODE_IDLE;
	  	
	  	Have_Valid_Workday_Sched = TRUE;
	          
	  	Schedule_Label$ = FormatDate(g_sDateToday, 1);
	          
	  	Last_Received_Schedule_Time_Date$ = date(1) + " " + time();
	    
	    g_iStoredEventCount = iStoredEventIndex;
	    
			bNeedUpdateCalendar = TRUE;
	 		bNeedSendInfoList = TRUE;
	 		bNeedSendUIList = TRUE;
	  	bNeedCheckRoomStatus = TRUE;
	  	
	  	// Not in PUSH mode?
	  	if (!g_bPushEnabled)
	  	{
	  		// Not in PUSH mode, so need NextReserv request
	  		
	  		bAllowNextReservRequest = TRUE;
	  	}
	  }
	  else if (iResponseType = REQUEST_AUTO_UPDATE)
	  {
	  	Auto_Update_Request_Mode = REQUEST_MODE_IDLE;
	  	
	  	g_iAutoUpdateStoredEventCount = iAutoUpdateStoredEventIndex;	  	
	  }
	  else if (iResponseType = REQUEST_PUSH)
	  {
			if (bUpdatedWorkday)
			{
				if (Debug_Logic)
				{
					trace ("  Updated Workday. Run post process.\n");
				}
				
				bNeedUpdateCalendar = TRUE;
	 			bNeedSendInfoList = TRUE;
	 			bNeedSendUIList = TRUE;
	  		bNeedCheckRoomStatus = TRUE;
	  		bAllowNextReservRequest = TRUE;
	  	}
	  	else
	  	{
				if (Debug_Logic)
				{
					trace ("  Workday NOT updated.\n");
				}
				
				if (bNextEventChange)
				{
					if (Debug_Logic)
					{
						trace ("  However, next event was changed.\n");
					}
					
					bNeedCheckRoomStatus = TRUE;
					bAllowNextReservRequest = TRUE;
				}	  	
	  	}
	  }
	  else if (iResponseType = REQUEST_NEXT_RESERV)
	  {
	  	Next_Reserv_Request_Mode = REQUEST_MODE_IDLE;
	  	
	  	bNeedCheckRoomStatus = TRUE;
	  	bAllowNextReservRequest = FALSE;	
	  }
	  else if (iResponseType = REQUEST_FIRST_APPT)
	  {
	  	First_Appt_Request_Mode = REQUEST_MODE_IDLE;
	  	
	  	bNeedCheckRoomStatus = TRUE;
	  	bAllowNextReservRequest = FALSE;
	  }
	  else if (iResponseType = REQUEST_IS_PRIVATE)
	  {
	  	// Only send event list out if privacy flag has changed
	  	if (bEventPrivateChange)
	  	{
	  		bNeedUpdateCalendar = TRUE;
	  		bNeedSendInfoList = TRUE;
	  		bNeedSendUIList = TRUE;
	  	}
	  }
	  
	  // Which post process functions to run?
	  
	  if (Debug_Logic)
	  {
	  	trace ("  Post Processes to Run:\n");
	  	trace ("   bNeedUpdateCalendar:%u\n", bNeedUpdateCalendar);
	  	trace ("   bNeedSendInfoList:%u\n", bNeedSendInfoList);
	  	trace ("   bNeedSendUIList:%u\n", bNeedSendUIList);
	  	trace ("   bNeedCheckRoomStatus:%u\n", bNeedCheckRoomStatus);
	  	trace ("   bAllowNextReservRequest:%u\n", bAllowNextReservRequest);
	  }
	  
	  
	  if (bNeedUpdateCalendar)
	  {
	  	// Update the calendar.
	 		call UpdateCalendar();
	 		
	 		// Remote system module connected?
	 		if (g_bHaveRemoteSysModule)
	 		 call SendRemoteSystemData(REM_SYS_DATA_WORKDAY, "");
	 	}

	 	if (bNeedSendUIList)
	 	{
	 		// Send the event list out.  
	  	call SendUIEventList();
	 	}
	 		 	
	 	if (bNeedSendInfoList)
	 	{
	 		// Send the event list out.
	 		// 12-29-09 Removed with new Preset Module interface.
	 		//if (g_bHaveMeetingInfoModule)  
	  	 //call SendInfoEventList();
	 	}
	 	
	 	if (bNeedCheckRoomStatus)
	 	{
	  	// Check the room status.
	  	call CheckRoomStatus(bAllowNextReservRequest);
	  	
	  	if (iResponseType = REQUEST_PUSH)
	  	{	  		
	  		Push_Triggered_Check_Room_Status = TRUE;
	  		Push_Triggered_Check_Room_Status = FALSE;
	  	}
	  }
	  
	}
	else
	{
		//Response contained errors
     
     
		if (iResponseType = REQUEST_TODAY)
		{
			GenerateUserNotice("Function:ProcessScheduleResponse||Response = REQUEST_TODAY||Response contained errors");
			
			Workday_Sched_Request_Mode = REQUEST_MODE_FAILURE;
			Workday_Sched_Request_Mode = REQUEST_MODE_IDLE;		
		}
		else if (iResponseType = REQUEST_PUSH)
		{
			GenerateUserNotice("Function:ProcessScheduleResponse||Response = REQUEST_PUSH||Response contained errors");
		}
		else if (iResponseType = REQUEST_AUTO_UPDATE)
		{
			// Since schedule request returned an error, the 
			// system now needs to try a few more times
			// and after enough tries, clear PUSH mode.
			
			GenerateUserNotice("Function:ProcessScheduleResponse||Response = REQUEST_AUTO_UPDATE||Response contained errors");
			
			Auto_Update_Request_Mode = REQUEST_MODE_FAILURE;
			Auto_Update_Request_Mode = REQUEST_MODE_IDLE; 
		}
		else if (iResponseType = REQUEST_NEXT_RESERV)
		{
			GenerateUserNotice("Function:ProcessScheduleResponse||Response = REQUEST_NEXT_RESERV||Response contained errors");
			
			Next_Reserv_Request_Mode = REQUEST_MODE_FAILURE;
			Next_Reserv_Request_Mode = REQUEST_MODE_IDLE;
		}
		else if (iResponseType = REQUEST_FIRST_APPT)
		{
			// GenerateUserNotice("Function:ProcessScheduleResponse||Response = REQUEST_FIRST_APPT||Response contained errors");
			
			First_Appt_Request_Mode = REQUEST_MODE_FAILURE;
			First_Appt_Request_Mode = REQUEST_MODE_IDLE;
			
			// This error is actually returned when there are no appts. in the calendar.
			
			// Store the data
			NextEvent.MeetingID = "";
			NextEvent.StartDate = "";
			NextEvent.StartTime = "";
			NextEvent.EndDate = "";
			NextEvent.EndTime = "";
			NextEvent.Organizer = "";
			NextEvent.Subject = "";
			NextEvent.IsPrivate = FALSE;
			NextEvent.IsExchangePrivate = FALSE;
			    					
			sNextDate =  NextDayDate(g_sDateToday, "3");
			    		
			SendFreeBusyAttributeData(sNextDate, "00:00:00");
		}
	}
	
	call SetDateTimeVars();
	
	// Did another force schedule request come in while
	// we were waiting for a schedule response?
	if (g_bNeedAnotherWorkdayRequest)
	{
		g_bNeedAnotherWorkdayRequest = FALSE;
		
		call GetSchedule(REQUEST_TODAY, g_sDateToday, "00:00:00", "24");		
	}
}

Function ProcessCreateResponse(integer iType, string sData)
{
	string sRemoved[255],
				 sMeetingID[MAX_MEETING_ID_LEN];
				 
	integer bSuccess;
	
  if (Debug_Logic)
  {
  	trace ("\n** ProcessCreateResponse **\n");
  	trace ("  Type:%u\n", iType);
  }
  
  if (iType = CREATE_TYPE_RESERVE_NOW)
  {
  	Reserve_Now_Request_Mode = REQUEST_MODE_PROCESSING;
  }
  else if(iType = CREATE_TYPE_USER)
  {
  }  
  
  bSuccess = FALSE;
  sMeetingID = "";
  
  do
  {
  	sRemoved = remove(">", sData);
  	
		if (find("</MeetingID>", sRemoved))
		{
      //Check MeetingID.
      
      sMeetingID = left(sRemoved, len(sRemoved) - 12);
      
      if (len(sMeetingID) > 0)
      {
      	bSuccess = TRUE;       
			}
		}  	
  	
  } until (len(sData) = 0);
  
  if (bSuccess)
  {
  	if (iType = CREATE_TYPE_RESERVE_NOW)
  	{      
      Reserve_Now_Message$ = "";
      
      g_sReserveNowMeetingID = sMeetingID;
      
      Enable_Reserve_Now = FALSE;
      g_bReserveNowSuccessNeedSched = TRUE;      
      
      Reserve_Now_Request_Mode = REQUEST_MODE_SUCCESS;  	
  	}
  	
  	
  	//Request new schedule after success if not push registered
  	if (!g_bPushEnabled)
  	{
  		call GetSchedule(REQUEST_TODAY, g_sDateToday, "00:00:00", "24");
  	}
  }
  else
  {
  	if (iType = CREATE_TYPE_RESERVE_NOW)
  	{      
      Reserve_Now_Message$ = "Request rejected by server.";
      
      g_sReserveNowMeetingID = "";

      g_bReserveNowSuccessNeedSched = FALSE;
			      
      Reserve_Now_Request_Mode = REQUEST_MODE_FAILURE;  	
  	}  	
  }
  
  if (iType = CREATE_TYPE_RESERVE_NOW)
  {
  	Reserve_Now_Request_Mode = REQUEST_MODE_IDLE;
  }
  else if(iType = CREATE_TYPE_USER)
  {
  }
}

Function ProcessActionResponse(string sData)
{
	integer iType,
					iIndex,
          iMeetingStatus;
	
	string sXML[300],
				 sRemoved[300],
				 sTrash[50];
				 
	string sActionRequestID[45],
				 sMeetingID[MAX_MEETING_ID_LEN],
				 sRVMeetingID[MAX_RV_MEETING_ID_LEN],
         sNewEndTime[MAX_RV_DATE_FORMAT_LEN];
	
  if (Debug_Logic)
   trace ("\n** ProcessActionResponse **\n");

  
  iType = 0;
  iIndex = 0;
  sMeetingID = "";
  sRVMeetingID = "";
  iMeetingStatus = 0;
  sNewEndTime = "";
    
  do
  {
  	sRemoved = remove(">", sData);  	
  	
		if (iType = ACTION_NODE_ROOT)
		{
			// In root node of XML. Look for switch node.
			
			if (find("</RequestID>", sRemoved))
			{
				// Found RequestID.
				sActionRequestID = left(sRemoved, len(sRemoved) - 12);
			}
			else if (find("RequestRVID</ActionID>", sRemoved))
			{
				// Found RequestRVID node
				
				if (Debug_Logic)
				 trace ("    Found RequestRVID\n");
				
				iType = ACTION_NODE_MEETING_ID;
			}
			else if (find("RegisterPushModel</ActionID>", sRemoved))
			{
				if (Debug_Logic)
				 trace ("  Found RegisterPushModel\n");
				
				Register_Push_Request_Mode = REQUEST_MODE_PROCESSING;
				
				iType = ACTION_NODE_PUSH_REGISTER;
			}
			else if (find("MeetingChange</ActionID>", sRemoved))
			{
				if (Debug_Logic)
				 trace ("  Found MeetingChange\n");
				 
				iType = ACTION_NODE_MEETING_CHANGE;
			}
			else if (find("Subscription</ActionID>", sRemoved))
			{
				if (Debug_Logic)
				 trace ("  Found Subscription\n");
				 
				iType = ACTION_NODE_SUBSCRIPTION;
			}
			else if (find("Backlog</ActionID>", sRemoved))
			{
				if (Debug_Logic)
				 trace ("  Found Backlog\n");
				 
				iType = ACTION_NODE_BACKLOG;
			}	
		}
		else
		{
			// Not in the root. Switch and process that nodes data
			
			cswitch(iType)
			{
				// RequestRVID
				case(ACTION_NODE_MEETING_ID):
				{
					if (find("</ActionResponse>", sRemoved))
					{
						// End of node
						iType = ACTION_NODE_ROOT;
						
					}
					else
					{
						// Process data within node
						
						if (find("<Parameter ID=\x22MeetingID\x22", sRemoved))
						{
				      // MeetingID returned
				      
				      // Remove trash first
				      sTrash = remove("Value=\x22", sRemoved);
				      
				      // Get the meeting id
				      sMeetingID = left(sRemoved, len(sRemoved) - 4);

				      if (Debug_Logic)
				       trace ("    MeetingID:%s\n", sMeetingID);
				       				      
				      // If MeetingID has length, find the index.
				      if (len(sMeetingID) > 0)
				      {
				      	iIndex = EventIndex(TYPE_WORKDAY, TYPE_MEETING_ID, sMeetingID);
				      }         
						}
						else if (find("<Parameter ID=\x22RVMeetingID\x22", sRemoved))
						{
							// RVMeetingID returned
							
							// Remove the trash first
							sTrash = remove("Value=\x22", sRemoved);
							
							// Get the RVMeetingID
							sRVMeetingID = left(sRemoved, len(sRemoved) - 4);
							
							if (Debug_Logic)
							 trace ("    RVMeetingID:%s\n", sRVMeetingID);
							
							// If we have the index, go ahead and assign the RVMeetingID
							if (iIndex > 0)
							 MeetingEvent[iIndex].RVMeetingID = sRVMeetingID; 
						}						
					}
					
					break;
				}
				
				case(ACTION_NODE_PUSH_REGISTER):
				{					
					if (find("</ActionResponse>", sRemoved))
					{
						// End of node
						iType = ACTION_NODE_ROOT;
						
						Register_Push_Request_Mode = REQUEST_MODE_IDLE;
					}
					else
					{
						
						// Is the action ID for register?
						if (find("ActionRegisterPush", sActionRequestID))
						{
							// Yes, this was a register puch response.
							
							if (find("<Parameter ID=\x22Registered\x22", sRemoved))
							{
								if (find("1", sRemoved))
								{
									g_bPushEnabled = TRUE;
								
									Register_Push_Request_Mode = REQUEST_MODE_SUCCESS;
								}
								else
								{
									g_bPushEnabled = FALSE;
								
									Register_Push_Request_Mode = REQUEST_MODE_FAILURE;
								}
							}
						}
						else
						{
							// No, this was an unregister response.
									
							g_bPushEnabled = FALSE;							
						}						
					}
					
					break;
				}
				
				case(ACTION_NODE_MEETING_CHANGE):
				{          
					if (find("</ActionResponse>", sRemoved))
					{
						// End of node
						iType = ACTION_NODE_ROOT;
					}
					else
					{						
						if (find("<Parameter ID=\x22GroupwareID\x22", sRemoved))
						{
							sTrash = remove("Value=\x22", sRemoved);
							sMeetingID = left(sRemoved, len(sRemoved) - 4);
							
							// Have MeetingID?
							if (len(sMeetingID) > 0)
							{
								call GetIsPrivate(sMeetingID);		
							}
							
							// Since meeting has changed, need to check
							// if meeting is started (preset), extended or current
							// and if so, get welcome msg again.
							
							// If meeting is started, then also get preset info again.							
						}
            else if (find("<Parameter ID=\x22MeetingID\x22", sRemoved))
            {
              sTrash = remove("Value=\x22", sRemoved);
              sMeetingID = left(sRemoved, len(sRemoved) - 4);
              if (Debug_Logic)
              {
                trace ("\rsMeetingID: %s", sMeetingID);
              }
            }
            else if (find("<Parameter ID=\x22Status\x22", sRemoved))
            {
              sTrash = remove("Value=\x22", sRemoved);
              iMeetingStatus = ATOI(left(sRemoved, len(sRemoved) - 4));
              if (Debug_Logic)
              {
                trace ("\riMeetingStatus: %d", iMeetingStatus);
              }
              
              if (iMeetingStatus = 1)
              {
                 End_Meeting_Request_Mode = REQUEST_MODE_SUCCESS;
              }
              else
              {
                 End_Meeting_Request_Mode = REQUEST_MODE_FAILURE;
              }
              
                          }
            else if (find("<Parameter ID=\x22Message\x22", sRemoved))
            {
             if (Debug_Logic)
             {
                trace ("\r ** Message Received **\r");
             }
            }
					}
					
					break;
				}
				
				case(ACTION_NODE_SUBSCRIPTION):
				{
					
					if (find("</ActionResponse>", sRemoved))
					{
						// End of node
						iType = ACTION_NODE_ROOT;
					}
					else
					{
							
						if (find("<Parameter ID=\x22Active\x22", sRemoved))
						{
							if (find("1", sRemoved))
							{
								EWS_Subscription_Offline_FB = TRUE;
								
								cancelwait(GetScheduleDelayWait);
								
								To_UI_Mod_DataIn$ =
									"<Data>" +
										"<Type>Subscription</Type>" +
										"<Status>Offline</Status>" +
									"</Data>";
							}
							else
							{
								EWS_Subscription_Offline_FB = FALSE;
								
								cancelwait(GetScheduleDelayWait);
								
								call GetScheduleDelay();
																
								To_UI_Mod_DataIn$ =
									"<Data>" +
										"<Type>Subscription</Type>" +
										"<Status>Online</Status>" +
									"</Data>";
							}
						}
						else if (find("<Parameter ID=\x22Text\x22", sRemoved))
						{
							sTrash = remove("Value=\x22", sRemoved);
							
							if (len(sRemoved) > 254)
							 EWS_Subscription_Offline_Msg$ = removebylength(250, sRemoved);
							else
							 EWS_Subscription_Offline_Msg$ = left(sRemoved, len(sRemoved) - 4);
						}						
					}
					
					break;
				}
				
				case(ACTION_NODE_BACKLOG):
				{
					
					if (find("</ActionResponse>", sRemoved))
					{
						// End of node
						iType = ACTION_NODE_ROOT;
					}
					else
					{
							
						if (find("<Parameter ID=\x22Active\x22", sRemoved))
						{
							if (find("1", sRemoved))
							{
								RoomService_Backlog_Active_FB = TRUE;
								
								To_UI_Mod_DataIn$ =
									"<Data>" +
										"<Type>Backlog</Type>" +
										"<Status>Active</Status>" +
									"</Data>";
							}
							else
							{
								RoomService_Backlog_Active_FB = FALSE;
								
								To_UI_Mod_DataIn$ =
									"<Data>" +
										"<Type>Backlog</Type>" +
										"<Status>Inactive</Status>" +
									"</Data>";
							}
						}
						else if (find("<Parameter ID=\x22Text\x22", sRemoved))
						{
							sTrash = remove("Value=\x22", sRemoved);
							
							if (len(sRemoved) > 254)
							 RoomService_Backlog_Active_Msg$ = removebylength(250,sRemoved);
							else
							 RoomService_Backlog_Active_Msg$ = left(sRemoved, len(sRemoved) - 4);
						}						
					}
					
					break;
				}
				
			}	
		}
			
  } until (len(sData) = 0);
}

Function TransferData()
{
	integer i;
	
	if (Debug_Logic)
	{
		trace ("\n** TransferData **\n"); 
	}
	
	g_iStoredEventCount = g_iAutoUpdateStoredEventCount;
	
	if (g_iAutoUpdateStoredEventCount > 0)
	{
		for (i = 1 to g_iAutoUpdateStoredEventCount)
		{
			MeetingEvent[i].MeetingID = AutoUpdateMeetingEvent[i].MeetingID;
			MeetingEvent[i].RVMeetingID = AutoUpdateMeetingEvent[i].RVMeetingID;
			MeetingEvent[i].InstanceID = AutoUpdateMeetingEvent[i].InstanceID;
			
			MeetingEvent[i].StartBlock = AutoUpdateMeetingEvent[i].StartBlock;
			MeetingEvent[i].EndBlock = AutoUpdateMeetingEvent[i].EndBlock;
			
			MeetingEvent[i].StartDate = AutoUpdateMeetingEvent[i].StartDate;
			MeetingEvent[i].EndDate = AutoUpdateMeetingEvent[i].EndDate;
			
			MeetingEvent[i].StartTime = AutoUpdateMeetingEvent[i].StartTime;
			MeetingEvent[i].EndTime = AutoUpdateMeetingEvent[i].EndTime;			
			
			MeetingEvent[i].Subject = AutoUpdateMeetingEvent[i].Subject;
			
			MeetingEvent[i].IsPrivate = AutoUpdateMeetingEvent[i].IsPrivate;
			MeetingEvent[i].IsExchangePrivate = AutoUpdateMeetingEvent[i].IsExchangePrivate;
			
			MeetingEvent[i].Organizer = AutoUpdateMeetingEvent[i].Organizer;
			
			MeetingEvent[i].Recurring = AutoUpdateMeetingEvent[i].Recurring;
		}		
	}
}

Function ProcessMeetingPresetDataResponse(string sData)
{
	string sRemovedData[300],
				 sTemp[1000];
         	
	if (Debug_Logic)
	{
		trace ("\n** ProcessMeetingPresetDataResponse **\n"); 
	}
	if(Debug_Preset_Data) Print("Inside Function ProcessMeetingPresetDataResponse\n");
	if(Debug_Preset_Data) Print("sData = %s\n", sData);
	
  	// Only process schedule data if no errors returned
  	if (!find("<Errors>", sData))
  	{  	
	  	if(Debug_Preset_Data) Print("Inside if (!find(\x22<Errors>\x22, sData))\n");
		g_sCurrentWelcomeMsg = "";
	  	
	  	// Preset module connected?
	  	if (g_bHaveMeetingPresetModule)
	  	{
  			// Yes, preset module connected. Just send all data to the module.

			if (Debug_Logic)
			{
				trace ("  Preset module connected. Sending data out.\n"); 
			}
			if(Debug_Preset_Data) Print("Inside if (g_bHaveMeetingPresetModule)\n");
	  		
	  		To_MeetingPreset_Mod_DataIn$ =
	  		 "<ScheduleInterfaceData><Type=\x22PresetData\x22 />";
	
	  		// Event index
	  		To_MeetingPreset_Mod_DataIn$ =
	  		 "<EventIndex>" + itoa(g_iLastSentGetPresetDataIndex) + "</EventIndex>";
	  		   		
	  		// Start date
	  		To_MeetingPreset_Mod_DataIn$ =
	  		 "<StartDate>" + MeetingEvent[g_iLastSentGetPresetDataIndex].StartDate + "</StartDate>";
	  		 
	  		// Start time
	  		To_MeetingPreset_Mod_DataIn$ =
	  		 "<StartTime>" + MeetingEvent[g_iLastSentGetPresetDataIndex].StartTime + "</StartTime>";
  		
  			do
  			{  		
	  			if (len(sData) > 240)
	  			{
	  				To_MeetingPreset_Mod_DataIn$ = removebylength(240, sData);
	  			}
	  			else
	  			{
	  				To_MeetingPreset_Mod_DataIn$ = removebylength(len(sData), sData);
	  			}
  		
  			} until (len(sData) = 0);
  		
  		 
  			To_MeetingPreset_Mod_DataIn$ =
  		 	"</ScheduleInterfaceData>";	
  		}
  		else
  		{
  			// Do not have preset module. Simply extract Welcome Message.

			if (Debug_Logic)
			{
				trace ("  Preset module not connected. Extracting welcome message.\n"); 
			}
			if(Debug_Preset_Data) Print("Inside the else for if (g_bHaveMeetingPresetModule)\n");
			      
	  		do
	  		{
	  			sRemovedData = remove(">", sData);	
	
				if (find("</WelcomeMessage>", sRemovedData))
				{
				  g_sCurrentWelcomeMsg = left(sRemovedData, len(sRemovedData) - 17);
				}
				    		
				// Check length
				if (len(g_sCurrentWelcomeMsg) > 250)
				{
				  // Need to chop list.
				  g_sCurrentWelcomeMsg = left(g_sCurrentWelcomeMsg, 250) + " ...";
				}
				
			} until (len(sData) = 0); 		
		}
  	
  		Current_Meeting_Welcome_Msg$ = g_sCurrentWelcomeMsg;
  	
  		Current_Meeting_Preset_Data_Request_Mode = REQUEST_MODE_IDLE;			    		
	}
	else
	{
		// Errors in the response.
		if(Debug_Preset_Data) Print("Inside the else for if (!find(\x22<Errors>\x22, sData))\n");
		Current_Meeting_Preset_Data_Request_Mode = REQUEST_MODE_FAILURE;
		Current_Meeting_Preset_Data_Request_Mode = REQUEST_MODE_IDLE;
	}

}

Function ProcessMeetingInfoResponse(integer iType, integer iRequestType, string sData)
{
	integer iNode;
	
	string sRemovedData[300],
				 sTemp[1000];
	
	string sEventEndDate[10],
         sEventEndTime[5],
         sEventOrganizer[MAX_NAME_LEN],
         sEventSubject[MAX_TEMP_SUBJECT_LEN];
  
  integer iRequiredAttendeeCount,
	        iOptionalAttendeeCount;
	
	string sRequiredAttendees[2000],
				 sOptionalAttendees[2000];

	integer bRequiredAttendee,
					bOptionalAttendee;	
	
	if (Debug_Logic)
	{
		trace ("\n** ProcessMeetingInfoResponse **\n");
		trace ("  iType:%u\n", iType);
		trace ("  iRequestType:%u\n", iRequestType); 
	}
	
	// Type 1 = Current Meeting
	// Type 2 = Next Meeting
	
	iNode = SCHED_NODE_ROOT;
	
  // Only process schedule data if no errors returned
  if (!find("<Errors>", sData))
  {
  	
  	if (iType = MEETING_INFO_CURRENT && iRequestType = MEETING_INFO_REQUEST_ATTENDEES)
  	 Current_Meeting_Info_Request_Mode = REQUEST_MODE_PROCESSING;
  	else if (iType = MEETING_INFO_NEXT && iRequestType = MEETING_INFO_REQUEST_ATTENDEES)
  	 Next_Meeting_Info_Request_Mode = REQUEST_MODE_PROCESSING;
  	
  	do
  	{
  		sRemovedData = remove(">", sData);

		  // Which node are we in?
		  if (iNode = SCHED_NODE_ROOT)
		  {
			  // In root node.
			  
			  // Reset expected vars at the start of event data
			  if (find("<Event>", sRemovedData))
			  {
			  	sEventEndDate = "-1";
			  	sEventEndTime = "-1";
			  	sEventOrganizer = "-1";
			  	sEventSubject = "-1";
			  	sRequiredAttendees = "-1";
			  	sOptionalAttendees = "-1";
			  }
			  else if (find("</Event>", sRemovedData))
			  {
			    
			    // Send out info.
			    	
			    if (iType = MEETING_INFO_CURRENT && iRequestType = MEETING_INFO_REQUEST_ATTENDEES)
			    {			    
			    		
			    	// Received required data?
			    	if (sRequiredAttendees != "-1")
			    	{
			    		// Check length of required attendees
			    		if (len(sRequiredAttendees) > 255)
			    		{
			    			// Need to chop list.
			    			Current_Meeting_Required_Attendees$ = left(sRequiredAttendees, 250) + " ...";
			    		}
			    		else
			    		{
			    			Current_Meeting_Required_Attendees$ = sRequiredAttendees;
			    		}
			    	}

			    	// Received optional data?
			    	if (sOptionalAttendees != "-1")
			    	{			    	
			    		// Check length of optional attendees
			    		if (len(sOptionalAttendees) > 255)
			    		{
			    			// Need to chop list.
			    			Current_Meeting_Optional_Attendees$ = left(sOptionalAttendees, 250) + " ...";
			    		}
			    		else
			    		{
			    			Current_Meeting_Optional_Attendees$ = sOptionalAttendees;
			    		}
			    	}
			    }
			    else if (iType = MEETING_INFO_NEXT && iRequestType = MEETING_INFO_REQUEST_ATTENDEES)
			    {
			    	// Send out info.

			    	// Received required data?
			    	if (sRequiredAttendees != "-1")
			    	{			    	
			    		// Check length of required attendees
			    		if (len(sRequiredAttendees) > 255)
			    		{
			    			// Need to chop list.
			    			Next_Reservation_Required_Attendees$ = left(sRequiredAttendees, 250) + " ...";
			    		}
			    		else
			    		{
			    			Next_Reservation_Required_Attendees$ = sRequiredAttendees;
			    		}
			    	}

			    	// Received optional data?
			    	if (sOptionalAttendees != "-1")
			    	{			    	
			    		// Check length of optional attendees
			    		if (len(sOptionalAttendees) > 255)
			    		{
			    			// Need to chop list.
			    			Next_Reservation_Optional_Attendees$ = left(sOptionalAttendees, 250) + " ...";
			    		}
			    		else
			    		{
			    			Next_Reservation_Optional_Attendees$ = sOptionalAttendees;
			    		}
			    	}
			    }
			  }
			  else if (find("</dtEnd>", sRemovedData))
			  {
		      // Remove the date
			    sEventEndDate = left(sRemovedData, 10);
		      
			    // Remove the time
		      sEventEndTime = mid(sRemovedData, 12, 5);
			  }
			  else if (find("</Organizer>", sRemovedData))
			  {
			    sEventOrganizer = left(sRemovedData, len(sRemovedData) - 12); 
			  }
		    else if (find("<Subject>", sRemovedData))
		    {
		      iNode = SCHED_NODE_MEETING_SUBJECT;
		    }
		    else if (find("<Attendees>", sRemovedData))
		    {	      
		      iNode = SCHED_NODE_ATTENDEES;
		      
		      // Reset vars
		      iRequiredAttendeeCount = 0;
		      iOptionalAttendeeCount = 0;
		    
		      bRequiredAttendee = FALSE;
		      bOptionalAttendee = FALSE;
		      
		      sRequiredAttendees = "";
		      sOptionalAttendees = "";
		    }
		  }
		  else if (iNode = SCHED_NODE_ATTENDEES)
		  {
		  	if (find("</Attendees>", sRemovedData))
		  	{
		  		iNode = SCHED_NODE_ROOT;
		  	}
		  	else
		  	{
		    	if (find("<Required>", sRemovedData))
		    	{
		      	bRequiredAttendee = TRUE;
		    	}
		    	else if (find("</Required>", sRemovedData))
		    	{
		      	bRequiredAttendee = FALSE;
		    	}
		    	else if (find("<Optional>", sRemovedData))
		    	{
		      	bOptionalAttendee = TRUE;
		    	}
		    	else if (find("</Optional>", sRemovedData))
		    	{
		      	bOptionalAttendee = FALSE;
		    	}    
		    	else if (find("</Attendee>", sRemovedData))
		    	{    
		      	sTemp = left(sRemovedData, len(sRemovedData) - 11);
		    
		      	// Attendee data?
		      	if (len(sTemp) > 0)
		      	{
		        	// Have attendee
		        
		        	// Filter out name that equal Conf Room
		        	if (!find("Conf Room", sTemp))
		        	{
		        		// Which list?
		          	if (bRequiredAttendee)
		          	{
		            	// Required attendee list
		            
		            	if (iRequiredAttendeeCount < MAX_ATTENDEES)
		            	{
		              	iRequiredAttendeeCount = iRequiredAttendeeCount + 1;
		              
		              	if (iRequiredAttendeeCount > 1)
		              	{
		             			sRequiredAttendees = sRequiredAttendees + ";" + sTemp;
		            		}
		            		else
		            		{
		            			sRequiredAttendees = sRequiredAttendees + sTemp;
		            		}
		            	}
		          	}
		          	else if (bOptionalAttendee)
		          	{
		            	// Optional attendee list
		            
		            	if (iOptionalAttendeeCount < MAX_ATTENDEES)
		            	{
		              	iOptionalAttendeeCount = iOptionalAttendeeCount + 1;
		              
		              	if (iOptionalAttendeeCount > 1)
		              	{
		              		sOptionalAttendees = sOptionalAttendees + ";" + sTemp;    
		            		}
		            		else
		            		{
		            			sOptionalAttendees = sOptionalAttendees + sTemp;
		            		}
		            	}
		          	} 
		        	}
		      	} 
		    	}
		  	}
		  }
		  else if (iNode = SCHED_NODE_MEETING_SUBJECT)
		  {
		    if (find("</Subject>", sRemovedData))
		    {
		      // Found the end of the subject, so process all data 
		      
			    sEventSubject = sEventSubject + left(sRemovedData, len(sRemovedData) - 10); 
		      
		      if (len(sEventSubject) > 240)
		       sEventSubject = left(sEventSubject, 240);
		      
		      iNode = SCHED_NODE_ROOT;
		    }
		    else
		    { 
			    // Did not find the end tag, so just keep adding data
			    sEventSubject = sEventSubject + sRemovedData;
		    }
		  }
  	
  	} until (len(sData) = 0);
  	
  	if (iType = MEETING_INFO_CURRENT && iRequestType = MEETING_INFO_REQUEST_ATTENDEES)
  	 Current_Meeting_Info_Request_Mode = REQUEST_MODE_IDLE;
  	else if (iType = MEETING_INFO_NEXT && iRequestType = MEETING_INFO_REQUEST_ATTENDEES)
  	 Next_Meeting_Info_Request_Mode = REQUEST_MODE_IDLE;		
	}
	else
	{
		// Have errors in the response.

  	if (iType = MEETING_INFO_CURRENT && iRequestType = MEETING_INFO_REQUEST_ATTENDEES)
  	{
  		Current_Meeting_Info_Request_Mode = REQUEST_MODE_FAILURE;
  		Current_Meeting_Info_Request_Mode = REQUEST_MODE_IDLE;
  	}
  	else if (iType = MEETING_INFO_NEXT && iRequestType = MEETING_INFO_REQUEST_ATTENDEES)
  	{
  		Next_Meeting_Info_Request_Mode = REQUEST_MODE_PROCESSING;
  		Next_Meeting_Info_Request_Mode = REQUEST_MODE_IDLE;		
		}
	}	
}

Function ClearAutoUpdateData()
{
  integer i;
  
	if (Debug_Logic)
	{
		trace ("\n** ClearAutoUpdateData **\n"); 
	}
	
	for (i = 1 to MAX_STORED_EVENTS)
	{					
					
		AutoUpdateMeetingEvent[i].StartBlock = 0;
		AutoUpdateMeetingEvent[i].EndBlock = 0;
		AutoUpdateMeetingEvent[i].StartDate = "";
		AutoUpdateMeetingEvent[i].EndDate = "";
		AutoUpdateMeetingEvent[i].StartTime = "";
		AutoUpdateMeetingEvent[i].EndTime = "";
		AutoUpdateMeetingEvent[i].MeetingID = "";
		AutoUpdateMeetingEvent[i].RVMeetingID = "";
		AutoUpdateMeetingEvent[i].InstanceID = "";
		AutoUpdateMeetingEvent[i].Subject = "";
		AutoUpdateMeetingEvent[i].IsPrivate = FALSE;
		AutoUpdateMeetingEvent[i].IsExchangePrivate = FALSE;
		AutoUpdateMeetingEvent[i].Organizer = "";
		AutoUpdateMeetingEvent[i].Recurring = FALSE;
		
	}
}

Function AutoUpdateStartEvents()
{
	if (Debug_Logic)
	{
		trace ("\n** AutoUpdateStartEvents **\n"); 
	}

	// Start auto update events for push.
	// Request tomorrow's schedule and store in temp structure. 
		
	Auto_Update_Process_Active = TRUE;
		
	call ClearAutoUpdateData();
		
	g_sAutoUpdateDate = NextDayDate(g_sDateToday, "1");
				
	// Request tomorrow's schedule.
		
	g_bHaveAutoUpdateSchedule = FALSE;
	g_iAutoUpdateStoredEventCount = 0;
		
	Auto_Update_Need_Sched = TRUE;
}

Function RoomViewOfflineEvents()
{
	if (Debug_Logic)
	{
		trace ("\n** RoomViewOfflineEvents **\n"); 
	}
	
	Workday_Sched_Request_Mode = REQUEST_MODE_IDLE;
	Next_Reserv_Request_Mode = REQUEST_MODE_IDLE;
	First_Appt_Request_Mode = REQUEST_MODE_IDLE;
	Reserve_Now_Request_Mode = REQUEST_MODE_IDLE;
	Auto_Update_Request_Mode = REQUEST_MODE_IDLE;
	Register_Push_Request_Mode = REQUEST_MODE_IDLE;
  Current_Meeting_Info_Request_Mode = REQUEST_MODE_IDLE;
  Current_Meeting_Preset_Data_Request_Mode = REQUEST_MODE_IDLE;
  Next_Meeting_Info_Request_Mode = REQUEST_MODE_IDLE;
  
	g_bReserveNowSuccessNeedSched = FALSE;
	
	g_sScheduleRequestID = "";
	g_sPushRequestID = "";
  g_sReserveNowRequestID = "";
  g_sActionRVIDRequestID = "";
  g_sActionPushRequestID = "";
  g_sNextReservRequestID = "";
  g_sFirstApptRequestID = "";
  g_sIsPrivateRequestID = "";
  g_sAutoUpdateRequestID = "";
  
  //g_iStoredEventCount = 0;
  //g_iCurrentEventNum = 0;
  //g_iStartedEventNum = 0;
  //g_iExtendedEventNum = 0;
	
	g_bHaveAutoUpdateSchedule = FALSE;
	g_iAutoUpdateStoredEventCount = 0;
	
  Auto_Update_Need_Sched = FALSE;  
  
  Have_Valid_Workday_Sched = FALSE;
  
  NextEvent.MeetingID = "";
	NextEvent.InstanceID = "";	
	NextEvent.StartDate = "";
  NextEvent.StartTime = "";  
	NextEvent.EndDate = "";
  NextEvent.EndTime = "";  
  NextEvent.Subject = "";  
  NextEvent.IsPrivate = FALSE;
  NextEvent.IsExchangePrivate = FALSE;  
  NextEvent.Organizer = "";   

  Meeting_Active = FALSE;
  End_Meeting_Btn_Sub = FALSE;
  End_Meeting_Confirm_Sub = FALSE;
  Current_Meeting_Private = FALSE;
  Have_Next_Reservation = FALSE;
  Next_Reservation_Private = FALSE;
  End_Meeting_Warn_FB = FALSE;
  Enable_Reserve_Now = FALSE;

  Current_Meeting_Duration_Min = 0;
  Current_Meeting_Elapsed_Time = 0;
  Current_Meeting_Elapsed_Percent = 0;
                                   
  call UpdateCalendar();
  call UpdateCurrentMeetingInfo();
  call UpdateNextReservInfo();
	call SendUIEventList();
	
	// Remote system module connected?
	if (g_bHaveRemoteSysModule)
	{
		call SendRemoteSystemData(REM_SYS_DATA_WORKDAY, "");
		call SendRemoteSystemData(REM_SYS_DATA_CURR_MEETING, "");
		call SendRemoteSystemData(REM_SYS_DATA_NEXT_RESERV, "");
	}
}

Function RoomViewOnlineEvents()
{
	if (Debug_Logic)
	{
		trace ("\n** RoomViewOnlineEvents **\n"); 
	}
	
	Workday_Sched_Request_Mode = REQUEST_MODE_IDLE;
	Next_Reserv_Request_Mode = REQUEST_MODE_IDLE;
	First_Appt_Request_Mode = REQUEST_MODE_IDLE;
	Reserve_Now_Request_Mode = REQUEST_MODE_IDLE;
	Auto_Update_Request_Mode = REQUEST_MODE_IDLE;
	Register_Push_Request_Mode = REQUEST_MODE_IDLE;
  Current_Meeting_Info_Request_Mode = REQUEST_MODE_IDLE;
  Current_Meeting_Preset_Data_Request_Mode = REQUEST_MODE_IDLE;
  Next_Meeting_Info_Request_Mode = REQUEST_MODE_IDLE;

  EWS_Subscription_Offline_FB = FALSE;
  RoomService_Backlog_Active_FB = FALSE;

	To_UI_Mod_DataIn$ =
		"<Data>" +
			"<Type>Subscription</Type>" +
			"<Status>Online</Status>" +
		"</Data>";

	To_UI_Mod_DataIn$ =
		"<Data>" +
			"<Type>Backlog</Type>" +
			"<Status>Inactive</Status>" +
		"</Data>";
																		                 
	g_bReserveNowSuccessNeedSched = FALSE;
	
	g_sScheduleRequestID = "";
	g_sPushRequestID = "";
  g_sReserveNowRequestID = "";
  g_sActionRVIDRequestID = "";
  g_sActionPushRequestID = "";
  g_sNextReservRequestID = "";
  g_sFirstApptRequestID = "";
  g_sIsPrivateRequestID = "";
  g_sAutoUpdateRequestID = "";
  
  //g_iStoredEventCount = 0;
  //g_iCurrentEventNum = 0;
  //g_iStartedEventNum = 0;
  //g_iExtendedEventNum = 0;
	
	g_bHaveAutoUpdateSchedule = FALSE;
	g_iAutoUpdateStoredEventCount = 0;
	
  Auto_Update_Need_Sched = FALSE;  
  
  Have_Valid_Workday_Sched = FALSE;

  Meeting_Active = FALSE;
  End_Meeting_Btn_Sub = FALSE;
  End_Meeting_Confirm_Sub = FALSE;
  Current_Meeting_Private = FALSE;
  Have_Next_Reservation = FALSE;
  Next_Reservation_Private = FALSE;
  End_Meeting_Warn_FB = FALSE;
  Enable_Reserve_Now = FALSE;

  Current_Meeting_Duration_Min = 0;
  Current_Meeting_Elapsed_Time = 0;
  Current_Meeting_Elapsed_Percent = 0;
      
  call UpdateCalendar();
  call UpdateCurrentMeetingInfo();
  call UpdateNextReservInfo();
	call SendUIEventList();
	
	// Remote system module connected?
	if (g_bHaveRemoteSysModule)
	{
		call SendRemoteSystemData(REM_SYS_DATA_WORKDAY, "");
		call SendRemoteSystemData(REM_SYS_DATA_CURR_MEETING, "");
		call SendRemoteSystemData(REM_SYS_DATA_NEXT_RESERV, "");
	}
}

Function ProcessFromRVScheduleResponse$()
{
	if (Debug_Logic)
	{
		trace ("\n** ProcessFromRVScheduleResponse$ **\n"); 
	}
	if(Debug_Preset_Data) Print("Inside Function ProcessFromRVScheduleResponse$\n");
  
  if (find(g_sScheduleRequestID, g_sRXData1))
  {      	
    if (Debug_Logic)
    {
      trace ("  Found g_sScheduleRequestID\n");      		
    }
	if(Debug_Preset_Data) Print("Inside if (find(g_sScheduleRequestID, g_sRXData1))\n");
      	
    call ProcessScheduleResponse(REQUEST_TODAY, g_sRXData1);    	
  }
  else if (find(g_sPushRequestID, g_sRXData1))
  {
    if (Debug_Logic)
    {
      trace ("  Found g_sPushRequestID\n");      		
    }
	if(Debug_Preset_Data) Print("Inside else if (find(g_sPushRequestID, g_sRXData1))\n");
    		
    call ProcessScheduleResponse(REQUEST_PUSH, g_sRXData1);
  }
  else if (find(g_sNextReservRequestID, g_sRXData1))
  {
    if (Debug_Logic)
    {
     trace ("  Found g_sNextReservRequestID\n");      		
    }
	if(Debug_Preset_Data) Print("Inside else if (find(g_sNextReservRequestID, g_sRXData1))\n");
    		
    call ProcessScheduleResponse(REQUEST_NEXT_RESERV, g_sRXData1);
  }
  else if (find(g_sFirstApptRequestID, g_sRXData1))
  {
    if (Debug_Logic)
    {
      trace ("  Found g_sFirstApptRequestID\n");      		
    }
	if(Debug_Preset_Data) Print("Inside else if (find(g_sFirstApptRequestID, g_sRXData1))\n");
    		
    call ProcessScheduleResponse(REQUEST_FIRST_APPT, g_sRXData1);
  }
  else if (find(g_sAutoUpdateRequestID, g_sRXData1))
  {
    if (Debug_Logic)
    {
      trace ("  Found g_sAutoUpdateRequestID\n");      		
    }
	if(Debug_Preset_Data) Print("Inside else if (find(g_sAutoUpdateRequestID, g_sRXData1))\n");
      	
    call ProcessScheduleResponse(REQUEST_AUTO_UPDATE, g_sRXData1);
  }
  else if (find(g_sIsPrivateRequestID, g_sRXData1))
  {
    if (Debug_Logic)
    {
      trace ("  Found g_sIsPrivateRequestID\n");      		
    }
	if(Debug_Preset_Data) Print("Inside else if (find(g_sIsPrivateRequestID, g_sRXData1))\n");
      	
    call ProcessScheduleResponse(REQUEST_IS_PRIVATE, g_sRXData1);
  }
  else if (find(g_sCurrentMeetingInfoRequestID, g_sRXData1))
  {
    if (Debug_Logic)
    {
      trace ("  Found g_sCurrentMeetingInfoRequestID\n");      		
    }
	if(Debug_Preset_Data) Print("Inside else if (find(g_sCurrentMeetingInfoRequestID, g_sRXData1))\n");
      	
    call ProcessMeetingInfoResponse(MEETING_INFO_CURRENT, MEETING_INFO_REQUEST_ATTENDEES, g_sRXData1);
  }
  else if (find(g_sCurrentMeetingPresetDataRequestID, g_sRXData1))
  {
    if (Debug_Logic)
    {
      trace ("  Found g_sCurrentMeetingPresetDataRequestID\n");      		
    }
	if(Debug_Preset_Data) Print("Inside else if (find(g_sCurrentMeetingPresetDataRequestID, g_sRXData1))\n");
      	
    call ProcessMeetingPresetDataResponse(g_sRXData1);
  }    	
  else if (find(g_sNextMeetingInfoRequestID, g_sRXData1))
  {
    if (Debug_Logic)
    {
      trace ("  Found g_sNextMeetingInfoRequestID\n");      		
    }
	if(Debug_Preset_Data) Print("Inside else if (find(g_sNextMeetingInfoRequestID, g_sRXData1))\n");
      	
    call ProcessMeetingInfoResponse(MEETING_INFO_NEXT, MEETING_INFO_REQUEST_ATTENDEES, g_sRXData1);
  }    	
  else if (find("<RequestID>RVRequest</RequestID>", g_sRXData1) &&
   find("Action ID=\x22RequestSchedule\x22", g_sRXData1))
  {
  	Processed_RV_Forced_Refresh = Processed_RV_Forced_Refresh + 1;
	if(Debug_Preset_Data) Print("Inside else if (find(\x22<RequestID>RVRequest</RequestID>\x22, g_sRXData1) && find(\x22Action ID=\x22RequestSchedule\x22\x22, g_sRXData1))\n");
  			
  	// Clear next event data
  	NextEvent.MeetingID = "";
  	NextEvent.InstanceID = "";
  	NextEvent.StartDate = "";
  	NextEvent.StartTime = "";
  	NextEvent.EndDate = "";
  	NextEvent.EndTime = "";
  	NextEvent.Subject = "";
  	NextEvent.Organizer = "";
  	NextEvent.IsPrivate = FALSE;
  	NextEvent.IsExchangePrivate = FALSE;
    			
  	if (Workday_Sched_Request_Mode = REQUEST_MODE_IDLE)
  	{
  		call GetSchedule(REQUEST_TODAY, g_sDateToday, "00:00:00", "24");
  	}
  	else
  	{
  		g_bNeedAnotherWorkdayRequest = TRUE;
  	}     		
  }
  else if (find("<RequestID>UserSchedule", g_sRXData1))
  {
    if (Debug_Logic)
    {
      trace ("  Found UserSchedule RequestID\n");      		
    }
	if(Debug_Preset_Data) Print("Inside else if (find(\x22<RequestID>UserSchedule\x22, g_sRXData1))\n");
      	
    call SendUISchedData(g_sRXData1);
  }
  else if (find("<RequestID>UserInfo", g_sRXData1))
  {
    if (Debug_Logic)
    {
      trace ("  Found UserInfo RequestID\n");      		
    }
	if(Debug_Preset_Data) Print("Inside else if (find(\x22<RequestID>UserInfo\x22, g_sRXData1))\n");
      	
    call SendUISchedData(g_sRXData1);
  }
}

Function ProcessFromRVCreateResponse$()
{
	if (Debug_Logic)
	{
		trace ("\n** ProcessFromRVCreateResponse$ **\n"); 
	}
  
  if (find(g_sReserveNowRequestID, g_sRXData2))
  {    		    		
    call ProcessCreateResponse(CREATE_TYPE_RESERVE_NOW, g_sRXData2);
  }
  else if (find("<RequestID>UserCreate", g_sRXData2))
  {
    if (Debug_Logic)
    {
      trace ("  Found User RequestID\n");      		
    }
      	
    call SendUICreateData(g_sRXData2);    		
  }
  else if (find("<RequestID>AvailRoomsCreate", g_sRXData2))
  {
    if (Debug_Logic)
    {
      trace ("  Found Available Rooms RequestID\n");      		
    }
      	
    call SendAvailRoomsCreateData(g_sRXData2);    		
  }
}

Function ProcessFromRVActionResponse$()
{
	string sMeetingID[MAX_MEETING_ID_LEN];
    
  if (Debug_Logic)
	{
		trace ("\n** ProcessFromRVActionResponse$ **\n");
	}
  
  if (find(g_sActionPushRequestID, g_sRXData3))
	{
		call ProcessActionResponse(g_sRXData3);
	}
	else if (find(g_sActionRVIDRequestID, g_sRXData3))
	{
		call ProcessActionResponse(g_sRXData3); 				
	}
  else if (find(g_sEndMeetingRequestID, g_sRXData3))
  {
    call ProcessActionResponse(g_sRXData3);
  }
	else if (find("<RequestID>RequestApptRefresh</RequestID>", g_sRXData3))
	{
		call ProcessActionResponse(g_sRXData3);				
	}
	else if (find("<RequestID>SchedAlertSubscription</RequestID>", g_sRXData3))
	{
		call ProcessActionResponse(g_sRXData3);				
	}
	else if (find("<RequestID>SchedAlertBacklog</RequestID>", g_sRXData3))
	{
		call ProcessActionResponse(g_sRXData3);				
	}
}

/*******************************************************************************************
  Event Handlers
  (Uncomment and declare additional event handlers as needed)
*******************************************************************************************/

PUSH Initialize_Module
{
  integer i;
  
  Initialize_Module_Busy_FB = TRUE;

  g_bHaveMeetingPresetModule = FALSE;
  g_bHaveRemoteSysModule = FALSE;
  
  Processed_Push_Responses = 0;
  Processed_RV_Forced_Refresh = 0;
  
  g_iStoredEventCount = 0;
  g_iAutoUpdateStoredEventCount = 0;
  
  g_iStartedEventNum = 0;
  g_sStartedEventID = "";
  
  g_bNeedAnotherWorkdayRequest = FALSE;
  
  g_bRXOK1 = TRUE;
  g_bRXOK2 = TRUE;
  g_bRXOK3 = TRUE;
  
  g_sRXData1 = "";
  g_sRXData2 = "";
  g_sRXData3 = "";
  
  Workday_Sched_Request_Mode = REQUEST_MODE_IDLE;
  Next_Reserv_Request_Mode = REQUEST_MODE_IDLE;
  First_Appt_Request_Mode = REQUEST_MODE_IDLE;
	Reserve_Now_Request_Mode = REQUEST_MODE_IDLE;
	Register_Push_Request_Mode = REQUEST_MODE_IDLE;
	Current_Meeting_Info_Request_Mode = REQUEST_MODE_IDLE;
	Current_Meeting_Preset_Data_Request_Mode = REQUEST_MODE_IDLE;
	Next_Meeting_Info_Request_Mode = REQUEST_MODE_IDLE;
	Auto_Update_Request_Mode = REQUEST_MODE_IDLE;
	
  Have_Valid_Workday_Sched = FALSE;
  
  g_bReserveNowSuccessNeedSched = FALSE;
  
  Enable_Reserve_Now = FALSE;
  
  Auto_Update_Need_Sched = FALSE;  
  Auto_Update_Process_Active = FALSE;
  
  Have_Next_Reservation = FALSE;
  Next_Reservation_Private = FALSE;
  
  g_bNeedFirstApptRequest = TRUE;
  
  g_bWaitingToSendInfoEventList = FALSE;
  g_bWaitingToSendUIEventList = FALSE;
  
  g_bWaitingToSendRVData = FALSE;
  
  Reserve_Now_Message$ = "";
  
  g_sCurrentMeetingWelcomeMsgID = "";
  
  g_iLastSentGetPresetDataIndex = 0;
  
  EWS_Subscription_Offline_FB = FALSE;
  RoomService_Backlog_Active_FB = FALSE;
  EWS_Subscription_Offline_Msg$ = "";
                 
	call SetDateTimeVars();
	  
  g_sMonth[1] = "January";
  g_sMonth[2] = "February";
  g_sMonth[3] = "March";
  g_sMonth[4] = "April";
  g_sMonth[5] = "May";
  g_sMonth[6] = "June";
  g_sMonth[7] = "July";
  g_sMonth[8] = "August";
  g_sMonth[9] = "September";
  g_sMonth[10] = "October";
  g_sMonth[11] = "November";
  g_sMonth[12] = "December";
  
  for (i = 1 to MAX_TIME_BLOCKS)
  {
    Time_Block_Mode[i] = 0;
    Time_Block_Text$[i] = "";
  }
    
  Initialize_Module_Busy_FB = FALSE;
}

CHANGE Privacy_Level
{
	call UpdateCalendar();
}

PUSH RoomView_Online_FB
{
	call RoomViewOnlineEvents();
	
	if (Auto_Update_Process_Active)
	 call AutoUpdateStartEvents();  	
}

RELEASE RoomView_Online_FB
{
	call RoomViewOfflineEvents();
}

PUSH Auto_Update_Push_Start
{
	
	if (!Auto_Update_Process_Active)
	 call AutoUpdateStartEvents();	
}

PUSH Auto_Update_Get_Schedule
{
	// Make sure request not already made and not processing response.
	if (Auto_Update_Request_Mode = REQUEST_MODE_IDLE && !g_bHaveAutoUpdateSchedule)
	{		
		call GetSchedule(REQUEST_AUTO_UPDATE, g_sAutoUpdateDate, "00:00:00", "24");	
	}
}

PUSH Auto_Update_Request_Timeout
{
	Auto_Update_Request_Mode = REQUEST_MODE_FAILURE;
	Auto_Update_Request_Mode = REQUEST_MODE_IDLE;
	
	g_sAutoUpdateRequestID = "";
	
	GenerateUserError("Auto Update Schedule Request Timeout");
}

PUSH Debug_Print_Work_Events
{
  call PrintEvents(TYPE_WORKDAY);
}

PUSH Debug_Print_AutoUpdate_Events
{
  call PrintEvents(TYPE_AUTO_UPDATE);
}

PUSH Debug_Force_Reserve_Now
{
	call ReserveNow();	
}

PUSH Schedule_Request_Timeout
{
	Workday_Sched_Request_Mode = REQUEST_MODE_FAILURE;
	Workday_Sched_Request_Mode = REQUEST_MODE_IDLE;
	
	g_bReserveNowSuccessNeedSched = FALSE;
	
	GenerateUserError("Workday Schedule Request Timeout");
	
	call SetReserveNow();
}

PUSH Check_Room_Status
{
  
  call SetDateTimeVars();
  
  if (Have_Valid_Workday_Sched)
  {
  	
  	// Auto update process active?
  	if (Auto_Update_Process_Active)
  	{
  		// Yes, auto update process active.
  	
  		if (Debug_Logic)
  		{
  			trace ("  AutoUpdateProcess active.\n");
  		}
  	
  		// Have we moved to the next day yet?
  		if (g_sDateToday = g_sAutoUpdateDate)
  		{
  			// Yes, we have moved to the next day.
  		
  			if (Debug_Logic)
  			{
  				trace ("  System has moved to AutoUpdate date.\n");
  			}
  		  
  		  // Reset flag (in case it is still active)
  		  Auto_Update_Need_Sched = FALSE;
  		  
  		  // If did not receive next day schedule
  		  if (!g_bHaveAutoUpdateSchedule)
  		  {  		  	
  		  	Have_Valid_Workday_Sched = FALSE;
  		  }
  		  else
  		  {
  		  	Have_Valid_Workday_Sched = TRUE;
  		  }
  		  
  		  // Reset processed push response count
  		  Processed_Push_Responses = 0;
  		  
  		  // Reset rv forced refresh count
  		  Processed_RV_Forced_Refresh = 0;
  		  
  			// Clear auto update active.
  			Auto_Update_Process_Active = FALSE;
  		  
  			// Transfer data.
  		  call TransferData();
  			
  			// Update calendar.
  			call UpdateCalendar();

	  		// Send UIEventList 
	  		call SendUIEventList();
  		}
  	}  	
  	
  	call CheckRoomStatus(FALSE);
	}
	else
	{
		// Still need to set ReserveNow button regardless.
		
		call SetReserveNow();
	}
}


PUSH Reserve_Now
{  
  if (Reserve_Now_Request_Mode = REQUEST_MODE_IDLE && Enable_Reserve_Now)
  {
    if (Reserve_Now_Time_Select)
    {
	    Set_Reserve_Now_Select = TRUE;
	    
	    if (SetReserveNowStartEnd(00, 30))
	    {
	      Reserve_Now_Select_30_Mode = 0;
	    }
      else
      {
        Reserve_Now_Select_30_Mode = 1;
      }
      
	    if(SetReserveNowStartEnd(30, 60))
	    {
	      Reserve_Now_Select_60_Mode = 0;
	    }
      else
      {
        Reserve_Now_Select_60_Mode = 1;
      }
      
	    if (SetReserveNowStartEnd(60, 90))
	    {
	      Reserve_Now_Select_90_Mode = 0;
	    }
      else
      {
        Reserve_Now_Select_90_Mode = 1;
      }
	    
	    Set_Reserve_Now_Select = FALSE;
	  }
	  else
	  {
	  	Set_Reserve_Now_Confirm = SetReserveNowStartEnd(0, Reserve_Now_Duration);
	  	Set_Reserve_Now_Confirm = FALSE;
    }
  }
}

PUSH Reserve_Now_Yes
{
	call ReserveNow();
}

PUSH Reserve_Now_Select_30
{
  if (Reserve_Now_Select_30_Mode = 0)
  {
		g_sReserveNowDTStart = ReserveNowToIntDateFormat(Select30Min, "Start");							
		g_sReserveNowDTEnd = ReserveNowToIntDateFormat(Select30Min, "End");
	  call ReserveNow();
  }
}

PUSH Reserve_Now_Select_60
{
  if (Reserve_Now_Select_60_Mode = 0)
  {
		g_sReserveNowDTStart = ReserveNowToIntDateFormat(Select60Min, "Start");							
		g_sReserveNowDTEnd = ReserveNowToIntDateFormat(Select60Min, "End");
	  call ReserveNow();
  }
}

PUSH Reserve_Now_Select_90
{
  if (Reserve_Now_Select_90_Mode = 0)
  {
		g_sReserveNowDTStart = ReserveNowToIntDateFormat(Select90Min, "Start");							
		g_sReserveNowDTEnd = ReserveNowToIntDateFormat(Select90Min, "End");
	  call ReserveNow();
  }
}


PUSH Reserve_Now_Timeout
{
	Reserve_Now_Message$ = "Request timed out.";
	
	Reserve_Now_Request_Mode = REQUEST_MODE_FAILURE;
	Reserve_Now_Request_Mode = REQUEST_MODE_IDLE;
	
	call SetReserveNow();
}

PUSH End_Meeting_Confirm_NO
{
    End_Meeting_confirm_sub = FALSE;
    End_Meeting_Btn_FB = FALSE;
}

PUSH End_Meeting_Confirm_YES
{
   call EndMeeting();
}

PUSH End_Meeting_Btn
{
  End_Meeting_Btn_FB = TRUE;
  End_Meeting_confirm_sub = TRUE;
}

PUSH End_Meeting_Timeout
{
	
	End_Meeting_Request_Mode = REQUEST_MODE_FAILURE;
	End_Meeting_Request_Mode = REQUEST_MODE_IDLE;
	
	call SetEndMeetingBtn();
}

PUSH Start_Meeting_Btn
{
  Start_Meeting_Confirm_Sub = TRUE;
  Start_Meeting_Btn_FB = TRUE;
}

PUSH Start_Meeting_Confirm_NO
{
  Start_Meeting_Confirm_Sub = FALSE;
  Start_Meeting_Btn_FB = FALSE;
}

PUSH Start_Meeting_Confirm_YES
{
  call StartMeeting();
}


PUSH Get_Schedule
{  
  string sDate[10];
  
  sDate = date(3); //get today's date
  
  //format in UTC
  g_sDateToday = left(sDate, 4) + "-" + mid(sDate, 6, 2) + "-" + right(sDate, 2);  
  
  Schedule_Label$ = FormatDate(g_sDateToday, 1); //send the date to the TP field
  
  if (Workday_Sched_Request_Mode = REQUEST_MODE_IDLE)
  {
  	call GetSchedule(REQUEST_TODAY, g_sDateToday, "00:00:00", "24");
  }
}


PUSH Register_Push
{
	if (Register_Push_Request_Mode = REQUEST_MODE_IDLE)
	{		
		call RegisterPush(1);
	}
}

PUSH Register_Push_Timeout
{
	g_sPushRequestID = "";
		
	g_bPushEnabled = FALSE;
		
	Register_Push_Request_Mode = REQUEST_MODE_FAILURE;
	Register_Push_Request_Mode = REQUEST_MODE_IDLE;
}

PUSH Unregister_Push
{
	if (Register_Push_Request_Mode = REQUEST_MODE_IDLE)
	{		
		g_bPushEnabled = FALSE;
		g_bNeedFirstApptRequest = TRUE;
		
		call RegisterPush(0);
	}
}

PUSH Get_Current_Meeting_Info
{
	call GetMeetingInfo(MEETING_INFO_CURRENT, MEETING_INFO_REQUEST_ATTENDEES, MeetingEvent[g_iCurrentEventNum].MeetingID); 
}

PUSH Get_Next_Meeting_Info
{
	call UpdateNextReservInfo();
	
	call GetMeetingInfo(MEETING_INFO_NEXT, MEETING_INFO_REQUEST_ATTENDEES, NextEvent.MeetingID); 
}

PUSH Get_Current_Meeting_Info_Timeout
{
	g_sCurrentMeetingInfoRequestID = "";

  Current_Meeting_Required_Attendees$ = "Data Timeout!";
  Current_Meeting_Optional_Attendees$ = "Data Timeout!";
	
	Current_Meeting_Info_Request_Mode = REQUEST_MODE_FAILURE;
	
	wait(100)
	{
	  Current_Meeting_Required_Attendees$ = "";
	  Current_Meeting_Optional_Attendees$ = "";	
		
		Current_Meeting_Info_Request_Mode = REQUEST_MODE_IDLE;
	}
}

PUSH Get_Current_Meeting_Preset_Data_Timeout
{
	g_sCurrentMeetingPresetDataRequestID = "";
	g_sLastSentGetPresetDataID = "";
	g_iLastSentGetPresetDataIndex = 0;
}

PUSH Get_Next_Meeting_Info_Timeout
{
	g_sNextMeetingInfoRequestID = "";
  
  Next_Reservation_Required_Attendees$ = "Data Timeout!";
  Next_Reservation_Optional_Attendees$ = "Data Timeout!";
	
	Next_Meeting_Info_Request_Mode = REQUEST_MODE_FAILURE;
	
	wait(100)
	{	  
	  Next_Reservation_Required_Attendees$ = "";
	  Next_Reservation_Optional_Attendees$ = "";	
		
		Next_Meeting_Info_Request_Mode = REQUEST_MODE_IDLE;
	}
}


CHANGE From_RV_ScheduleResponse$
{  
  	if(Debug_Preset_Data) Print("Change Event From_RV_ScheduleResponse$\ng_bRXOK1 = %u\n", g_bRXOK1);

	if (g_bRXOK1)
  	{
    	g_bRXOK1 = FALSE;
        
		if(Debug_Preset_Data) Print("Inside if (g_bRXOK1)\ng_bRXOK1 = %u\n", g_bRXOK1);   
	    
		while(find("</ScheduleResponse>", From_RV_ScheduleResponse$))
	    {
	    	g_sRXData1 = remove("</ScheduleResponse>", From_RV_ScheduleResponse$); 
	    	
	    	if(Debug_Preset_Data) Print("Inside CHANGE From_RV_ScheduleResponse$ While Loop\ng_sRXData1 = %s\n", g_sRXData1);
			if (Debug_Logic)
	    	{
	    		trace ("** End ScheduleResponse Found **\n");
	    	}
	    	
	      	call ProcessFromRVScheduleResponse$();
	    }
		g_bRXOK1 = True;
		if(Debug_Preset_Data) Print("Outside while(find(\x22</ScheduleResponse>\x22, From_RV_ScheduleResponse$))\ng_bRXOK1 = %u\n", g_bRXOK1);
  	}    
}

CHANGE From_RV_CreateResponse$
{  
  if (g_bRXOK2)
  {
    g_bRXOK2 = FALSE;
    
    while(find("</CreateScheduleResponse>", From_RV_CreateResponse$))
    {
    	g_sRXData2 = remove("</CreateScheduleResponse>", From_RV_CreateResponse$);
    	
    	if (Debug_Logic)
    	{
    		trace ("** End CreateResponse Found **\n");
    	}
      
      call ProcessFromRVCreateResponse$();
    }

	g_bRXOK2 = True;
  }
}

CHANGE From_RV_ActionResponse$
{
	
	if (g_bRXOK3)
	{
		g_bRXOK3 = FALSE;
		
		while(find("</ActionResponse>", From_RV_ActionResponse$))
		{
			g_sRXData3 = remove("</ActionResponse>", From_RV_ActionResponse$);

	    	if (Debug_Logic)
	    	{
	    		trace ("** End ActionResponse Found **\n");
	        	trace ("g_sRXData3: %s\n", g_sRXData3);
	    	}
      
      		call ProcessFromRVActionResponse$();
		}

		g_bRXOK3 = True;
	}
}

CHANGE From_MeetingPreset_Mod_DataOut$
{
	string sTrash[50];

	if (find("<MeetingPresetModule>Hello</MeetingPresetModule>", From_MeetingPreset_Mod_DataOut$))
	{
		if (Debug_Logic)
		 trace ("\n ** Meeting Info Module Connected **\n");
		
		g_bHaveMeetingPresetModule = TRUE;		
	}	
	else if (find("<StartedEvent>", From_MeetingPreset_Mod_DataOut$))
	{
		g_iStartedEventNum = atoi(From_MeetingPreset_Mod_DataOut$);
		g_sStartedEventID = MeetingEvent[g_iStartedEventNum].MeetingID;
		
		call CheckRoomStatus(FALSE);
	}
	else if (find("<EndMeeting>", From_MeetingPreset_Mod_DataOut$))
	{		
		g_iStartedEventNum = 0;
		g_sStartedEventID = "";
		
		call CheckRoomStatus(FALSE);
	}
	else if (find("<WelcomeMsg>", From_MeetingPreset_Mod_DataOut$))
	{
		sTrash = remove("<WelcomeMsg>", From_MeetingPreset_Mod_DataOut$);
		
		g_sCurrentWelcomeMsg = left(From_MeetingPreset_Mod_DataOut$, len(From_MeetingPreset_Mod_DataOut$) - 13);
		
		call UpdateCurrentMeetingInfo();
	}
}

CHANGE From_Remote_Sys_Mod_DataOut$
{	
	if (find("<RemoteSystemData>Hello</RemoteSystemData>", From_Remote_Sys_Mod_DataOut$))
	{
		// Remote system module is connected.
		
		if (Debug_Logic)
		 trace ("\n ** Remote System Module Connected **\n");		
		
		g_bHaveRemoteSysModule = TRUE;
	}
	else if (find("<Get ID=\x22AllData\x22 />", From_Remote_Sys_Mod_DataOut$))
	{
		call SendRemoteSystemData(REM_SYS_DATA_WORKDAY, "");
		call SendRemoteSystemData(REM_SYS_DATA_CURR_MEETING, "");
		call SendRemoteSystemData(REM_SYS_DATA_NEXT_RESERV, "");
		call SendRemoteSystemData(REM_SYS_DATA_DATE_TIME, "");
	}
	else if (find("<Get ID=\x22WorkdaySchedule\x22 />", From_Remote_Sys_Mod_DataOut$))
	{
		call SendRemoteSystemData(REM_SYS_DATA_WORKDAY, "");
	}
	else if (find("<Get ID=\x22CurrentMeetingInfo\x22 />", From_Remote_Sys_Mod_DataOut$))
	{
		call SendRemoteSystemData(REM_SYS_DATA_CURR_MEETING, "");
	}
	else if (find("<Get ID=\x22NextReservation\x22 />", From_Remote_Sys_Mod_DataOut$))
	{
		call SendRemoteSystemData(REM_SYS_DATA_NEXT_RESERV, "");
	}
	else if (find("<Get ID=\x22DateTime\x22 />", From_Remote_Sys_Mod_DataOut$))
	{
		call SendRemoteSystemData(REM_SYS_DATA_DATE_TIME, "");
	}
}

/*******************************************************************************************
  Main()
  Uncomment and place one-time startup code here
  (This code will get called when the system starts up)
*******************************************************************************************/
/*
Function Main()
{
  integer i;
  
  WaitForInitializationComplete();
  

}
/*